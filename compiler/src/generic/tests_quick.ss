
(define tests_quick
  '( (let ([f (lambda (x) x)])
       (add1 (f 0)))
     (let ([f (lambda (y) y)]) (f (f 4)))
     ((lambda (f) (f (f 4))) (lambda (y) y))
     ((let ([a 4000])
        (lambda (b) (+ a b)))
      5000)
     (((lambda (a)
         (lambda (b)
           (+ a b)))
       4000)
      5000)
     (let ([f (lambda (x) (add1 x))]) (f (f 0)))
     ((lambda (f) (f (f 0))) (lambda (x) (add1 x)))
     (let ([x 0] [f (lambda (x) x)])
       (let ([a (f x)] [b (f x)] [c (f x)]) (+ (+ a b) c)))
     (let ([x 0][y 1][z 2][f (lambda (x) x)])
       (let ([a (f x)][b (f y)][c (f z)])
         (+ (+ a b) c)))
     (let ([f (lambda (x y) x)])
       (f 0 1))
     (let ([x (add1 (letrec ([y (lambda () 4)]) (y)))]) x)
     (let ([f (lambda (x y) x)])
       (let ([a (f 0 1)]) (f a a)))
     (let ([x 0] [y 1] [z 2] [f (lambda (x y z) x)])
       (let ([a (f x y z)]) (f a a a)))
     (let ([x 0] [y 1] [z 2] [f (lambda (x y z) x)])
       (let ([a (f x y z)] [b y] [c z]) (f a b c)))
     (let ([f (lambda (a b c d)
                (+ a d))])
       (f 0 1 2 3))
     (let ([f (lambda (x) x)])
       (+ (f 0)
          (let ([a 0] [b 1] [c 2])
            (+ (f a) (+ (f b) (f c))))))
     (let ([f (lambda (x) x)])
       (+ (f 0)
          (let ([a 0] [b 1] [c 2])
            (add1 (f a)))))
     (let ([f (lambda (x) x)])
       (let ([a 1])
         (* (+ (f a) a) a)))
     
     (let ([k (lambda (x y) x)])
       (let ([b 17])
         ((k (k k 37) 37) b (* b b))))
     
     (let ([f (lambda ()
                (let ([n 256])
                  (let ([v (make-vector n)])
                    (vector-set! v 32 n)
                    (vector-ref v 32))))])
       (pair? (f)))
     (let ((w 4) (x 8) (y 16) (z 32))
       (let ((f (lambda ()
                  (+ w (+ x (+ y z))))))
         (f)))
     (let ([f (lambda (x) x)])
       (+ (f 0) (let ([a 0][b 1][c 2][d 3])
                  (+ (f a)
                     (+ (f b)
                        (+ (f c)
                           (f d)))))))
     
     ;(let ([a 0])(letrec ([a (lambda () 0)][b (lambda () 11)]) (set! a 11)))
     (let ([a 0])(letrec ([a (lambda () 0)][b (lambda () 11)])
                   (eq? (void) (set! a 11))))
     ;(let ([a 0])(letrec ([a (lambda () (set! a 0))][b 11]) (a)))
     (let ([a 0])(letrec ([a (lambda () (set! a 0))][b 11])
                   (eq? (void) (a))))
     (letrec ([a (lambda () 0)]) (a))
     (letrec ([a (lambda () 0)] [b (lambda () 11)]) (a))
     (let ([z 4])
       (letrec ([f (lambda (x)
                     (letrec ([g (lambda (y)
                                   (if (= y 0) 0
                                       (f (- y 1))))])
                       (g x)))])
         (f z)))
     ;(let ([x 0]) (letrec ([a (lambda () 0)] [b (lambda () 11)]) (set! x 11)))
     (let ([x 0]) (letrec ([a (lambda () 0)] [b (lambda () 11)])
                    (eq? (void) (set! x 11))))
     (let ([f (let ([x 1]) (lambda (y) (+ x y)))])
       (let ([x 0]) (f (f x))))
     ((let ([t (lambda (x) (+ x 50))])
        (lambda (f) (t (f 1000))))
      (lambda (y) (+ y 2000)))
     (let ([x 0])
       (let ([f (let ([x 1]
                      [z x])
                  (lambda (y)
                    (+ x (+ z y))))])
         (f (f x))))
     (((lambda (t)
         (lambda (f) (t (f 1000))))
       (lambda (x) (+ x 50)))
      (lambda (y) (+ y 2000)))
     ((let ([t 50])
        (lambda (f)
          (+ t (f))))
      (lambda () 2000))
     (((lambda (t)
         (lambda (f)
           (+ t (f))))
       50)
      (lambda () 2000))
     ((let ([x 300])
        (lambda (y) (+ x y)))
      400)
     (let ([x 3] [f (lambda (x y) x)])
       (f (f 0 0) x))
     (let ([x 3] [f (lambda (x y) x)])
       (if (f 0 0) (f (f 0 0) x) 0))
     (let ([x02 3] [f01 (lambda (x04 y03) x04)])
       (if (not x02) (f01 (f01 0 0) x02) 0))
     (let ((f (lambda (x) (if (if (pair? x) (not (eq? (car x) 0)) #f) x #f))))
       (f (cons 0 0)))
     (let ((f (lambda (x)
                (if (if x (not (if (pair? x) (not (eq? (car x) 0)) #f)) #f)
                    x #f))))
       (f 0))
     (let ((f (lambda (x) (if (if (pair? x) #t (null? x)) x '()))))
       (f 0))
     (let ([y 4])
       (let ([f (lambda (y) y)])
         (f (f y))))
     (let ([y 4])
       (let ([f (lambda (x y) 0)])
         (f (f y y) (f y y))))
     (let ([y 4])
       (let ([f (lambda (x y) 0)])
         (f (f y y) (f y (f y y)))))
     (let ([y 4])
       (let ([f (lambda (x y) 0)])
         (f (f y (f y y)) (f y (f y y)))))
     ((lambda (y) ((lambda (f) (f (f y))) (lambda (y) y))) 4)
     (let ([f (lambda (x) (+ x x))]) (f 4000))
     (let ((x (if 1000 2000 3000)))
       x)
     (let ([f (lambda (x) x)])
       (add1 (if #f 1 (f 22))))
     (let ([f (lambda (x) x)])
       (if (f (zero? 23)) 1 22))
     (let ([f (lambda () 0)])
       (let ([x (f)])
         1))
     (let ([f (lambda () 0)])
       (begin (f) 1))
     (let ([f (lambda (x) x)])
       (if #t (begin (f 3) 4) 5))
     (let ([f (lambda (x) x)])
       (begin (if #t (f 4) 5) 6))
     (let ([f (lambda (x) x)])
       (begin
         (if (f #t)
             (begin
               (f 3)
               (f 4))
             (f 5))
         (f 6)))
     (let ([f (lambda (x) (add1 x))])
       (f (let ([f 3]) (+ f 1))))
     (let ((x 15)
           (f (lambda (h v) (* h v)))
           (k (lambda (x) (+ x 5)))
           (g (lambda (x) (add1 x))))
       (k (g (let ((g 3)) (f g x)))))
     (let ([x 4])
       (let ([f (lambda () x)])
         (set! x 5)
         (f)))
     (letrec ([one (lambda (n) (if (zero? n) 1 (one (sub1 n))))])
       (one 13))
     (letrec ((fact (lambda (n) (if (zero? n) 1 (* n (fact (sub1 n)))))))
       (fact 5))
     (letrec ([remq (lambda (x ls)
                      (if (null? ls)
                          '()
                          (if (eq? (car ls) x)
                              (remq x (cdr ls))
                              (cons (car ls) (remq x (cdr ls))))))])
       (remq 3 '(3 1 3)))
     (let ([f (lambda () 80)])
       (let ([a (f)] [b (f)])
         0))
     (let ([f (lambda () 80)])
       (let ([a (f)] [b (f)])
         (* a b)))
     (let ([f (lambda () 80)]
           [g (lambda () 80)])
       (let ([a (f)] [b (g)])
         (* a b)))
     (let ([fact
             (lambda (fact n)
               (if (zero? n) 1 (* (fact fact (sub1 n)) n)))])
       (fact fact 5))
     (let ([f (lambda (x) (+ x 1000))])
       (if (zero? (f -2)) (f 6000) (f (f 8000))))
     (let ([f (lambda (x) (+ x 1000))])
       (if (zero? (f -1)) (f 6000) (f (f 8000))))
     (let ((f (lambda (x y) (+ x 1000))))
       (+ (if (f 3000 (begin 0 0 0)) (f (f 4000 0) 0) 8000) 2000))
     ((((lambda (x)
          (lambda (y)
            (lambda (z)
              (+ x (+ y (+ z y))))))
        5) 6) 7)
     (let ((f (lambda (x) x)))
       (if (procedure? f)
           #t
           #f))
     (let ((sum (lambda (sum ls)
                  (if (null? ls)
                      0
                      (+ (car ls) (sum sum (cdr ls)))))))
       (sum sum (cons 1 (cons 2 (cons 3 '())))))
     (((lambda (a)
         (lambda ()
           (+ a (if #t 200))
           1500))
       1000))
     (((lambda (b)
         (lambda (a) (set! a (if 1 2)) (+ a b)))
       100)
      200)
     ((((lambda (a) (lambda (b) (lambda (c) (+ a (+ b c))))) 10) 20) 30)
     (+ 2 3)
     ((lambda (a) (+ 2 a)) 3)
     (((lambda (b) (lambda (a) (+ b a))) 3) 2)
     ((lambda (b) ((lambda (a) (+ b a)) 2)) 3)
     ((lambda (f) (f (f 5))) (lambda (x) x))
     ((let ((f (lambda (x) (+ x 3000))))
        (lambda (y) (f (f y))))
      2000)
     (let ((n 17) (s 18) (t 19))
       (let ((st (make-vector 5)))
         (vector-set! st 0 n)
         (vector-set! st 1 s)
         (vector-set! st 2 t)
         (if (not (vector? st))
             10000
             (vector-length st))))
     (let ((s (make-vector 1)))
       (vector-set! s 0 82)
       (if (eq? (vector-ref s 0) 82) 1000 2000))
     (not 17)
     (not #f)
     (let ([fact
             (lambda (fact n acc)
               (if (zero? n) acc (fact fact (sub1 n) (* n acc))))])
       (fact fact 5 1))
     ((lambda (b c a)
        (let ((b (+ b a))
              (a (+ a (let ((a (+ b b))
                            (c (+ c c)))
                        (+ a a)))))
          (* a a)))
      2 3 4)
     (let ((f (lambda (x) (lambda () (x))))) ((f (lambda () 3))))
     (letrec ((f (lambda (x) (if (zero? x) 1 (* x (f (- x 1)))))))
       (let ((g (lambda (a) (lambda (b) (a b)))))
         ((g f) 10)))
     (let ((f (lambda (g u) (g (if u (g 37) u)))))
       (f (lambda (x) x) 75))
     
     (let ((f (lambda (h u) (h (if u (h (+ u 37)) u))))
           (w 62))
       (f (lambda (x) (- w x)) (* 75 w)))
     (letrec ((f (lambda (x) (+ x 1)))
              (g (lambda (y) (f (f y)))))
       (set! f (lambda (x) (- x 1)))
       (+ (f 1) (g 1)))
     
     (let ([x 5] [th (let ((a 1)) (lambda () a))])
       (letrec ([fact (lambda (n th)
                        (if (zero? n)
                            (th)
                            (* n (fact (- n 1) th))))])
         (fact x th)))
     
     ;; This breaks hotdog:
     #;(letrec ([iota-fill!
                  (lambda (v i n)
                    (if (not (= i n))
                        (begin
                          (vector-set! v i i)
                          (iota-fill! v (+ i 1) n))))])
         (let ([n 4])
           (let ([v (make-vector n)])
             (iota-fill! v 0 n)
             v)))
     ;; Renaming fixes it.
     (letrec ((iota-fill!
                (lambda (vec i num)
                  (if (not (= i num))
                      (begin (vector-set! vec i i)
                             (iota-fill! vec (+ i 1) num))))))
       (let ((len 4))
         (let ((avec (make-vector len)))
           (begin
             (iota-fill! avec 0 len)
             avec))))
     ))

