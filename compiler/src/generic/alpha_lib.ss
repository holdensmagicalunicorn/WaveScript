
;; These are used by code generated by compile-simulate-alpha.

;; ======================================================================
;; Simulator runtime
  
(define (alpha-it tm)
  (eval `(define alph ',(compile-simulate-alpha tm)))
  (eval (compile-simulate-alpha tm)))

;; This returns:
;; 1) meta-token-handler of type (msg-object, vtime -> ())
;; 2) a cost-table mapping toknames to vtime costs
(define (node-code this)
  (define-structure (tokstore))
  "This is the simulation seed."
  "It returns an initial set of scheduled actions for the simulator to execute."
  (let ([local-sense
         (lambda ()
           ((current-sense-function)
            (node-pos (simobject-node this))))])
    (let* ()
      (letrec ([node-start
                (lambda (current-vtime subtok-index)
                  (let* ([the-store (simobject-token-store this)]
                         [this-tokname (cons 'node-start subtok-index)]
                         [old-outgoing (simobject-outgoing-msg-buf this)]
                         [old-local (simobject-local-msg-buf this)])
		    (logger "node-starte...~n")
                    "Is there already an allocated token object?:"
                    (let ([tokobj (hashtab-get the-store this-tokname)])
                      (if (not tokobj)
                          (begin "If not, then we allocate that token object..."
                                 " setting the invoke counter to zero."
                                 (set! tokobj (vector 0))
                                 (hashtab-set!
                                   the-store
                                   this-tokname
                                   tokobj)))
                      (set-simobject-outgoing-msg-buf! this '())
                      (set-simobject-local-msg-buf! this '())
                      (display "N")
                      (set-simobject-outgoing-msg-buf!
                        this
                        (append
                          (reverse (simobject-outgoing-msg-buf this))
                          old-outgoing))
                      (set-simobject-local-msg-buf!
                        this
                        (append
                          (reverse (simobject-local-msg-buf this))
                          old-local))
                      (void))))]
               [soc-start
                (lambda (current-vtime subtok-index)
                  (let* ([the-store (simobject-token-store this)]
                         [this-tokname (cons 'soc-start subtok-index)]
                         [old-outgoing (simobject-outgoing-msg-buf this)]
                         [old-local (simobject-local-msg-buf this)])
                    "Is there already an allocated token object?:"
                    (let ([tokobj (hashtab-get the-store this-tokname)])
                      (if (not tokobj)
                          (begin "If not, then we allocate that token object..."
                                 " setting the invoke counter to zero."
                                 (set! tokobj (vector 0))
                                 (hashtab-set!
                                   the-store
                                   this-tokname
                                   tokobj)))
                      (set-simobject-outgoing-msg-buf! this '())
                      (set-simobject-local-msg-buf! this '())
                      (begin (printf "S")
                             (set-simobject-local-msg-buf!
                               this
                               (cons (make-simevt
                                       #f
                                       3
                                       (bare-msg-object
                                         'tok1
                                         (list)
                                         current-vtime))
                                     (simobject-local-msg-buf this))))

		      (logger "SOC-start locals ~a...~n"
			      (simobject-local-msg-buf this))

                      (set-simobject-outgoing-msg-buf!
                        this
                        (append
                          (reverse (simobject-outgoing-msg-buf this))
                          old-outgoing))
                      (set-simobject-local-msg-buf!
                        this
                        (append
                          (reverse (simobject-local-msg-buf this))
                          old-local))
                      (void))))]
               [tok1
                (lambda (current-vtime subtok-index)
                  (let* ([the-store (simobject-token-store this)]
                         [this-tokname (cons 'tok1 subtok-index)]
                         [old-outgoing (simobject-outgoing-msg-buf this)]
                         [old-local (simobject-local-msg-buf this)])
                    "Is there already an allocated token object?:"
                    (let ([tokobj (hashtab-get the-store this-tokname)])
                      (if (not tokobj)
                          (begin "If not, then we allocate that token object..."
                                 " setting the invoke counter to zero."
                                 (set! tokobj (vector 0))
                                 (hashtab-set!
                                   the-store
                                   this-tokname
                                   tokobj)))
                      (set-simobject-outgoing-msg-buf! this '())
                      (set-simobject-local-msg-buf! this '())
                      (begin (display ".")
                             (set-simobject-outgoing-msg-buf!
                               this
                               (cons (make-simevt
                                       #f
                                       2
                                       (bare-msg-object
                                         'tok2
                                         (list "!")
                                         current-vtime))
                                     (simobject-local-msg-buf this))))
                      (set-simobject-outgoing-msg-buf!
                        this
                        (append
                          (reverse (simobject-outgoing-msg-buf this))
                          old-outgoing))
                      (set-simobject-local-msg-buf!
                        this
                        (append
                          (reverse (simobject-local-msg-buf this))
                          old-local))
                      (void))))]
               [tok2
                (lambda (current-vtime subtok-index x)
                  (let* ([the-store (simobject-token-store this)]
                         [this-tokname (cons 'tok2 subtok-index)]
                         [old-outgoing (simobject-outgoing-msg-buf this)]
                         [old-local (simobject-local-msg-buf this)])
                    "Is there already an allocated token object?:"
                    (let ([tokobj (hashtab-get the-store this-tokname)])
                      (if (not tokobj)
                          (begin "If not, then we allocate that token object..."
                                 " setting the invoke counter to zero."
                                 (set! tokobj (vector 0))
                                 (hashtab-set!
                                   the-store
                                   this-tokname
                                   tokobj)))
                      (set-simobject-outgoing-msg-buf! this '())
                      (set-simobject-local-msg-buf! this '())
                      (set-simobject-timed-token-buf!
                        this
                        (cons (make-simevt
                                (+ 500 current-vtime)
                                1
                                (bare-msg-object
                                  'tok3
                                  (list x)
                                  current-vtime))
                              (simobject-timed-token-buf this)))
                      (set-simobject-outgoing-msg-buf!
                        this
                        (append
                          (reverse (simobject-outgoing-msg-buf this))
                          old-outgoing))
                      (set-simobject-local-msg-buf!
                        this
                        (append
                          (reverse (simobject-local-msg-buf this))
                          old-local))
                      (void))))]
               [tok3
                (lambda (current-vtime subtok-index y)
                  (let* ([the-store (simobject-token-store this)]
                         [this-tokname (cons 'tok3 subtok-index)]
                         [old-outgoing (simobject-outgoing-msg-buf this)]
                         [old-local (simobject-local-msg-buf this)])
                    "Is there already an allocated token object?:"
                    (let ([tokobj (hashtab-get the-store this-tokname)])
                      (if (not tokobj)
                          (begin "If not, then we allocate that token object..."
                                 " setting the invoke counter to zero."
                                 (set! tokobj (vector 0))
                                 (hashtab-set!
                                   the-store
                                   this-tokname
                                   tokobj)))
                      (set-simobject-outgoing-msg-buf! this '())
                      (set-simobject-local-msg-buf! this '())
                      (display y)
                      (set-simobject-outgoing-msg-buf!
                        this
                        (append
                          (reverse (simobject-outgoing-msg-buf this))
                          old-outgoing))
                      (set-simobject-local-msg-buf!
                        this
                        (append
                          (reverse (simobject-local-msg-buf this))
                          old-local))
                      (void))))])
        (let ([dyndispatch_table (make-default-hash-table)])
          (begin (hashtab-set!
                   dyndispatch_table
                   'node-start
                   node-start)
                 (hashtab-set! dyndispatch_table 'soc-start soc-start)
                 (hashtab-set! dyndispatch_table 'tok1 tok1)
                 (hashtab-set! dyndispatch_table 'tok2 tok2)
                 (hashtab-set! dyndispatch_table 'tok3 tok3))
          (values
            (lambda (msgob current-vtime)
              (mvlet
                (((name subtok)
                  (let ([tok (msg-object-token msgob)])
                    (if (pair? tok)
                        (values (car tok) (cdr tok))
                        (values tok 0)))))
                (let ([handler (hashtab-get dyndispatch_table name)])
                  (apply
                    handler
                    current-vtime
                    subtok
                    (msg-object-args msgob)))))
            '((node-start 1)
              (soc-start 3)
              (tok1 3)
              (tok2 2)
              (tok3 1))))))))


(define (evntcmpr a b) 
  (cond 
    [(not (simevt-vtime a)) #t]
    [(not (simevt-vtime b)) #f]
    [else (<= (simevt-vtime a) (simevt-vtime b))]))

;; This builds a simulation object for a specific node in the network.
;; This object drives the simulation for that node.  
;; When the simulation object is invoked once, it processes all
;; incoming and queued messages and returns the next action to be executed.
;; The execution of that atomic action (token handler) produces new messages
;; both in *this* simobject, and in the incoming fields of other simobjects.

;; It returns this simulation object as a thunk.
;; The thunk produces simevt's, but with action-thunks in the msgobj field 
(define build-node-sim
  (lambda (ob world node-code)
    ;; the scheduling queue contains event entries of the format:
    ;;   [<vtime-to-exec>, <duration>, <msg-object>]
    ;; which are also returned from sim-seed in this format.
    
      ;; Schedule either adds an event to the schedule, 
      ;; or returns the current schedule in list form.
    (define private-scheduler
      (let ([buffer '()] ;; Contains simevts
            [private-vtime 0])
	(lambda args
	  (match args 
	    [(get-buffer) buffer]
	    [(get-time) private-vtime]
            [(head) (if (null? buffer) #f
                        (let ([next (car buffer)])
                          (make-simevt
                           (if (simevt-vtime next)
                               (max (simevt-vtime next) private-vtime)
                               private-vtime)
                           (simevt-duration next)
                           (simevt-msgobj next))))]
	    [(pop)
	     (if (null? buffer)
		 (error 'alpha-lib:build-node-sim "Can't pop from null scheduling queue"))
	     (logger 3 "~a: Popped off action: ~a at vtime ~a ~n" 
		     (node-id (simobject-node ob))
		     (msg-object-token (simevt-msgobj (car buffer)))
		     (simevt-vtime (car buffer)))
	     (set! buffer (cdr buffer))]
            [(set-time ,current-vtime)
	     (logger 3 "~a: Set time: ~a ~n"
		     (node-id (simobject-node ob))
		     current-vtime)
             (private-scheduler 'advance-time (- current-vtime private-vtime))]
	    [(advance-time ,increment)
	     (if (< increment 0)
		 (logger 2 "~a: WARNING, attempted negative time advance by ~a~n"
			 (node-id (simobject-node ob))
			 increment))
	     ;; Here we update the schedule to deal with the new local clock.
             (when (> increment 0) ;; Fizzle if the increment is not positive
	       (logger 3 "~a: Incrementing time by ~a, from ~a ~n"
		       (node-id (simobject-node ob))
		       increment private-vtime)
               (set! private-vtime (+ private-vtime increment))
               ;; This is where we make sure we have time to run the
               ;; things we want to run before the next hard timing constraint:
               (mvlet ([(flexible rest) (split-before simevt-vtime buffer)])
                      (if (not (null? rest))
                          (let* ([nexttime (simevt-vtime (car rest))]
                                 [time-remaining (- nexttime private-vtime)])
                            (mvlet ([(cando letslide)
                                     (let loop ([acc '()] [budget time-remaining] [evts flexible])
                                       (cond 
                                         [(null? evts) (values flexible '())]
                                         [(< budget (simevt-duration (car evts)))
                                          ;; We can't afford it, stop here:
                                          (values (reverse! acc) evts)]
                                         [else (loop (cons (car evts) acc) 
                                                     (- budget (simevt-duration (car evts)))
                                                     (cdr evts))]))])
                                   (if (not (null? letslide))
                                       (set! buffer
                                             (append cando
                                                     (list (car rest))
                                                     letslide ;; Let them slide till after the timed event
                                                     (cdr rest)))))))))]
            [(schedule ,current-vtime . ,newevnts)
	     (unless (null? newevnts)
		(logger 3 "~a: Scheduling ~a new events ~a~n"
			(node-id (simobject-node ob))
			(length newevnts)
			(map (lambda (e) (msg-object-token (simevt-msgobj e))) newevnts))
		(set! buffer (merge evntcmpr newevnts buffer))
		(private-scheduler 'set-time current-vtime))]
	    ))))

    
    (define (process-incoming current-vtime)      
      (define schedule (simobject-scheduler ob))

      '(logger 1.5 "Processing Node ~a incoming: ~a local,  ~a timed,  ~a remote~n"
	      (node-id (simobject-node ob))
	      (length (simobject-local-msg-buf ob))
	      (length (simobject-timed-token-buf ob))
	      (length (simobject-incoming-msg-buf ob)))
      
      (if (not (null? (append (simobject-local-msg-buf ob)
			      (simobject-timed-token-buf ob)
			      (simobject-incoming-msg-buf ob))))			      
	  (logger 1.5 "Processing Node ~a incoming: ~a local,  ~a timed,  ~a remote~n"
		  (node-id (simobject-node ob))
		  (map (lambda (x) (msg-object-token (simevt-msgobj x))) (simobject-local-msg-buf ob))
		  (map (lambda (x) (msg-object-token (simevt-msgobj x))) (simobject-timed-token-buf ob))
		  (map (lambda (x) (msg-object-token (simevt-msgobj x))) (simobject-incoming-msg-buf ob))))


      (let ([timed (simobject-timed-token-buf ob)]
	    [local (simobject-local-msg-buf ob)]
	    [incoming (simobject-incoming-msg-buf ob)])
	(set-simobject-local-msg-buf! ob '())
	(set-simobject-timed-token-buf! ob '())
	(set-simobject-incoming-msg-buf! ob '())

	(if (not (andmap simevt? (append timed local incoming)))
	    (printf "NOT ALL SIMEVT ~a ~a ~a~n" 
		    timed local incoming))

      ;; Process incoming and local msgs:
      ;; Schedule timed local tokens:
      (apply schedule 'schedule current-vtime timed)
      (apply schedule 'schedule current-vtime local)
      (apply schedule 'schedule current-vtime incoming))
      )
  
    (define (launch-outgoing current-vtime)
      ;; This does the radio transmission, and puts msgs in their respective incoming buffers.
      ;; TODO: Here's where we insert the better radio model!!!
      (let ([outgoing (simobject-outgoing-msg-buf ob)])
	
	(unless (null? outgoing)
	;; They're all broadcasts for now
	(for-each (lambda (evt)
		    ;; Timestame the message:
		    (set-msg-object-sent-time! (simevt-msgobj evt) current-vtime)
		    ;(let ([newmsg (structure-copy (simevt-msgobj evt))])
		    )
		  outgoing)

	(let ((neighbors (graph-neighbors (simworld-object-graph world) ob)))
	  (logger "~a: bcast at time ~a to -> ~a~n" (node-id (simobject-node ob)) current-vtime
		  (map (lambda (x) (node-id (simobject-node x))) neighbors))
	  
	  (for-each 
	   (lambda (nbr)
	     (set-simobject-incoming-msg-buf! 
	      nbr (append  outgoing
			   (simobject-incoming-msg-buf nbr))))
	   neighbors)
	;; They're all delivered, so we clear our own outgoing buffer.
	  (set-simobject-outgoing-msg-buf! ob '())))))

    ;;========================================    
    ;; MAIN BODY:
    (mvlet ([(mhandler cost-table) (node-code ob)])
    ;; Install the scheduler and handler incase anybody else wants to use them:
    (set-simobject-scheduler! ob private-scheduler)
    (set-simobject-meta-handler! ob mhandler)

    ;; Clear out the buffers from any prior simulations:
    (set-simobject-local-msg-buf! ob '())
    (set-simobject-timed-token-buf! ob '())
    (set-simobject-outgoing-msg-buf! ob '())
    ;; The incoming buffer starts out with just the start actions SOC-start and node-start.
    (set-simobject-local-msg-buf! ob				
	(list (make-simevt 0
			   (cadr (assq 'node-start cost-table))
			   (bare-msg-object 'node-start '() 0))))
    (if (simobject-I-am-SOC ob)
	(set-simobject-local-msg-buf! ob
	   (cons (make-simevt 0
			      (cadr (assq 'node-start cost-table))
			      (bare-msg-object 'SOC-start '() 0))
		 (simobject-local-msg-buf ob))))

    ;; This is the simulation object, each time its executed it
    ;; processes incoming messages for the nodes, decides what action
    ;; is next and returns that action (as a simevt).  If there's no
    ;; next action, returns #f.  

    ;; If the simulation driver wishes to execute that action, it
    ;; does, which will run the handler, update the scheduler, and
    ;; modify the simobject.
    (lambda (global-mintime)

      (define scheduler (simobject-scheduler ob))
      (define ourtime_starting (scheduler 'get-time))
      
      ;; If our local clock has fallen behind the real one, advance it.
      ;; Ourtime represents the actual start time at which this potential action will run.
      (define ourtime
	(if (< ourtime_starting global-mintime)
	    ourtime_starting 
	    (begin (logger "~a: Fell behind global timer.  Advancing.~n"
			   (node-id (simobject-node ob)))
		   (scheduler 'set-time global-mintime)
		   global-mintime)))

      ;; First schedule any incoming messages we've received
      (process-incoming ourtime)

      (let ([next (scheduler 'head)])
	(if (not next) 
	    #f    ;; We just fizzle if our schedule is empty.  
            (begin 
	      (logger 3 "~a: Updated schedule, got head: vt~a d~a ~a, buffer ~a~n" 
		      (node-id (simobject-node ob))
		      (simevt-vtime next) (simevt-duration next)
		      (msg-object-token (simevt-msgobj next)) 
		      (map (lambda (evt) (list (simevt-vtime evt)
					       (msg-object-token (simevt-msgobj evt))))
			   (scheduler 'get-buffer)))
	      (make-simevt
               (simevt-vtime next)
               (simevt-duration next)
               ;; Action thunk that executes message:
               (lambda ()
		 ;; DEBUG:
		 (if (not (= ourtime (scheduler 'get-time)))
		     (error 'build-node-sim
			    "Local time changed between getting the new head and executing it!~n Node ~a, orig time ~a, current-time ~a"
			    (node-id (simobject-node ob))
			    ourtime
			    (scheduler 'get-time)))

                 ;(printf "Busting thunk, running action: ~a~n" next)
                 ;; For now, the time actually executed is what's scheduled
                 (logger "~a: Executing: ~a at mintime ~a localtime [was] ~a~n" 
			 (node-id (simobject-node ob))
			 (msg-object-token (simevt-msgobj next)) 
			 global-mintime
			 (scheduler 'get-time))

		 ;; DEBUG: check invariant:
		 '(if (not (null? (simobject-outgoing-msg-buf ob)))
		     (error 'build-node-sim 
			    "Trying to execute action at time ~a, but there's already an outgoing(s) msg: ~a~n"
			    global-mintime (simobject-outgoing-msg-buf ob)))

		 ;; Do the actual computation:
                 ((simobject-meta-handler ob) (simevt-msgobj next) (simevt-vtime next))
                 ;; Now that the atomic action is finished, do the radio transimission:		 
		 ;; The actual time that outgoing messages are launched is at the 
		 ;; end of the atomic actions completion:
                 (launch-outgoing (+ ourtime (simevt-duration next)))
                 
                 ;; Finally we must tell our scheduler that we have executed this action:
                 ;; First, advance the clock appropriately.
                 (scheduler 'advance-time (simevt-duration next))
                 (scheduler 'pop)  ;; Next, pop off that action since we're done with it.
                 )))))))))

(define global-graph #f)

(define (run-alpha-sim . stop-time)
    (if (file-exists? "__temp.log") (delete-file "__temp.log"))
    (simulation-logger (open-output-file "__temp.log" 'replace))
    ;(simulation-logger #f)
    
    (let ([stopping-time? (if (null? stop-time)
			      (lambda (t) #f)
			      (if (inexact? (car stop-time))
				  ;; It's in seconds:
				  (let ([end-time (+ (* 1000 (car stop-time)) (cpu-time))])
				    (printf "Stopping after ~a seconds.~n" (car stop-time))
				    (lambda (_) (>= (cpu-time) end-time)))
				  ;; Otherwise, vtime:
				  (begin (printf "Stopping after vtime ~a.~n" (car stop-time))
				  (lambda (t) (>= t (car stop-time))))))])
      (let* ([sim (fresh-simulation)]
	     [soc (car (filter (lambda (n) (eq? BASE_ID (node-id (simobject-node n))))
			       (simworld-all-objs sim)))]
	     [node-sims
	       (map (lambda (ob)
		      (build-node-sim ob
		       sim ;; the world
                       node-code ;; TODO: read from file
		       ))
		    (simworld-all-objs sim))])

	(set! global-graph (simworld-graph sim))

	;(printf "Starting!  Local: ~a~n" (map simobject-local-msg-buf (simworld-all-objs sim)))

	;; As this loop runs, the global (main-sim-loop) time is just the start time of the last executed action.
    (let/ec exit-loop
    (let main-sim-loop ([vtime 0])
      (logger 2 "  Main sim loop: vtime ~a (vtime of last action)~n" vtime)
      (logger 1.5 "  Local vtimes ~a~n" 
	      (map (lambda (ob) ((simobject-scheduler ob) 'get-time))
		   (simworld-all-objs sim)))
      
      (printf "<~a>" vtime)
      (if (stopping-time? vtime)
	  (printf "Out of time.~n")
;      (let ([nextevt
; 	     (let actionsloop ([sims node-sims] [best #f])
; 	       (if (null? sims) best
; 		   (let ([action ((car sims) vtime)])
; 		     (actionsloop (cdr sims)
; 				  (cond
; 				   [(not action) best]
; 				   [(not best) action]
; 				   [(evntcmpr action best) action]
; 				   [else best])))))])
; 	(if (not nextevt)
; 	    (printf "~n~a: Simulator ran fresh out of actions!~n"
; 		    'alpha-lib:run-alpha-sim)

	     ;; Less efficient but more functional way:
	      (let ([nextevt
		     (let ([actions (filter id (map (lambda (f) (f vtime)) node-sims))])
		       (if (null? actions)
			   (exit-loop 
			    (printf "~n~a: Simulator ran fresh out of actions!~n"
				    'alpha-lib:run-alpha-sim))
			   (let* ([nexttime (apply min (map simevt-vtime actions))])
			     (car (filter (lambda (se) (eq? nexttime (simevt-vtime se))) actions)))))])
	
	    (begin
	      ;; Run this atomic action (token handler), it gets to run at its intended virtual time.
              ;; We have lamely stored it in the msgobj field:
	      ((simevt-msgobj nextevt)) ;; This will execute the action and advance the clock internally.
              
	      ;; That had the effect of launching new messages to process.
	      (main-sim-loop (simevt-vtime nextevt)))))))
    
    ;; Out of main loop:
    (if (simulation-logger)
	(close-output-port (simulation-logger)))
    )))


;; From Swindle:
;;>> (merge less? a b)
;;>   Takes two lists `a' and `b' such that both (sorted? a less?) and
;;>   (sorted? b less?) are true, and returns a new list in which the
;;>   elements of `a' and `b' have been stably interleaved so that (sorted?
;;>   (merge less? a b) less?) is true.  Note: this does not accept vectors.
(define (merge less? a b)
  (cond [(null? a) b]
        [(null? b) a]
        [else (let loop ([x (car a)] [a (cdr a)] [y (car b)] [b (cdr b)])
                ;; The loop handles the merging of non-empty lists.  It has
                ;; been written this way to save testing and car/cdring.
                (if (less? y x)
                  (if (null? b)
                    (cons y (cons x a))
                    (cons y (loop x a (car b) (cdr b))))
                  ;; x <= y
                  (if (null? a)
                    (cons x (cons y b))
                    (cons x (loop (car a) (cdr a) y b)))))]))


;; ======================================================================
;; Gets set by .... Something?  TODO FIX UP:
;; All node level utilities below depend on this parameter being set properly.
[define this (make-parameter #f)]

;; ======================================================================
;; Node level utilities 

;; Is set to a list of all the leds that are toggled on.    
[define led-toggle-state '()]

;; MAKE SURE NOT TO INCLUDE OURSELVES:
[define (neighbors obj sim)
  (let ((entry (assq obj (simworld-object-graph sim))))
    (if (null? entry)
        (error 'neighbors "generated code.. .cannot find obj in graph: ~s ~n ~s"
               obj (simworld-object-graph sim))
        (begin 
          (if (memq obj (cdr entry))
              (error 'neighbors "we're in our own neighbors list"))
          (cdr entry))))]

[define sendmsg (lambda (data ob)
                  (set-simobject-incoming-msg-buf! ob
                                           (cons data (simobject-incoming-msg-buf ob)))
                  ;(set-simobject-redraw! ob #t)
                  )]


[define (sim-light-up r g b)
  ((sim-debug-logger) "~n~a: light-up ~a ~a ~a"
                      (node-id (simobject-node this)) r g b)
  (if (simobject-gobj this)
      (change-color! (simobject-gobj this) (rgb r g b))
      ;; We're allowing light-up of undrawn objects atm:
      ;(error 'sim-light-up "can't change color on undrawn object!: ~s" this)
      )]

;; INCOMPLETE (we don't yet draw the leds directly.)
[define (sim-leds what which)
  (let* ([colors 
          (case which
            [(red)   '(255 0 0)]
            [(green) '(0 255 0)]
            [(blue)  '(0 0 255)]
            [else (error 'sim-leds "bad color: ~a" which)])]
         ;; INCOMPLETE:
         ;	     [oldcolors '(0 0 0)]
         )
    (let ((string (format "~a: (time ~s) (Leds: ~a ~a ~a)~n" 	
                          (node-id (simobject-node this)) (cpu-time) which what
                          (case what
                            [(on) 
                             (set! led-toggle-state (list->set (cons which led-toggle-state)))
                             (apply sim-light-up colors)
                             "" ]
                            [(off)
                             (set! led-toggle-state (remq which led-toggle-state))
                             (sim-light-up '(0 0 0))
                             "" ]
                            [(toggle)
                             (if (memq which led-toggle-state)
                                 (begin 
                                   (set! led-toggle-state (remq which led-toggle-state))
                                   (sim-light-up 0 0 0)
                                   "off")
                                 (begin 
                                   (set! led-toggle-state (list->set (cons which led-toggle-state)))
                                   (apply sim-light-up colors)
                                   "on")
                                 )]
                            [else (error 'sim-leds "bad action: ~a" what)]))))
      ;((sim-debug-logger) string)
      (logger string)
      ))]

'[define (sim-dist . tok)
  (if (null? tok)
      (begin 
        (if (msg-object-count this-message)
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist) is broken!")))
      (let ((entry (hashtab-get (simobject-token-cache this) (car tok))))
        (if (and entry (msg-object-count entry))
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist ~s) but ~s has not been received!"
                   (car tok) (car tok))
            )))]

[define (sim-loc) ;; Return this nodes location.
  (node-pos (simobject-node this))]

[define (sim-locdiff a b)
  (sqrt (+ (expt (- (car a) (car b)) 2)
           (expt (- (cadr a) (cadr b)) 2)))]


(define (t)
  (alpha-it
   '(program
     (bindings)
     (nodepgm 
	 (tokens
	  [node-start () (stored) (display "N")]
	  ;[node-start () (stored) (void)]
	  [SOC-start () (stored) (begin (printf "S") (call tok1))]
	  [tok1 () (stored) (begin (display ".") (bcast tok2 "!"))]
	  [tok2 (x) (stored) (timed-call 500 tok3 x)]
	  [tok3 (y) (stored) (display y)]
	  )))))


;     (begin (t) (time (run-alpha-sim 10.0)))
