
;; These are used by code generated by compile-simulate-alpha.

;; ======================================================================
;; Simulator runtime
  
(define (alpha-it tm)
  (eval `(define alph ',(compile-simulate-alpha tm)))
  (eval (compile-simulate-alpha tm)))

;; This returns:
;; 1) meta-token-handler of type (msg-object, vtime -> ())
;; 2) a cost-table mapping toknames to vtime costs
(define (node-code this)
  (define-structure (tokstore))
  "This is the simulation seed."
  "It returns an initial set of scheduled actions for the simulator to execute."
  (let ([local-sense
         (lambda ()
           ((current-sense-function)
            (node-pos (simobject-node this))))])
    (let* ()
      (letrec ([node-start
                (lambda (current-vtime subtok-index)
                  (let* (#0=(the-store (simobject-token-store this))
                         [this-tokname
                          (cons 'node-start . #1=(subtok-index))]
                         .
                         #2=((old-outgoing
                               (simobject-outgoing-msg-buf this))
                             (old-local (simobject-local-msg-buf this))))
                    #3="Is there already an allocated token object?:"
                    (let #4=((tokobj (hashtab-get the-store this-tokname)))
                      (if #5=(not tokobj)
                          (begin #6="If not, then we allocate that token object..."
                                 #7=" setting the invoke counter to zero."
                                 (set! tokobj (vector 0))
                                 .
                                 #8=((hashtab-set!
                                       the-store
                                       this-tokname
                                       tokobj))))
                      #9=(set-simobject-outgoing-msg-buf! this '())
                      #10=(set-simobject-local-msg-buf! this '())
                      (display "N")
                      .
                      #11=((set-simobject-outgoing-msg-buf!
                             this
                             (append
                               (reverse (simobject-outgoing-msg-buf this))
                               old-outgoing))
                           (set-simobject-local-msg-buf!
                             this
                             (append
                               (reverse (simobject-local-msg-buf this))
                               old-local))
                           (void)))))]
               [soc-start
                (lambda (current-vtime subtok-index)
                  (let* (#0# [this-tokname (cons 'soc-start . #1#)] . #2#)
                    #3#
                    (let #4#
                      (if #5#
                          (begin #6# #7# (set! tokobj (vector 0)) . #8#))
                      #9#
                      #10#
                      (begin (printf "S")
                             (set-simobject-local-msg-buf!
                               this
                               (cons (make-simevt
                                       #f
                                       3
                                       (bare-msg-object
                                         'tok1
                                         (list)
                                         current-vtime))
                                     (simobject-local-msg-buf this))))
                      .
                      #11#)))]
               [tok1
                (lambda (current-vtime subtok-index)
                  (let* (#0# [this-tokname (cons 'tok1 . #1#)] . #2#)
                    #3#
                    (let #4#
                      (if #5#
                          (begin #6# #7# (set! tokobj (vector 0)) . #8#))
                      #9#
                      #10#
                      (begin (display ".")
                             (set-simobject-outgoing-msg-buf!
                               this
                               (cons (make-simevt
                                       #f
                                       2
                                       (bare-msg-object
                                         'tok2
                                         (list "!")
                                         current-vtime))
                                     (simobject-local-msg-buf this))))
                      .
                      #11#)))]
               [tok2
                (lambda (current-vtime subtok-index x)
                  (let* (#0# [this-tokname (cons 'tok2 . #1#)] . #2#)
                    #3#
                    (let #4#
                      (if #5#
                          (begin #6# #7# (set! tokobj (vector 0)) . #8#))
                      #9#
                      #10#
                      (set-simobject-timed-token-buf!
                        this
                        (cons (make-simevt
                                (+ 500 current-vtime)
                                1
                                (bare-msg-object
                                  'tok3
                                  (list x)
                                  current-vtime))
                              (simobject-timed-token-buf this)))
                      .
                      #11#)))]
               [tok3
                (lambda (current-vtime subtok-index y)
                  (let* (#0# [this-tokname (cons 'tok3 . #1#)] . #2#)
                    #3#
                    (let #4#
                      (if #5#
                          (begin #6# #7# (set! tokobj (vector 0)) . #8#))
                      #9#
                      #10#
                      (display y)
                      .
                      #11#)))])
        (let ([dyndispatch_table (make-default-hash-table)])
          (begin (hashtab-set!
                   dyndispatch_table
                   'node-start
                   node-start)
                 (hashtab-set! dyndispatch_table 'soc-start soc-start)
                 (hashtab-set! dyndispatch_table 'tok1 tok1)
                 (hashtab-set! dyndispatch_table 'tok2 tok2)
                 (hashtab-set! dyndispatch_table 'tok3 tok3))
          (values
            (lambda (msgob current-vtime)
              (mvlet
                (((name subtok)
                  (let ([tok (msg-object-token msgob)])
                    (if (pair? tok)
                        (values (car tok) (cdr tok))
                        (values tok 0)))))
                (let ([handler (hashtab-get dyndispatch_table name)])
                  (apply
                    handler
                    current-vtime
                    subtok
                    (msg-object-args msgob)))))
            '((node-start 1)
              (soc-start 3)
              (tok1 3)
              (tok2 2)
              (tok3 1))))))))

;; #f trumps any time, EXCEPT 0, 0 trumps all.
(define (evntlessthan a b)
  (vtimelessthan (simevt-vtime a) (simevt-vtime b)))

(define (vtimelessthan at bt)
  (cond
   [(zero? at) #t]
   [(zero? bt) #f]
   [(not at) #t]
   [(not bt) #f]
   [else (<= at bt)]))

;; This builds a simulation object for a specific node in the network.
;; This object drives the simulation for that node.  
;; When the simulation object is invoked once, it processes all
;; incoming and queued messages and returns the next action to be executed.
;; The execution of that atomic action (token handler) produces new messages
;; both in *this* simobject, and in the incoming fields of other simobjects.

;; Matt's right, this is more complexity than was necessary.
;; The local-time/global-time distinction is confusing.

;; It returns this simulation object as a thunk.
;; The thunk produces simevt's, but with action-thunks in the msgobj field 
(define build-node-sim
  (lambda (ob world node-code)
    ;; the scheduling queue contains event entries of the format:
    ;;   [<vtime-to-exec>, <duration>, <msg-object>]
    ;; which are also returned from sim-seed in this format.
    
      ;; Schedule either adds an event to the schedule, 
      ;; or returns the current schedule in list form.
    (define private-scheduler
      (let ([buffer '()] ;; Contains simevts
            [private-vtime 0]) ;; Local clock
	(lambda args
	  (match args 
	    [(get-buffer) buffer]
	    [(get-time) private-vtime]

	    ;; The head action on the buffer (next to execute) must be
	    ;; scheduled for a time g/equal the current local clock
	    ;; time.
            [(head) (if (null? buffer) #f
                        (let ([next (car buffer)])
			  (DEBUGMODE 
			   (if (and (simevt-vtime next)
				    (< (simevt-vtime next) private-vtime))
			       (logger 0 
				       "~a: WARNING: token event ~a has time in the past (~a) relative to current local clock (~a)~n"
				       (node-id (simobject-node ob))
				       (msg-object-token (simevt-msgobj next))
				       (simevt-vtime next)
				       private-vtime)))

                          (make-simevt
                           (if (simevt-vtime next)
			       ;; If for some reason it was scheduled earlier than the current clock time,
			       ;; bring it up to that time!
                               (max (simevt-vtime next) private-vtime)
                               private-vtime)
                           (simevt-duration next)
                           (simevt-msgobj next))))]

	    [(pop)
	     (if (null? buffer)
		 (error 'alpha-lib:build-node-sim "Can't pop from null scheduling queue"))
	     (logger 3 "~a: Popped off action: ~a at vtime ~a ~n" 
		     (node-id (simobject-node ob))
		     (msg-object-token (simevt-msgobj (car buffer)))
		     (simevt-vtime (car buffer)))
	     (set! buffer (cdr buffer))]

	    ;; This is a questionable method.  When we have a gap in
	    ;; our local schedule, the only way we time-advance is
	    ;; when the "global clock" runs along past ours, and then
	    ;; we set ours to catch up with it.
            [(catchup-time ,globvtime)
	     (logger 3 "~a: Catchup time: ~a ~n"
		     (node-id (simobject-node ob))
		     globvtime)
             (private-scheduler 'advance-time (- globvtime private-vtime))]

	    [(advance-time ,increment)
	     (if (< increment 0)
		 (logger 2 "~a: WARNING, attempted negative time advance by ~a~n"
			 (node-id (simobject-node ob))
			 increment))
	     ;; Here we update the schedule to deal with the new local clock.
             (when (> increment 0) ;; Fizzle if the increment is not positive
	       (logger 3 "~a: Incrementing time by ~a, from ~a ~n"
		       (node-id (simobject-node ob))
		       increment private-vtime)
               (set! private-vtime (+ private-vtime increment))
	       ;; But with that new time, we have to see if we still have time 
	       (private-scheduler 'reconsider-schedule)
	       )]

	    ;; Slides the #f timed events around in the hard-timed events.
	    [(reconsider-schedule)
               ;; This is where we make sure we have time to run the
               ;; things we want to run before the next hard timing constraint:
               (mvlet ([(flexible rest) (split-before simevt-vtime buffer)])
                      (if (not (null? rest))
                          (let* ([nexttime (simevt-vtime (car rest))]


                                 [time-remaining (- nexttime private-vtime)])
                            (mvlet ([(cando letslide)
                                     (let loop ([acc '()] [budget time-remaining] [evts flexible])
                                       (cond 
                                         [(null? evts) (values flexible '())]
                                         [(< budget (simevt-duration (car evts)))
                                          ;; We can't afford it, stop here:
                                          (values (reverse! acc) evts)]
                                         [else (loop (cons (car evts) acc) 
                                                     (- budget (simevt-duration (car evts)))
                                                     (cdr evts))]))])
                                   (if (not (null? letslide))
                                       (set! buffer
                                             (append cando
                                                     (list (car rest))
                                                     letslide ;; Let them slide till after the timed event
                                                     (cdr rest))))))))]

	    ;; Is called with the local time that the scheduling hapens.
	    ;; New events may have times in the future, but should not have times in the past.
            [(schedule ,current-vtime . ,newevnts)
	     (DEBUGMODE
	      (for-each (lambda (ne)
			  (if (vtimelessthan (simevt-vtime ne) current-vtime)
			      (logger 0 "~a: ERROR: Scheduled event has time in past (now ~t): ~a"
				      (node-id (simobject-node ob))
				      current-vtime
				      (list (simevt-vtime ne) (msg-object-token (simevt-msgobj ne))))))
			newevnts))
	     
	     (unless (null? newevnts)
		(set! buffer (merge evntlessthan newevnts buffer))
		;; Setting the new time will reorder the buffer rationally
		;;(private-scheduler 'catchup-time current-vtime)
		(logger 3 "~a: Scheduling ~a new events ~a, new schedule: ~a~n"
			(node-id (simobject-node ob))
			(length newevnts)
			(map (lambda (e) (msg-object-token (simevt-msgobj e))) newevnts)
			(map (lambda (e) (list (simevt-vtime e) (msg-object-token (simevt-msgobj e))))
			     buffer))
		)]
	    
	    [,err (error 'build-node-sim "Did not understand message: ~a" err)]
	    ))))

    
    (define (process-incoming localclock)      
      (define schedule (simobject-scheduler ob))
      
      (if (not (null? (append (simobject-local-msg-buf ob)
			      (simobject-timed-token-buf ob)
			      (simobject-incoming-msg-buf ob))))			      
	  (logger 1.5 "~a: Receiving (t:~a): ~a local, ~a timed, ~a remote. Buffer: ~a~n"		  
		  (node-id (simobject-node ob))
		  localclock
		  (map (lambda (x) (msg-object-token (simevt-msgobj x))) (simobject-local-msg-buf ob))
		  (map (lambda (x) (msg-object-token (simevt-msgobj x))) (simobject-timed-token-buf ob))
		  (map (lambda (x) (msg-object-token (simevt-msgobj x))) (simobject-incoming-msg-buf ob))
		  (map msg-object-token (map simevt-msgobj (schedule 'get-buffer)))
		  ))

      (let ([timed (simobject-timed-token-buf ob)]
	    [local (simobject-local-msg-buf ob)]
	    [incoming (simobject-incoming-msg-buf ob)])
	(set-simobject-local-msg-buf! ob '())
	(set-simobject-timed-token-buf! ob '())
	(set-simobject-incoming-msg-buf! ob '())

	(if (not (andmap simevt? (append timed local incoming)))
	    (printf "NOT ALL SIMEVT ~a ~a ~a~n" 
		    timed local incoming))

      ;; Process incoming and local msgs:
      ;; Schedule timed local tokens:
      (apply schedule 'schedule localclock timed)
      (apply schedule 'schedule localclock local)
      (apply schedule 'schedule localclock incoming))
      )
  
    (define (launch-outgoing current-vtime)
      ;; This does the radio transmission, and puts msgs in their respective incoming buffers.
      ;; TODO: Here's where we insert the better radio model!!!
      (let ([outgoing (simobject-outgoing-msg-buf ob)])
	
	(unless (null? outgoing)
	;; They're all broadcasts for now
	(for-each (lambda (evt)
		    ;; Timestame the message:
		    (set-msg-object-sent-time! (simevt-msgobj evt) current-vtime)
		    ;(let ([newmsg (structure-copy (simevt-msgobj evt))])
		    )
		  outgoing)

	(let ((neighbors (graph-neighbors (simworld-object-graph world) ob)))
	  (logger "~a: bcast ~a at time ~a to -> ~a~n" 
		  (node-id (simobject-node ob)) 
		  (map (lambda (m) (msg-object-token (simevt-msgobj m))) outgoing)
		  current-vtime
		  (map (lambda (x) (node-id (simobject-node x))) neighbors))
	  
	  (for-each 
	   (lambda (nbr)
	     (set-simobject-incoming-msg-buf! 
	      nbr (append  outgoing
			   (simobject-incoming-msg-buf nbr))))
	   neighbors)
	;; They're all delivered, so we clear our own outgoing buffer.
	  (set-simobject-outgoing-msg-buf! ob '())))))

    ;;========================================    
    ;; MAIN BODY:
    (mvlet ([(mhandler cost-table) (node-code ob)])
    ;; Install the scheduler and handler incase anybody else wants to use them:
    (set-simobject-scheduler! ob private-scheduler)
    (set-simobject-meta-handler! ob mhandler)

    ;; Clear out the buffers from any prior simulations:
    (set-simobject-local-msg-buf! ob '())
    (set-simobject-timed-token-buf! ob '())
    (set-simobject-outgoing-msg-buf! ob '())
    ;; The incoming buffer starts out with just the start actions SOC-start and node-start.
    (set-simobject-local-msg-buf! ob				
	(list (make-simevt 0
			   (cadr (assq 'node-start cost-table))
			   (bare-msg-object 'node-start '() 0))))
    (if (simobject-I-am-SOC ob)
	(set-simobject-local-msg-buf! ob
	   (cons (make-simevt 0
			      (cadr (assq 'node-start cost-table))
			      (bare-msg-object 'SOC-start '() 0))
		 (simobject-local-msg-buf ob))))

    ;; This is the simulation object, each time its executed it
    ;; processes incoming messages for the nodes, decides what action
    ;; is next and returns that action (as a simevt).  If there's no
    ;; next action, returns #f.  

    ;; If the simulation driver wishes to execute that action, it
    ;; does, which will run the handler, update the scheduler, and
    ;; modify the simobject.
    (lambda (global-mintime)

      (define scheduler (simobject-scheduler ob))
      (define ourtime_starting (scheduler 'get-time))
      
      ;; If our local clock has fallen behind the real one, advance it.
      ;; Ourtime represents the actual start time at which this potential action will run.
      (define ourtime
	(if (>= ourtime_starting global-mintime)
	    ourtime_starting 
	    (begin (logger "~a: Fell behind global timer (our ~a trailing global ~a).  Advancing.~n"
			   (node-id (simobject-node ob))
			   ourtime_starting global-mintime)
		   (scheduler 'catchup-time global-mintime)
		   global-mintime)))

      ;; First schedule any incoming messages we've received
      (process-incoming ourtime)

      (let ([next (scheduler 'head)])
	(if (not next) 
	    #f    ;; We just fizzle if our schedule is empty.  
            (begin 
	      (logger 3 "~a: Updated schedule, got head: vt~a d~a ~a, buffer ~a~n" 
		      (node-id (simobject-node ob))
		      (simevt-vtime next) (simevt-duration next)
		      (msg-object-token (simevt-msgobj next)) 
		      (map (lambda (evt) (list (simevt-vtime evt)
					       (msg-object-token (simevt-msgobj evt))))
			   (scheduler 'get-buffer)))
	      (make-simevt
               (simevt-vtime next)
               (simevt-duration next)
               ;; Action thunk that executes message:
               (lambda ()
		 (DEBUGMODE
		  (if (not (= ourtime (scheduler 'get-time)))
		     (logger 0 ; 'build-node-sim
			    "~a: ERROR: Local time changed between getting the new head and executing it!  orig time ~a, current-time ~a~n"
			    (node-id (simobject-node ob))
			    ourtime
			    (scheduler 'get-time))))

                 ;(printf "Busting thunk, running action: ~a~n" next)
                 ;; For now, the time actually executed is what's scheduled
                 (logger "~a: Executing: ~a at scheduled time ~a, global/mintime ~a,  localclock ~a~n" 
			 (node-id (simobject-node ob))
			 (msg-object-token (simevt-msgobj next))
			 (simevt-vtime next)
			 global-mintime
			 (scheduler 'get-time))

		 '(DEBUGMODE ;; check invariant:
		   (if (not (null? (simobject-outgoing-msg-buf ob)))
		     (error 'build-node-sim 
			    "Trying to execute action at time ~a, but there's already an outgoing(s) msg: ~a~n"
			    global-mintime (simobject-outgoing-msg-buf ob))))

		 ;; Do the actual computation:
                 ((simobject-meta-handler ob) (simevt-msgobj next) (simevt-vtime next))
                 ;; Now that the atomic action is finished, do the radio transimission:		 
		 ;; The actual time that outgoing messages are launched is at the 
		 ;; end of the atomic actions completion:
                 (launch-outgoing (+ ourtime (simevt-duration next)))
                 
                 ;; Finally we must tell our scheduler that we have executed this action:
                 ;; First, advance the clock appropriately.
                 (scheduler 'advance-time (simevt-duration next))
                 (scheduler 'pop)  ;; Next, pop off that action since we're done with it.
                 )))))))))

(define global-graph #f)

(define (run-alpha-sim . stop-time)
  (define logfile "__temp.log")
    (if (file-exists? logfile) (delete-file logfile))
    (parameterize ([simulation-logger (open-output-file logfile 'replace)]
		   [simulation-logger-count 0])
    (printf "Running simulator alpha (logfile ~s)" logfile)
    (DEBUGMODE (display " with Debug-Mode enabled"))
    (printf ".~n")
    
    (let ([stopping-time? (if (null? stop-time)
			      (lambda (t) #f)
			      (if (inexact? (car stop-time))
				  ;; It's in seconds:
				  (let ([end-time (+ (* 1000 (car stop-time)) (cpu-time))])
				    (printf "Stopping after ~a seconds.~n" (car stop-time))
				    (lambda (_) (>= (cpu-time) end-time)))
				  ;; Otherwise, vtime:
				  (begin (printf "Stopping after vtime ~a.~n" (car stop-time))
				  (lambda (t) (>= t (car stop-time))))))])
      (let* ([sim (fresh-simulation)]
	     [soc (car (filter (lambda (n) (eq? BASE_ID (node-id (simobject-node n))))
			       (simworld-all-objs sim)))]
	     [node-sims
	       (map (lambda (ob)
		      (build-node-sim ob
		       sim ;; the world
                       node-code ;; TODO: read from file
		       ))
		    (simworld-all-objs sim))])

	;; DEBUG DEBUG DEBUG
	(set! global-graph (simworld-graph sim))

	;(printf "Starting!  Local: ~a~n" (map simobject-local-msg-buf (simworld-all-objs sim)))

	;; As this loop runs, the global (main-sim-loop) time is just the start time of the last executed action.
    (let/ec exit-loop
    (let main-sim-loop ([vtime 0])
      (logger 2 "  Main sim loop: vtime ~a (vtime of last action)~n" vtime)
      (logger 1.5 "  Local vtimes ~a~n" 
	      (map (lambda (ob) ((simobject-scheduler ob) 'get-time))
		   (simworld-all-objs sim)))
      
      (printf "<~a>" vtime)
      (if (stopping-time? vtime)
	  (printf "Out of time.~n")
;      (let ([nextevt
; 	     (let actionsloop ([sims node-sims] [best #f])
; 	       (if (null? sims) best
; 		   (let ([action ((car sims) vtime)])
; 		     (actionsloop (cdr sims)
; 				  (cond
; 				   [(not action) best]
; 				   [(not best) action]
; 				   [(evntlessthan action best) action]
; 				   [else best])))))])
; 	(if (not nextevt)
; 	    (printf "~n~a: Simulator ran fresh out of actions!~n"
; 		    'alpha-lib:run-alpha-sim)

	     ;; Less efficient but more functional way:
	      (let ([nextevt
		     (let ([actions (filter id (map (lambda (f) (f vtime)) node-sims))])
		       (if (null? actions)
			   (exit-loop 
			    (printf "~n~a: Simulator ran fresh out of actions!~n"
				    'alpha-lib:run-alpha-sim))
			   (let* ([nexttime (apply min (map simevt-vtime actions))])
			     (car (filter (lambda (se) (eq? nexttime (simevt-vtime se))) actions)))))])
	
	    (begin
	      ;; Run this atomic action (token handler), it gets to run at its intended virtual time.
              ;; We have lamely stored it in the msgobj field:
	      ((simevt-msgobj nextevt)) ;; This will execute the action and advance the clock internally.
              
	      ;; That had the effect of launching new messages to process.
	      (main-sim-loop (simevt-vtime nextevt)))))))
    
    ;; Out of main loop:
    (if (simulation-logger) (close-output-port (simulation-logger)))
    ))))


;; From Swindle:
;;>> (merge less? a b)
;;>   Takes two lists `a' and `b' such that both (sorted? a less?) and
;;>   (sorted? b less?) are true, and returns a new list in which the
;;>   elements of `a' and `b' have been stably interleaved so that (sorted?
;;>   (merge less? a b) less?) is true.  Note: this does not accept vectors.
(define (merge less? a b)
  (cond [(null? a) b]
        [(null? b) a]
        [else (let loop ([x (car a)] [a (cdr a)] [y (car b)] [b (cdr b)])
                ;; The loop handles the merging of non-empty lists.  It has
                ;; been written this way to save testing and car/cdring.
                (if (less? y x)
                  (if (null? b)
                    (cons y (cons x a))
                    (cons y (loop x a (car b) (cdr b))))
                  ;; x <= y
                  (if (null? a)
                    (cons x (cons y b))
                    (cons x (loop (car a) (cdr a) y b)))))]))


;; ======================================================================
;; Gets set by .... Something?  TODO FIX UP:
;; All node level utilities below depend on this parameter being set properly.
[define this (make-parameter #f)]

;; ======================================================================
;; Node level utilities 

;; Is set to a list of all the leds that are toggled on.    
[define led-toggle-state '()]

;; MAKE SURE NOT TO INCLUDE OURSELVES:
[define (neighbors obj sim)
  (let ((entry (assq obj (simworld-object-graph sim))))
    (if (null? entry)
        (error 'neighbors "generated code.. .cannot find obj in graph: ~s ~n ~s"
               obj (simworld-object-graph sim))
        (begin 
          (if (memq obj (cdr entry))
              (error 'neighbors "we're in our own neighbors list"))
          (cdr entry))))]

[define sendmsg (lambda (data ob)
                  (set-simobject-incoming-msg-buf! ob
                                           (cons data (simobject-incoming-msg-buf ob)))
                  ;(set-simobject-redraw! ob #t)
                  )]


[define (sim-light-up r g b)
  ((sim-debug-logger) "~n~a: light-up ~a ~a ~a"
                      (node-id (simobject-node this)) r g b)
  (if (simobject-gobj this)
      (change-color! (simobject-gobj this) (rgb r g b))
      ;; We're allowing light-up of undrawn objects atm:
      ;(error 'sim-light-up "can't change color on undrawn object!: ~s" this)
      )]

;; INCOMPLETE (we don't yet draw the leds directly.)
[define (sim-leds what which)
  (let* ([colors 
          (case which
            [(red)   '(255 0 0)]
            [(green) '(0 255 0)]
            [(blue)  '(0 0 255)]
            [else (error 'sim-leds "bad color: ~a" which)])]
         ;; INCOMPLETE:
         ;	     [oldcolors '(0 0 0)]
         )
    (let ((string (format "~a: (time ~s) (Leds: ~a ~a ~a)~n" 	
                          (node-id (simobject-node this)) (cpu-time) which what
                          (case what
                            [(on) 
                             (set! led-toggle-state (list->set (cons which led-toggle-state)))
                             (apply sim-light-up colors)
                             "" ]
                            [(off)
                             (set! led-toggle-state (remq which led-toggle-state))
                             (sim-light-up '(0 0 0))
                             "" ]
                            [(toggle)
                             (if (memq which led-toggle-state)
                                 (begin 
                                   (set! led-toggle-state (remq which led-toggle-state))
                                   (sim-light-up 0 0 0)
                                   "off")
                                 (begin 
                                   (set! led-toggle-state (list->set (cons which led-toggle-state)))
                                   (apply sim-light-up colors)
                                   "on")
                                 )]
                            [else (error 'sim-leds "bad action: ~a" what)]))))
      ;((sim-debug-logger) string)
      (logger string)
      ))]

'[define (sim-dist . tok)
  (if (null? tok)
      (begin 
        (if (msg-object-count this-message)
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist) is broken!")))
      (let ((entry (hashtab-get (simobject-token-cache this) (car tok))))
        (if (and entry (msg-object-count entry))
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist ~s) but ~s has not been received!"
                   (car tok) (car tok))
            )))]

[define (sim-loc) ;; Return this nodes location.
  (node-pos (simobject-node this))]

[define (sim-locdiff a b)
  (sqrt (+ (expt (- (car a) (car b)) 2)
           (expt (- (cadr a) (cadr b)) 2)))]


(define (t)
  (alpha-it
   '(program
     (bindings)
     (nodepgm 
	 (tokens
	  [node-start () (stored) (display "N")]
	  ;[node-start () (stored) (void)]
	  [SOC-start () (stored) (begin (printf "S") (call tok1))]
	  [tok1 () (stored) (begin (display ".") (bcast tok2 "!"))]
	  [tok2 (x) (stored) (timed-call 500 tok3 x)]
	  [tok3 (y) (stored) (display y)]
	  )))))


;     (begin (t) (time (run-alpha-sim 10.0)))
