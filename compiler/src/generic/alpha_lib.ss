
;; These are used by code generated by compile-simulate-alpha.

;; ======================================================================
;; Simulator runtime
  
;; This returns:
;; 1) meta-token-handler of type (msg-object, vtime -> ())
;; 2) a cost-table mapping toknames to vtime costs
;(define node-code #f)

;; #f trumps any time, EXCEPT 0, 0 trumps all.
(define (evntlessthan a b)
  (vtimelessthan (simevt-vtime a) (simevt-vtime b)))

(define (vtimelessthan at bt)
  (cond
   [(eq? at 0) #t]
   [(eq? bt 0) #f]
   [(not at) #t]
   [(not bt) #f]
   [else (<= at bt)]))

(define global-graph #f)

;; Global parameter contains continuation for exiting the alpha-sim.  Invoked by soc-finished.
(define escape-alpha-sim
  (make-parameter (lambda (x) (error 'escape-alpha-sim "parameter holds no continuation"))
		  (lambda (k) (if (procedure? k) k
				  (error 'escape-alpha-sim "bad continuation: ~a" k)))))
;; Global parameter to hold globally returned values:
(define soc-return-buffer
  (make-parameter '()
		  (lambda (ls) ls)))

;; [2005.09.29] Moved start-alpha-sim to simulator_alpha.ss

;; From Swindle:
;;>> (merge less? a b)
;;>   Takes two lists `a' and `b' such that both (sorted? a less?) and
;;>   (sorted? b less?) are true, and returns a new list in which the
;;>   elements of `a' and `b' have been stably interleaved so that (sorted?
;;>   (merge less? a b) less?) is true.  Note: this does not accept vectors.
'(define (merge less? a b)
  (cond [(null? a) b]
        [(null? b) a]
        [else (let loop ([x (car a)] [a (cdr a)] [y (car b)] [b (cdr b)])
                ;; The loop handles the merging of non-empty lists.  It has
                ;; been written this way to save testing and car/cdring.
                (if (less? y x)
                  (if (null? b)
                    (cons y (cons x a))
                    (cons y (loop x a (car b) (cdr b))))
                  ;; x <= y
                  (if (null? a)
                    (cons x (cons y b))
                    (cons x (loop (car a) (cdr a) y b)))))]))


;; ======================================================================
;; Gets set by .... Something?  TODO FIX UP: seems like this is a param, and below these funs expect a direct var binding
;; All node level utilities below depend on this parameter being set properly.
[define this (make-parameter #f)]

;; ======================================================================
;; Node level utilities 

;; Is set to a list of all the leds that are toggled on.    
[define led-toggle-state '()]

;; MAKE SURE NOT TO INCLUDE OURSELVES:
[define (neighbors obj sim)
  (let ((entry (assq obj (simworld-object-graph sim))))
    (if (null? entry)
        (error 'neighbors "generated code.. .cannot find obj in graph: ~s ~n ~s"
               obj (simworld-object-graph sim))
        (begin 
          (if (memq obj (cdr entry))
              (error 'neighbors "we're in our own neighbors list"))
          (cdr entry))))]

[define sendmsg (lambda (data ob)
                  (set-simobject-incoming-msg-buf! ob
                                           (cons data (simobject-incoming-msg-buf ob)))
                  ;(set-simobject-redraw! ob #t)
                  )]


[define (sim-light-up r g b)
  ((sim-debug-logger) "~n~a: light-up ~a ~a ~a"
                      (node-id (simobject-node this)) r g b)
  (if (simobject-gobj this)
      (change-color! (simobject-gobj this) (rgb r g b))
      ;; We're allowing light-up of undrawn objects atm:
      ;(error 'sim-light-up "can't change color on undrawn object!: ~s" this)
      )]

;; todo INCOMPLETE (we don't yet draw the leds directly.)
[define (sim-leds what which)
  (let* ([colors 
          (case which
            [(red)   '(255 0 0)]
            [(green) '(0 255 0)]
            [(blue)  '(0 0 255)]
            [else (error 'sim-leds "bad color: ~a" which)])]
         ;; INCOMPLETE:
         ;	     [oldcolors '(0 0 0)]
         )
    (let ((string (format "~a: (time ~s) (Leds: ~a ~a ~a)~n" 	
                          (node-id (simobject-node this)) (cpu-time) which what
                          (case what
                            [(on) 
                             (set! led-toggle-state (list->set (cons which led-toggle-state)))
                             (apply sim-light-up colors)
                             "" ]
                            [(off)
                             (set! led-toggle-state (remq which led-toggle-state))
                             (sim-light-up '(0 0 0))
                             "" ]
                            [(toggle)
                             (if (memq which led-toggle-state)
                                 (begin 
                                   (set! led-toggle-state (remq which led-toggle-state))
                                   (sim-light-up 0 0 0)
                                   "off")
                                 (begin 
                                   (set! led-toggle-state (list->set (cons which led-toggle-state)))
                                   (apply sim-light-up colors)
                                   "on")
                                 )]
                            [else (error 'sim-leds "bad action: ~a" what)]))))
      ;((sim-debug-logger) string)
      (logger string)
      ))]

'[define (sim-dist . tok)
  (if (null? tok)
      (begin 
        (if (msg-object-count this-message)
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist) is broken!")))
      (let ((entry (hashtab-get (simobject-token-cache this) (car tok))))
        (if (and entry (msg-object-count entry))
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist ~s) but ~s has not been received!"
                   (car tok) (car tok))
            )))]

[define (sim-loc) ;; Return this nodes location.
  (node-pos (simobject-node this))]

[define (sim-locdiff a b)
  (sqrt (+ (expt (- (car a) (car b)) 2)
           (expt (- (cadr a) (cadr b)) 2)))]

[define (simulator-soc-return x)
  (printf "~n  SOCRETURN: ~a ~n" x)
  (soc-return-buffer (cons x (soc-return-buffer)))]

[define (simulator-soc-finished)
  (printf "~nSOC-FINISHED!~n")(flush-output-port)
  ((escape-alpha-sim))]


;; Invariant checker: used only in DEBUGMODE
[define (check-store tokstore)
  (hashtab-for-each
   (lambda (namepair tokobj)
     (or (and (simtok? namepair) ;(pair? namepair)
	      (symbol? (simtok-name namepair)) ;(symbol? (car namepair))
	      (number? (simtok-subid namepair)) ;(number? (cdr namepair))
	      (vector? tokobj))
	 (error 'check-store "Bad token store at entry: ~a, tokobj: ~n~a" namepair tokobj)))
   tokstore)]

;======================================================================

;; Junk:

(define (t)
  (alpha-it
   '(program
     (bindings)
     (nodepgm 
	 (tokens
	  [node-start _ () (stored) (bindings) (display "N")]
	  ;[node-start () (stored) (void)]
	  [SOC-start _ () (stored) (bindings) (begin (printf "S") (call tok1))]
	  [tok1 _ () (stored) (bindings) (begin (display ".") (bcast tok2 5))]
	  [tok2 _ (x) (stored) (bindings) (timed-call 500 tok3 x)]
	  [tok3 _ (y) (stored) (bindings)
		(if (not (= y 0))		    		    
		    (begin (display y)
			   (timed-call 1000 tok3 (- y 1))))]
	  )))))

'(tokens 
  [soc-start () (display "S")]
  [node-start () (display "N")])

;; Uses global "node-code" binding.
#;(define (alpha-repl)
  (printf "sim> ") (flush-output-port)
  (let ((input (read)))
    (unless (eq? 'exit input)
	    (disp "Got prgoram" input)
	    (let ((cleaned (cleanup-token-machine input)))
	      (disp "got cleaned:")(pp cleaned)
	      (alpha-it cleaned)
	      (start-alpha-sim node-code 10.0 'simple)
	      (alpha-repl)))))

(define (alpha-it tm)
  (let ([comped (compile-simulate-alpha tm)])
  ;; Bind the current program to a global variable:
    (eval `(define alph ',comped))
    (eval comped)))






;     (begin (t) (time (start-alpha-sim 10.0)))
