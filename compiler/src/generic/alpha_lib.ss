
;; These are used by code generated by compile-simulate-alpha.

;; ======================================================================
;; Simulator runtime
  
(define (alpha-it tm)
  (eval `(define alph ',(compile-simulate-alpha tm)))
  (eval (compile-simulate-alpha tm)))

;; This returns:
;; 1) meta-token-handler of type (msg-object, vtime -> ())
;; 2) a cost-table mapping toknames to vtime costs
(define (node-code this)
  (define-structure (tokstore))
  "This is the simulation seed."
  "It returns an initial set of scheduled actions for the simulator to execute."
  (let ([local-sense
         (lambda ()
           ((current-sense-function)
            (node-pos (simobject-node this))))])
    (let* ()
      (letrec ([node-start
                (lambda (current-vtime subtok-index)
                  (let* (#0=(the-store (simobject-token-store this))
                         [this-tokname
                          (cons 'node-start . #1=(subtok-index))]
                         .
                         #2=((old-outgoing
                               (simobject-outgoing-msg-buf this))
                             (old-local (simobject-local-msg-buf this))))
                    #3="Is there already an allocated token object?:"
                    (let #4=((tokobj (hashtab-get the-store this-tokname)))
                      (if #5=(not tokobj)
                          (begin #6="If not, then we allocate that token object..."
                                 #7=" setting the invoke counter to zero."
                                 (set! tokobj (vector 0))
                                 .
                                 #8=((hashtab-set!
                                       the-store
                                       this-tokname
                                       tokobj))))
                      #9=(set-simobject-outgoing-msg-buf! this '())
                      #10=(set-simobject-local-msg-buf! this '())
                      (display "N")
                      .
                      #11=((set-simobject-outgoing-msg-buf!
                             this
                             (append
                               (reverse (simobject-outgoing-msg-buf this))
                               old-outgoing))
                           (set-simobject-local-msg-buf!
                             this
                             (append
                               (reverse (simobject-local-msg-buf this))
                               old-local))
                           (void)))))]
               [soc-start
                (lambda (current-vtime subtok-index)
                  (let* (#0# [this-tokname (cons 'soc-start . #1#)] . #2#)
                    #3#
                    (let #4#
                      (if #5#
                          (begin #6# #7# (set! tokobj (vector 0)) . #8#))
                      #9#
                      #10#
                      (begin (printf "S")
                             (set-simobject-local-msg-buf!
                               this
                               (cons (make-simevt
                                       #f
                                       3
                                       (bare-msg-object
                                         'tok1
                                         (list)
                                         current-vtime))
                                     (simobject-local-msg-buf this))))
                      .
                      #11#)))]
               [tok1
                (lambda (current-vtime subtok-index)
                  (let* (#0# [this-tokname (cons 'tok1 . #1#)] . #2#)
                    #3#
                    (let #4#
                      (if #5#
                          (begin #6# #7# (set! tokobj (vector 0)) . #8#))
                      #9#
                      #10#
                      (begin (display ".")
                             (set-simobject-outgoing-msg-buf!
                               this
                               (cons (make-simevt
                                       #f
                                       2
                                       (bare-msg-object
                                         'tok2
                                         (list "!")
                                         current-vtime))
                                     (simobject-local-msg-buf this))))
                      .
                      #11#)))]
               [tok2
                (lambda (current-vtime subtok-index x)
                  (let* (#0# [this-tokname (cons 'tok2 . #1#)] . #2#)
                    #3#
                    (let #4#
                      (if #5#
                          (begin #6# #7# (set! tokobj (vector 0)) . #8#))
                      #9#
                      #10#
                      (set-simobject-timed-token-buf!
                        this
                        (cons (make-simevt
                                (+ 500 current-vtime)
                                1
                                (bare-msg-object
                                  'tok3
                                  (list x)
                                  current-vtime))
                              (simobject-timed-token-buf this)))
                      .
                      #11#)))]
               [tok3
                (lambda (current-vtime subtok-index y)
                  (let* (#0# [this-tokname (cons 'tok3 . #1#)] . #2#)
                    #3#
                    (let #4#
                      (if #5#
                          (begin #6# #7# (set! tokobj (vector 0)) . #8#))
                      #9#
                      #10#
                      (display y)
                      .
                      #11#)))])
        (let ([dyndispatch_table (make-default-hash-table)])
          (begin (hashtab-set!
                   dyndispatch_table
                   'node-start
                   node-start)
                 (hashtab-set! dyndispatch_table 'soc-start soc-start)
                 (hashtab-set! dyndispatch_table 'tok1 tok1)
                 (hashtab-set! dyndispatch_table 'tok2 tok2)
                 (hashtab-set! dyndispatch_table 'tok3 tok3))
          (values
            (lambda (msgob current-vtime)
              (mvlet
                (((name subtok)
                  (let ([tok (msg-object-token msgob)])
                    (if (pair? tok)
                        (values (car tok) (cdr tok))
                        (values tok 0)))))
                (let ([handler (hashtab-get dyndispatch_table name)])
                  (apply
                    handler
                    current-vtime
                    subtok
                    (msg-object-args msgob)))))
            '((node-start 1)
              (soc-start 3)
              (tok1 3)
              (tok2 2)
              (tok3 1))))))))

;; #f trumps any time, EXCEPT 0, 0 trumps all.
(define (evntlessthan a b)
  (vtimelessthan (simevt-vtime a) (simevt-vtime b)))

(define (vtimelessthan at bt)
  (cond
   [(eq? at 0) #t]
   [(eq? bt 0) #f]
   [(not at) #t]
   [(not bt) #f]
   [else (<= at bt)]))


(define global-graph #f)


;; This just sets up the sim and the logger and invokes one of the scheduler/execution engines.
;; I've written two different engines at different levels of time-modeling complexity.
(define (run-alpha-sim . args)
  (define logfile "__temp.log")

  (define simple-scheduler #f)
  (define stop-time (filter (lambda (arg)
			 (if (eq? arg 'simple)
			     (begin (set! simple-scheduler #t) #f)
			     #t))
                       args))
  (define stopping-time? 
    (if (null? stop-time)
	(lambda (t) #f)
	(if (inexact? (car stop-time))
	    ;; It's in seconds:
	    (let ([end-time (+ (* 1000 (car stop-time)) (cpu-time))])
	      (printf "Stopping after ~a seconds.~n" (car stop-time))
	      (lambda (_) (>= (cpu-time) end-time)))
	    ;; Otherwise, vtime:
	    (begin (printf "Stopping after vtime ~a.~n" (car stop-time))
		   (lambda (t) (>= t (car stop-time)))))))
  (define sim (fresh-simulation))


  (if (file-exists? logfile) (delete-file logfile))
  (parameterize ([simulation-logger (open-output-file logfile 'replace)]
		 [simulation-logger-count 0])
		(printf "Running simulator alpha (logfile ~s)" logfile)
		(DEBUGMODE (display " with Debug-Mode enabled"))
		(printf ".~n")

	;; DEBUG DEBUG DEBUG
	(DEBUGMODE
	 (set! global-graph (simworld-graph sim)))

	;(printf "Starting!  Local: ~a~n" (map simobject-local-msg-buf (simworld-all-objs sim)))
	(if simple-scheduler
	    (run-alpha-simple-scheduler sim stopping-time?)
	    (run-alpha-full-scheduler sim stopping-time?))
		   
    ;; Out of main loop:
    (if (simulation-logger) (close-output-port (simulation-logger)))
    ))


;; From Swindle:
;;>> (merge less? a b)
;;>   Takes two lists `a' and `b' such that both (sorted? a less?) and
;;>   (sorted? b less?) are true, and returns a new list in which the
;;>   elements of `a' and `b' have been stably interleaved so that (sorted?
;;>   (merge less? a b) less?) is true.  Note: this does not accept vectors.
(define (merge less? a b)
  (cond [(null? a) b]
        [(null? b) a]
        [else (let loop ([x (car a)] [a (cdr a)] [y (car b)] [b (cdr b)])
                ;; The loop handles the merging of non-empty lists.  It has
                ;; been written this way to save testing and car/cdring.
                (if (less? y x)
                  (if (null? b)
                    (cons y (cons x a))
                    (cons y (loop x a (car b) (cdr b))))
                  ;; x <= y
                  (if (null? a)
                    (cons x (cons y b))
                    (cons x (loop (car a) (cdr a) y b)))))]))


;; ======================================================================
;; Gets set by .... Something?  TODO FIX UP:
;; All node level utilities below depend on this parameter being set properly.
[define this (make-parameter #f)]

;; ======================================================================
;; Node level utilities 

;; Is set to a list of all the leds that are toggled on.    
[define led-toggle-state '()]

;; MAKE SURE NOT TO INCLUDE OURSELVES:
[define (neighbors obj sim)
  (let ((entry (assq obj (simworld-object-graph sim))))
    (if (null? entry)
        (error 'neighbors "generated code.. .cannot find obj in graph: ~s ~n ~s"
               obj (simworld-object-graph sim))
        (begin 
          (if (memq obj (cdr entry))
              (error 'neighbors "we're in our own neighbors list"))
          (cdr entry))))]

[define sendmsg (lambda (data ob)
                  (set-simobject-incoming-msg-buf! ob
                                           (cons data (simobject-incoming-msg-buf ob)))
                  ;(set-simobject-redraw! ob #t)
                  )]


[define (sim-light-up r g b)
  ((sim-debug-logger) "~n~a: light-up ~a ~a ~a"
                      (node-id (simobject-node this)) r g b)
  (if (simobject-gobj this)
      (change-color! (simobject-gobj this) (rgb r g b))
      ;; We're allowing light-up of undrawn objects atm:
      ;(error 'sim-light-up "can't change color on undrawn object!: ~s" this)
      )]

;; INCOMPLETE (we don't yet draw the leds directly.)
[define (sim-leds what which)
  (let* ([colors 
          (case which
            [(red)   '(255 0 0)]
            [(green) '(0 255 0)]
            [(blue)  '(0 0 255)]
            [else (error 'sim-leds "bad color: ~a" which)])]
         ;; INCOMPLETE:
         ;	     [oldcolors '(0 0 0)]
         )
    (let ((string (format "~a: (time ~s) (Leds: ~a ~a ~a)~n" 	
                          (node-id (simobject-node this)) (cpu-time) which what
                          (case what
                            [(on) 
                             (set! led-toggle-state (list->set (cons which led-toggle-state)))
                             (apply sim-light-up colors)
                             "" ]
                            [(off)
                             (set! led-toggle-state (remq which led-toggle-state))
                             (sim-light-up '(0 0 0))
                             "" ]
                            [(toggle)
                             (if (memq which led-toggle-state)
                                 (begin 
                                   (set! led-toggle-state (remq which led-toggle-state))
                                   (sim-light-up 0 0 0)
                                   "off")
                                 (begin 
                                   (set! led-toggle-state (list->set (cons which led-toggle-state)))
                                   (apply sim-light-up colors)
                                   "on")
                                 )]
                            [else (error 'sim-leds "bad action: ~a" what)]))))
      ;((sim-debug-logger) string)
      (logger string)
      ))]

'[define (sim-dist . tok)
  (if (null? tok)
      (begin 
        (if (msg-object-count this-message)
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist) is broken!")))
      (let ((entry (hashtab-get (simobject-token-cache this) (car tok))))
        (if (and entry (msg-object-count entry))
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist ~s) but ~s has not been received!"
                   (car tok) (car tok))
            )))]

[define (sim-loc) ;; Return this nodes location.
  (node-pos (simobject-node this))]

[define (sim-locdiff a b)
  (sqrt (+ (expt (- (car a) (car b)) 2)
           (expt (- (cadr a) (cadr b)) 2)))]


(define (t)
  (alpha-it
   '(program
     (bindings)
     (nodepgm 
	 (tokens
	  [node-start () (stored) (display "N")]
	  ;[node-start () (stored) (void)]
	  [SOC-start () (stored) (begin (printf "S") (call tok1))]
	  [tok1 () (stored) (begin (display ".") (bcast tok2 "!"))]
	  [tok2 (x) (stored) (timed-call 500 tok3 x)]
	  [tok3 (y) (stored) (display y)]
	  )))))


;     (begin (t) (time (run-alpha-sim 10.0)))
