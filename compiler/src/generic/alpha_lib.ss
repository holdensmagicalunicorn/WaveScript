 
;; These are used by code generated by compile-simulate-alpha.

;; ======================================================================
;; Simulator runtime
(define (sim-seed world)
  (define-structure (tokstore x))
  "This is the simulation seed."
  "It returns an initial set of scheduled actions for the simulator to execute."
  (let ((local-sense
          (lambda ()
            ((current-sense-function) (node-pos (simobject-node this))))))
    (let* ()
      (letrec ((soc-start
                 (lambda (this world)
                   (lambda ()
                     (let ((the-store (simobject-token-store this)))
                       (set-simobject-outgoing! this '())
                       (set-simobject-outgoing!
                         this
                         (cons
                          (bare-msg-object tok1 (list))
                          (simobject-outgoing this)))
                       (let ((result (values (simobject-outgoing (this)))))
                         (set-simobject-outgoing! this '())
                         result)))))
               (tok1
                (lambda (this world)
                  (lambda ()
                    (let ((the-store (simobject-token-store this)))
                      (set-simobject-outgoing! this '())
                      ;(bcast tok2 '3)
                      (let ((result (values (simobject-outgoing (this)))))
                        (set-simobject-outgoing! this '())
                        result)))))
               (tok2
                (lambda (this world)
                  (lambda (x)
                    (let ((the-store (simobject-token-store this)))
                      (set-simobject-outgoing! this '())
                      (begin
                        "Doing let stored."
                        (if (eq? x '()) (set-car! x '99))
                        (begin
                          (set-tokstore-x!
                            the-store
                            (+ (tokstore-x the-store) '1))
                          ;(bcast tok2 (tokstore-x the-store))
                          ))
                      (let ((result (values (simobject-outgoing (this)))))
                        (set-simobject-outgoing! this '())
                        result))))))
        (values (list) (lambda () (make-tokstore '())))))))

;; This builds a simulation for a specific node in the network.
;; Returns a stream of scheduled events, ordered by virtual time.
;; It is important that they be consumed only one at a time, because
;; the execution of earlier events affects which events come later.
(define build-node
  (lambda (ob world sim-seed)
    ;; The scheduling queue contains event entries of the format:
    ;;   [<vtime-to-exec>, <host-simob>, <execution-func>]
    ;; which are also returned from sim-seed in this format.
    (let* ([evnts (sim-seed world)]
	   [evntcmpr (lambda (a b) (<= (car a) (car b)))]
	   [evnts (sort eventcmpr evnts)])
	 ;; Schedule either adds an event to the schedule, 
	 ;; or returns the current schedule in list form.
	 (letrec ([schedule 
		   (let ([buffer '()])
		     (case-lambda 
		      [() buffer]
		      [(evnt) (set! buffer (merge evntcmpr (list evnt) buffer))]))]
		  ;; Wire the token-handler executer into our scheduler.
  	          [wrap (lambda (evnt)
			  (match evnt
				 [(,vtime ,simob ,fun) 
				  (list vtime 
					(lambda (vtimeexeced) ;args				 
					  (for-each schedule 
					       (map wrap 
						    ((fun simob world) vtimeexeced ;args
							   )))))]))])
	   ;; Put all the starting events into the schedule, while
	   ;; also wiring their return values to modify the scheduler
	   ;; further.
	   (for-each schedule (map wrap evnts))
	   ;; Now we build a stream from the scheduler:
	   ;; This is a weird stream though, because it gives different results
	   ;;  based on whether you *use* the earlier values in the stream.
	   (let loop ([ls (schedule)])
	     (disp "CURRENT SCHEDULE: " ls)
	     (if (null? ls) '()     
		 (cons (car ls) ;; We expose only the very next action.
		       (lambda () ;; When this is called we get the new schedule, which might have changed.
			 (loop (schedule))))))))))



(define run-alpha-sim
;  (lambda (starting-evnts store-factory . stop-time)
  (lambda stop-time
    (let ([stopping-time? (if (null? stop-time)
			      (lambda (t) #f)
			      (lambda (t) (>= t (car stop-time))))])
;      (let ([stores (make-n-list numsimnodes (lambda (_) (store-factory)))])
      (let* ([sim (fresh-simulation)]
	     [soc (car (filter (lambda (n) (eq? BASE_ID (node-id (simobject-node n))))
			       (simworld-all-objs sim)))]
	     [streams 
	      (list->vector
	       (map (lambda (ob)
		      (build-node ob
		       sim ;; the world
		       sim-seed ;; TODO: READ THIS FROM FILE.		       
		       )) 
		    (simworld-all-objs sim)))])

    (let main-sim-loop ([streams streams])      
      (disp "mainsimloop" streams)
      (let* ([streams (map (lambda (s) (if procedure? s) (s) s) streams)]
	     [heads (map stream-car streams)]
	     [nexttime (apply min heads)])
	
	(let* ([next (assq nexttime heads)]
	       [nextstrm (assq next streams)])
	  (if (not (procedure? nextstrm))
	      (error 'run-alpha-sim "nextstrm should be a procedure!: ~a" nextstrm))	  
	  ;; Run this atomic action (token handler), it gets to run at its intended virtual time.
	  ((cadr next) (car next))
	  ;; That had the effect of scheduling new actions, now we keep going.
	  (main-sim-loop (cons (stream-cdr nextstrm) (alist-remove next streams))))))))))


;; From Swindle:
;;>> (merge less? a b)
;;>   Takes two lists `a' and `b' such that both (sorted? a less?) and
;;>   (sorted? b less?) are true, and returns a new list in which the
;;>   elements of `a' and `b' have been stably interleaved so that (sorted?
;;>   (merge less? a b) less?) is true.  Note: this does not accept vectors.
(define (merge less? a b)
  (cond [(null? a) b]
        [(null? b) a]
        [else (let loop ([x (car a)] [a (cdr a)] [y (car b)] [b (cdr b)])
                ;; The loop handles the merging of non-empty lists.  It has
                ;; been written this way to save testing and car/cdring.
                (if (less? y x)
                  (if (null? b)
                    (cons y (cons x a))
                    (cons y (loop x a (car b) (cdr b))))
                  ;; x <= y
                  (if (null? a)
                    (cons x (cons y b))
                    (cons x (loop (car a) (cdr a) y b)))))]))


;; ======================================================================
;; Gets set by .... Something?  TODO FIX UP:
;; All node level utilities below depend on this parameter being set properly.
[define this (make-parameter #f)]

;; ======================================================================
;; Node level utilities 

;; Is set to a list of all the leds that are toggled on.    
[define led-toggle-state '()]

;; MAKE SURE NOT TO INCLUDE OURSELVES:
[define (neighbors obj sim)
  (let ((entry (assq obj (simworld-object-graph sim))))
    (if (null? entry)
        (error 'neighbors "generated code.. .cannot find obj in graph: ~s ~n ~s"
               obj (simworld-object-graph sim))
        (begin 
          (if (memq obj (cdr entry))
              (error 'neighbors "we're in our own neighbors list"))
          (cdr entry))))]

[define sendmsg (lambda (data ob)
                  (set-simobject-incoming! ob
                                           (cons data (simobject-incoming ob)))
                  ;(set-simobject-redraw! ob #t)
                  )]


[define (sim-light-up r g b)
  ((sim-debug-logger) "~n~a: light-up ~a ~a ~a"
                      (node-id (simobject-node this)) r g b)
  (if (simobject-gobj this)
      (change-color! (simobject-gobj this) (rgb r g b))
      ;; We're allowing light-up of undrawn objects atm:
      ;(error 'sim-light-up "can't change color on undrawn object!: ~s" this)
      )]

;; INCOMPLETE (we don't yet draw the leds directly.)
[define (sim-leds what which)
  (let* ([colors 
          (case which
            [(red)   '(255 0 0)]
            [(green) '(0 255 0)]
            [(blue)  '(0 0 255)]
            [else (error 'sim-leds "bad color: ~a" which)])]
         ;; INCOMPLETE:
         ;	     [oldcolors '(0 0 0)]
         )
    (let ((string (format "~a: (time ~s) (Leds: ~a ~a ~a)~n" 	
                          (node-id (simobject-node this)) (cpu-time) which what
                          (case what
                            [(on) 
                             (set! led-toggle-state (list->set (cons which led-toggle-state)))
                             (apply sim-light-up colors)
                             "" ]
                            [(off)
                             (set! led-toggle-state (remq which led-toggle-state))
                             (sim-light-up '(0 0 0))
                             "" ]
                            [(toggle)
                             (if (memq which led-toggle-state)
                                 (begin 
                                   (set! led-toggle-state (remq which led-toggle-state))
                                   (sim-light-up 0 0 0)
                                   "off")
                                 (begin 
                                   (set! led-toggle-state (list->set (cons which led-toggle-state)))
                                   (apply sim-light-up colors)
                                   "on")
                                 )]
                            [else (error 'sim-leds "bad action: ~a" what)]))))
      ;((sim-debug-logger) string)
      (logger string)
      ))]

'[define (sim-dist . tok)
  (if (null? tok)
      (begin 
        (if (msg-object-count this-message)
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist) is broken!")))
      (let ((entry (hashtab-get (simobject-token-cache this) (car tok))))
        (if (and entry (msg-object-count entry))
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist ~s) but ~s has not been received!"
                   (car tok) (car tok))
            )))]

[define (sim-loc) ;; Return this nodes location.
  (node-pos (simobject-node this))]

[define (sim-locdiff a b)
  (sqrt (+ (expt (- (car a) (car b)) 2)
           (expt (- (cadr a) (cadr b)) 2)))]

