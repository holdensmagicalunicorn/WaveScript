.tr ~
.ds s \fIChez Scheme\fP
.ds p \fIPetite Chez Scheme\fP
.if t .ds c caf\o'\'e'
.if n .ds c cafe
.ds ]W 
.TH SCHEME 1 "August 2005 Cadence Research Systems"
.SH NAME
\fIChez Scheme\fP
.br
\fIPetite Chez Scheme\fP
.SH SYNOPSIS
\fB{InstallSchemeName}\fP [ \fIoptions\fP ] \fIfile\fP ...
.br
\fB{InstallPetiteName}\fP [ \fIoptions\fP ] \fIfile\fP ...
.SH DESCRIPTION
\*s is a high-performance implementation of ANSI Scheme with numerous 
extensions.
\*s compiles source expressions \fIincrementally\fP,
providing the speed of compiled code in an interactive system.
.LP
\*p is a freely distributable interpreted version of \*s that may be
used as a run-time environment for \*s applications or as a
stand-alone Scheme system.
With the exception that the compiler is not present, \*p is 100%
compatible with \*s.
Interpreted code is fast in \*p, but generally not nearly as fast as
compiled code.
.LP
Scheme is normally used interactively.  The system prompts
the user with a right angle bracket (\*(lq>\*(rq) at the beginning of each
input line.  Any Scheme expression may be entered.  The system evaluates
the expression and prints the result.  After printing
the result, the system prompts again for more input.
.LP
\*s recognizes the following command line options:
.TP 1i
.B -b \fIfile\fP, --boot \fIfile\fP
Load boot code from \fIfile\fP.
.TP
.B -c, --compact
Toggle flag for heap compaction on heap save.
.TP
.B -h \fIfile\fP, --heap \fIfile\fP
Load heap from \fIfile\fP.
.TP
.B -s[\fIlevel\fP] \fIfile\fP, --saveheap[\fIlevel\fP] \fIfile\fP
Save heap on normal exit in \fIfile\fP.
.TP
.B --script \fIfile\fP
Run \fIfile\fP as a shell script.
.TP
.B -q, --quiet
Suppress greeting and prompts.
.TP
.B --help
Print brief command-line help and exit.
.TP
.B --verbose
Trace boot/heap search process
.TP
.B --version
Print version and exit.
.TP
.B --
Pass all remaining command-line arguments through to Scheme.
.LP
The \*(lq-c\*(rq, \*(lq-h\*(rq, \*(lq-s\*(rq,
\*(lq--script\*(rq, and \*(lq--verbose\*(rq options are described
in detail below.
The others should be self-explanatory.
.LP
In the normal mode of operation,
the file names on the command line (except for the arguments
to the \*(lq-b\*(rq, \*(lq-h\*(rq, and \*(lq-s\*(rq switches) are
loaded before \*s begins interacting with the user.  Each of the
expressions in the loaded files is executed just as if it were
typed by the user in response to a prompt.  If you wish to load a
set of definitions each time, consider setting up a shell script to
load the file \*(lq.schemerc\*(rq from your home directory:
.br
.sp
     {InstallSchemeName} ${HOME}/.schemerc $*
.sp
.br
If you have a 
substantial number of definitions to load each time, it might
be worthwhile to compile the .schemerc file (that is, compile
the definitions and name the resulting object file .schemerc)
or to save the definitions in a heap file (see below).
.LP
Typically, a Scheme programmer creates a source file of
definitions and other Scheme forms using an editor such as
\fIvi\fP(1) or the SWL (Scheme Widget Library) user interface
and loads the file into Scheme to test them.  The
conventional filename extension for \*s source files
is \fI.ss\fP.  Such a file may be loaded during a session by typing
(load~\*(lq\fIfilename\fP\*(rq), or by specifying the filename on
the command line as mentioned above.  Any expression that may be
typed interactively may be placed in a file to be loaded.
.LP
When the \*(lq--script\*(rq option is used, the named file is
treated as a Scheme shell script, and the remaining command-line
arguments are made available via the parameter
\*(lqcommand-line-arguments\*(rq.
For example, the following script prints its command-line arguments.
.br
.sp
#! {InstallBin}/{InstallSchemeName} --script
.br
(for-each
.br
  (lambda (x) (display x) (newline))
.br
  (command-line-arguments))
.sp
.br
.LP
\*s compiles source expressions as it sees them.  In
order to speed loading of a large file, the file may be compiled
with the output placed in an object file.
(compile-file~\*(lqfoo\*(rq) compiles the expressions in the file
\*(lqfoo.ss\*(rq and places the resulting object code on the file
\*(lqfoo.so\*(rq.  Loading a pre-compiled file is no different from
loading the source file, except that loading is faster since
compilation is already done.  
.LP
When \*s is run, it looks for one or more boot files
and/or one or more heap files to load.
Boot files contain the compiled Scheme code that implements most of
the Scheme system, including the interpreter, compiler, and most
libraries.
Heap files contain prebuilt heap images, i.e., saved heap images
into which the boot code has already been loaded.
Heap and boot files may be specified explicitly on the command
line via \*(lq-b\*(rq and \*(lq-h\*(rq options or implicitly.
In the simplest case, no \*(lq-b\*(rq and \*(rq-h\*(lq options
are given and the necessary heap or boot files are loaded
automatically based on the name of the executable.
For example, if the executable name is \*(lqmyapp\*(rq, the
system looks for \*(lqmyapp.heap\*(rq in a set of standard
directories, then for \*(lqmyapp.boot\*(rq.
It also looks for and loads any subordinate heaps or boot files required
by \*(lqmyapp.heap\*(rq or \*(lqmyapp.boot\*(rq.
Subordinate heap and boot files are also loaded automatically for the
first boot file and any heap files explicitly specified via the command line.
When boot and heap files are specified via the command line, all heap
files must come before all boot files, and each file must be listed
before those that depend upon it.
.LP
The \*(lq--verbose\*(rq option may be used to trace the heap and boot file
searching process and must appear before any boot or heap arguments
for which search tracing is desired.
.LP
Ordinarily, the search for heap and boot files is limited to a set of
default installation directories, but this may be overridden by setting
the environment variable SCHEMEHEAPDIRS.
SCHEMEHEAPDIRS should be a colon-separated list of directories, listed in
the order in which they should be searched.
Within each directory, the two-character escape sequence \*(lq%v\*(rq
is replaced by the current version, and the two-character escape sequence
\*(lq%m\*(rq is replaced by the machine type.
A percent followed by any other character is replaced by the second
character; in particular, \*(lq%%\*(rq is replaced by \*(lq%\*(rq, and
\*(lq%:\*(rq is replaced by \*(lq:\*(rq.
If SCHEMEHEAPDIRS ends in a non-escaped colon, the default directories are
searched after those in SCHEMEHEAPDIRS; otherwise, only those listed in
SCHEMEHEAPDIRS are searched.
Under Windows, semi-colons are used in place of colons.
.LP
Boot files consist of ordinary compiled code and may be created by
concatenating a boot header onto the compiled code for one or more
source files, e.g.:
.br
.sp
     % cat myapp.header myapp1.so myapp2.so > myapp.boot
.sp
.br
Boot headers are created with the Scheme procedure
\*(lqmake-boot-header\*(rq, which takes an output file name
and the names of one or more alternatives for the boot file upon
which the new boot file immediately depends, e.g.:
.br
.sp
     % echo '(make-boot-header "myapp.header" "scheme.boot" "petite.boot")' | scheme
.sp
.br
In ordinary usage, one or both of 
\*(lqscheme\*(lq and \*(lqpetite\*(lq should be specified, as
shown above,
when creating the base boot file for an application.
If the application requires the use of the compiler, just
\*(lqscheme\*(lq should be specified.
.LP
Heap files are created via the \*(lq-s\*(rq option.
If the \*(lq-s\*(rq option is present and \*s exits normally
(see \fIexit\fP, below), it will save the heap on the
specified file.
The heap contains the entire state of the
system, so that any procedures or other objects created during a
session are retained.
Saved heaps are typically used to create fast-loading
Scheme-based applications, but they also provide an alternative to
the .schemerc file for customizing the scheme system and
allow suspension of a session to return to at a later time.
Due to differences in
memory address allocation across installations of an operating system,
heaps should always be built on the target system, i.e., the system
upon which the application will run.
This can often be done transparently to the end user via an
installation program.
Heaps may need to be rebuilt from time to time as the operating
environment changes.
For this reason, boot files are preferred if the somewhat slower start-up
time is not an issue.
.LP
The heap level is determined by the \fIlevel\fP argument.
A level zero heap contains the entire heap, a level one heap
contains only those portions that differ from the corresponding level
zero heap, and so on.
A level one heap may be created in a session in which a level zero heap has
been loaded, and the level one heap can be loaded with an additional
\*(lq-h\*(rq option:
.br
.sp
     {InstallSchemeName} -h ${HOME}/.heap -s1 ${HOME}/.heap.1 $*
.br
     {InstallSchemeName} -h ${HOME}/.heap -h ${HOME}/.heap.1 $*
.sp
.br
.LP
If no level follows the \*(lq-s\*(rq switch, the level defaults to the
level of the highest level heap loaded or zero if no heaps have been loaded.
If the special level \*(lq+\*(rq follows the \*(lq-s\*(rq switch, the
level is one level higher than the highest loaded heap or zero if no heaps
have been loaded.
Thus, the following three lines create level zero, one, one, and two heaps.
.br
.sp
     SCHEMEHEAPDIRS=".:"; export SCHEMEHEAPDIRS
.br
     echo | {InstallSchemeName} -b petite.boot -s heap.0
.br
     echo | {InstallSchemeName} -h heap.0 -s+ heap.1
.br
     echo | {InstallSchemeName} -h heap.1 -s heap.1
.br
     echo | {InstallSchemeName} -h heap.1 -s+ heap.2
.sp
.br
.LP
It may be useful to use a shell script that always
loads from and saves to a heap file in the home directory.
.br
.sp
     {InstallSchemeName} -h ${HOME}/.heap -s ${HOME}/.heap $*
.sp
.br
The file ${HOME}/.heap must be created prior to the first time
this script is used.
You should be careful to retain the source for important definitions,
since future releases of \*s will not be compatible with existing heaps
or compiled object files.
.LP
Normally, when a heap file is saved, the heap is first compacted.
This can consume significant time and additional memory for very large
heaps.
The \*(lq-c\*(rq option can be used to disable this compaction.
Multiple \*(lq-c\*(rq options toggle heap compaction; it is thus
possible to use a shell script that disables compaction by default
while still allowing compaction if desired.
The \*(lq-c\*(rq option has no effect if the \*(lq-s\*(rq option has
not been specified.
.LP
You can exit the system by typing the end-of-file character
(normally Control-D) or by using the procedure \fIexit\fP.
Typing Control-D is equivalent to (exit), (exit (void)), or
(exit 0), each of which is considered a \*(lqnormal exit\*(rq.
If the \*(lq-s\*(rq option
is present (see above), a normal exit causes the
system to save the heap in the given file.
.LP
Interaction of the system with the user is performed
by a Scheme program called a \fIwaiter\fP, running in a
program state called a \fI\*c\fP.  The waiter
merely prompts, reads, evaluates, prints and loops
back for more.  It is possible to open up a chain of \*s
\*cs by invoking the \fInew-cafe\fP procedure with no arguments.
New-cafe is also one of the options when an interrupt
occurs.  Each \*c has its own reset and exit procedures.
Exiting from one \*c in the chain returns you to the next one
back, and so on, until the entire chain closes and you leave the
system altogether.  Sometimes it is useful to
interrupt a long computation by typing the interrupt character,
enter a new \*c to execute something (perhaps to check a status
variable set by computation), and exit the \*c back to the old
computation.
.LP
You can tell what level you are at by the number of angle brackets
in the prompt, one for level one, two for level two, and so on.
Three angle brackets in the prompt means you would have to exit from
three \*cs to get out of \*s.  If you wish to abort
from \*s and you are several \*cs deep, the procedure
\fIabort\fP leaves the system directly.
.LP
Running programs may be interrupted by typing the interrupt
character (normally DEL, BREAK or Control-C).   In response, the
system enters a debug handler, which prompts for input with a
\*(lqdebug>\*(rq prompt.
Several commands may be issued to the debug handler, including
\*(lqe\*(rq to exit from the handler and continue,
\*(lqr\*(rq to reset to the current \*c,
\*(lqa\*(rq to abort \*s,
\*(lqn\*(rq to enter a new \*c,
\*(lqi\*(rq to inspect the current continuation, and
\*(lqs\*(rq to display statistics about the interrupted program.
While typing an expression to the waiter, the interrupt character
simply resets to the current \*c.
.LP
When an error occurs, the system prints an error message and
resets.
Typing (debug) after an error occurs places you into the
debug handler, where you can inspect the current continuation (control
stack) to help determine the cause of the problem.
.LP
Complete documentation for \*s is available in two parts:
\fIThe Scheme Programming Language, Third Edition\fP, and
\fIThe Chez Scheme Version 7 User's Guide\fP.
Both documents are available electronically at
\fIwww.scheme.com\fP as well as in printed form.
.LP
Several example Scheme programs, ranging from a simple factorial procedure
to a somewhat complex unification algorithm, are in the examples directory
(see FILES below).  Looking at and trying out example programs is a good way
to start learning Scheme.
.SH ENVIRONMENT
.LP
The environment variable
.B SCHEMEHEAPDIRS \fR
(see above) may be set
to a colon-separated (semi-colon under Windows) list of directories
in which to search for boot and heap files.
.SH FILES
.if 0 COMMENT: put the longest path from below in the tab computation:
.ta \w'{InstallLibBin}'u+.25i
{InstallBin}/{InstallSchemeName}	executable file
.br
{InstallBin}/{InstallPetiteName}	executable file
.br
{InstallLibLib}	example program library
.br
{InstallLibBin}	boot, heap, and include files
.sp
.br
.SH SEE ALSO
.in +5
.br
.ti -5
R. Kent Dybvig,
\fIThe Scheme Programming Language, Third Edition\fP,
MIT Press (2003).
.br
.ti -5
R. Kent Dybvig,
\fIChez Scheme Version 7 User's Guide\fP,
Cadence Research Systems (2005).
.br
.ti -5
IEEE Computer Society,
\fIIEEE Standard for the Scheme Programming Language\fP,
IEEE Std 1178-1990 (1991).
.br
.ti -5
Daniel P. Friedman and Matthias Felleisen,
\fIThe Little Schemer\fP, fourth edition,
MIT Press (1996).
.br
.ti -5
Harold Abelson and Gerald J. Sussman with Julie Sussman,
\fIStructure and Interpretation  of Computer Programs,
Second Edition\fP,
MIT press (1996).
.br
.ti -5
Richard Kelsey, Will Clinger and Jonathan Rees, eds.,
.if t \*(lqRevised\u5\d Report on the Algorithmic Language Scheme,\*(rq
.if n \*(lqRevised^5 Report on the Algorithmic Language Scheme,\*(rq
Higher Order and Symbolic Computation 11, 1, 1999.
.in -5
.SH AUTHOR
Cadence Research Systems, \fIhttp://www.scheme.com\fP
