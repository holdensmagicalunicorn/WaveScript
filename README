

See INSTALL for installation.



<Running Regiment>
======================================================================

Running regiment from the command-line will enable you to:

 *) Compile Regiment source.  "regiment c"
    Compile (.rs) to Token Machines (.tm) and .tm to simulator files
    for the TM network simulator, or to NesC files for use with the
    Tossim simulator (currently incomplete).

 *) Run the TM network simulator. "regiment s"

 *) Load the Regiment source and interact with it. "regiment i"

There are separate scripts for invoking the WaveScript variant of the
system.  Use "ws" and "wsc".  See the wavescript manual under
doc/wavescript_manual.


<Using the GUI>
======================================================================

Start SWL from the $REGIMENTD/src directory, or start SWL and switch to it with
   (cd (getenv "REGIMENTD")) 
   (cd "src")

Type (load "main_chez.ss").

Now you should be able to load Regiment source files (or Token Machine
source files) and run them/interact with them through the GUI.

Try: (load-regiment "demos/regiment/simple_fold.rs")

You will now have three windows open.  The Scheme interaction window
(REPL), the stdout window for output messages from the simulator.  (If
you press "Print Stats" for example, the output goes here.)





<URGENT note on code: Things in transition.>
======================================================================

Certain things are in the process of happening.  As a result the
inconsistencies might be confusing.

 *) Reformatting comments for Schemedoc is a work-in-progress.
 *) Converting to the common module format.  (See regmodule.ss)
    I'm gradually changing modules over, currently [2006.02.28], the
    vast majority are still either in chez-format or PLT format.


<Documentation>
======================================================================

In addition to this README, there are a number of papers published on
Regiment.  Further, there is the code-documentation.  At some point in
the future there will hopefully be a proper manual for
regiment.  -[2006.02.15]

The code-documentation is generated by Schemedoc.  
Please see doc/README.


<Basic Summary of Folders>
======================================================================

src/
  There are only a few files in this directory.  Entry points to the
  system, configuration code, a Makefile, and this README.

src/generic/
  The vast majority of the code, used by both PLT and Chez ports of
  the system.

src/chez/
  Pieces of code that are Chez-only.

src/plt/
  Pieces of code that are PLT-only.

src/C/
  C extensions used within Regiment's Chez Scheme source.


<Basic Summary of Files>
======================================================================
This doesn't cover everything.

main_chez.ss & main_plt.ss:
  Entry point.  Load all the compiler files into Chez/PLT Scheme.

main.ss:
  This defines the compiler as a composition of the individual
  passes.  It contains run-compiler for invoking the system.  (It
  also, in spite of the name, contains a front-end to the simulator.
  Really, it's the "main" file.)

config.ss:


regiment.ss & regiment_script.ss:
  A system for invoking regiment from the command line.

generic/passes/*:
  These files are the compilers primary transformations.

generic/langs/*:
  These files define executable simulations of the between-pass
  languages.  We do have a simple, non-node-level, simulation that can
  be run even before the token machine simulator.  But these lang files
  are not used extensively and will be phased out.

generic/testing/system_tests.ss:
  The primary system tests.

generic/constants.ss:
  Widely used constants and tunable parameters for the system.

generic/util/helpers.ss:
  Library code.  This has a bunch of unused stuff in it.

generic/compiler_components/prim_defs.ss:
  The specification for every primitive in the Regiment/WaveScript systems.

generic/compiler_components/regiment_helpers.ss:
  Various helper routines specifically for working with Regiment/TML code.
  
generic/compiler_components/hm_type_inference.ss:
  The type checker.
    
generic/sim/simulator_alpha.ss:
generic/sim/simulator_alpha_datatypes.ss:
generic/sim/alpha_lib.ss:
generic/sim/alpha_lib_scheduler_simple.ss:
  The newest token machine simulator.


<WHERE STUFF IS>
======================================================================

Unit Tests:
The unit test executor itself is in generic/helpers.ss

Every file that has unit tests defines its own "these-tests" variable,
as well as a "test-this" variable.  (It may optionally bind these to
other, more unique, names as well: test1, test2, test-graphics, and so on.)

The function "test-units" runs (or should) all the unit tests in the
system.

I have made some effort to ensure that a unit-tests will run after
only loading the file in question.  Anything bigger counts as a
"system test", and goes in compiler.ss.  However, in a bunch of places
this doesn't quite make sense (in particular, utility files and the
cleanup-token-machine pass), so I believe this convention is begining
to slip in certain places. -rrn [2005.09.24]

  Simulator unit tests:
  The old simulator nought, which had problems, also had many unit tests.
  The current simulator alpha doesn't have so many, because I decided
  to start doing things that seem like "system tests" in compiler.ss,
  and most of simulator alpha's tests fall into this category.
  I should, however, look at the progs in simulator_nought.examples.ss
  and make simulator_alpha tests for them..
  -rrn [2005.09.24]
 

NOTE on TESTING: There are a number of toggles and parameters in the
system (mostly concentrated in constants.ss).  I am following a
convention where I sprinkle the exact phrase "TOGGLE FOR UNIT TESTING"
throughout the code.  When unit testing, you should be able to change
the values of these parameters and have it complete its tests.  In
fact, to test thoroughly, you should exercise the system in all of the
major configurations.
( [2007.03.12] Note, with the much newer "supertest" system, I hope to
at some point automatically permute major system parameters during
nightly unit tests. )


<Debugging tips>
======================================================================

 *) Whenever trying to use Chez's interactive debugger (using "(debug)"),
you should remember to go to the top of compiler_chez.ss and set the
optimize-level to 0.  Otherwise inlining might result in you not
seeing stack frames in the inspector that you expect to see.
  [With WaveScript, simply run ws.debug - 2007.03.12]

 *) Chez's interactive inspecter is good, use "(break)" or 
"(call/cc inspect)" liberally (sometimes the latter is what you need).

 *) If you're using SWL and you get the cryptic "invalid command name "0""
 error, this probably means that you're attempting a method call on a
deleted object.  My memory is fuzzy however, I did figure this out in
the past, but I need to remember exactly what causes this.  <TODO>




======================================================================

[2004.11.13]

I need to explain the multi-backend structure of this project.  For
now suffice it to say that it supports two backends (drscheme and
chezscheme).  There's a directory for shared code (generic) and
directories specific to each.  Sometimes within the shared code I
might use the "current_interpreter" variable to switch the behavior
based on which backend we're using.

[- Addendum: Now I use the macro IFCHEZ primarily to switch back and
forth, also there's a common module syntax.  See src/chez/regmodule.ss -]

[2005.02.13]

I have tagged all my little shorthand commands for invoking the system with a
";; shorthand" comment.  By searching for this I should be able to find all the 
shorthands.  These are esoteric, and will make the system confusing to
others, but you should just be able to ignore them.

