
<INSTALLATION>
======================================================================


Quick Start:

You probably already checked out the code like this.
  svn co http://macroprogramming.ffh.us/repos/trunk ~/macroprogramming

Now switch to macroprogramming/regiment_alpha/src and run this script.
  ./install_environment_vars

NOW, if you're lucky (and this only currently works out of the box on
Linux), try running the command "regiment".  If it loads and you get
the help info, then you're good to go.


Slightly less Quick Start:

If you want to manually (and more permanently) set up the necessary
environment variables, all you need to do is the following.

Step 1: Bind enviroment variable REGIMENTD to the location of the
        regiment directory.

Step 2: add $REGIMENTD/bin to your path (or just run "regiment" from there).

Step 3: try typing 'regiment' and see if you get the help output.


If you did that means the free copy of Petite Chez Scheme was able to
run and successfully load all of the Regiment source.  Or it means
that you acquired a compiled heap image in
$REGIMENTD/build/regiment.0.heap, which Petite loaded from (this is
much faster).

Either way, try "regiment t" to run all the unit tests.
  ([2005.11.14] For me this takes 48 seconds with petite, and 18 with a
   saved heap when all debugging is turned on.)




<Running Regiment>
======================================================================

Running regiment from the command-line will enable you to.

 *) Compile Regiment source.  "regiment c"
    Compile (.rs) to Token Machines (.tm) and .tm to simulator files
    for the TM network simulator, or to NesC files for use with the
    Tossim simulator (currently incomplete).

 *) Run the TM network simulator. "regiment s"

 *) Load the Regiment source and interact with it. "regiment i"


<Using the GUI>
======================================================================

Start SWL from the $REGIMENTD/src directory, or start SWL and switch to it with
   (cd (getenv "REGIMENTD")) 
   (cd "src")

Type (load "compiler_chez.ss").

Now you should be able to load Regiment source files (or Token Machine
source files) and run them/interact with them through the GUI.

Try: (load-regiment "demos/regiment/simple_fold.rs")

You will now have three windows open.  The Scheme interaction window
(REPL), the stdout window for output messages from the simulator.  (If
you press "Print Stats" for example, the output goes here.)


<Basic Summary of Files>
======================================================================
This doesn't cover everything.

compiler_chez.ss/compiler_plt.ss:
  Entry point.  Load all the compiler files into Chez/PLT Scheme.

compiler.ss:
  This defines the compiler as a composition of the individual
  passes.  It contains run-compiler for invoking the system.  (It
  also, in spite of the name, contains a front-end to the simulator.
  Really, it's the "main" file.)

generic/pass??_*:
  These files are the compilers primary transformations.

generic/lang??_*:
  These files define executable simulations of the between-pass
  languages.  We do have a simple, non-node-level, simulation that can
  be run even before the token machine simulator.  But these lang files
  are not used extensively and will be phased out.

generic/system_tests.ss:
  The primary system tests.

generic/constants.ss:
  Widely used constants and tunable parameters for the system.

generic/helpers.ss:
  Library code.  This has a bunch of unused stuff in it.

generic/regiment_helpers.ss:
  Various helper routines specifically for working with Regiment/TML code.
  
generic/hm_type_inference.ss:
  The type checker.
    
generic/simulator_alpha.ss:
generic/simulator_alpha_datatypes.ss:
generic/alpha_lib.ss:
generic/alpha_lib_scheduler_simple.ss:
  The newest token machine simulator.



<WHERE STUFF IS>
======================================================================

Unit Tests:
The unit test executor itself is in generic/helpers.ss

Every file that has unit tests defines its own "these-tests" variable,
as well as a "test-this" variable.  (It may optionally bind these to
other, more unique, names as well: test1, test2, test-graphics, and so on.)

The function "test-units" runs (or should) all the unit tests in the
system.

I have made some effort to insure that a unit-tests will run after
only loading the file in question.  Anything bigger counts as a
"system test", and goes in compiler.ss.  However, in a bunch of places
this doesn't quite make sense (in particular, utility files and the
cleanup-token-machine pass), so I believe this convention is begining
to slip in certain places. -rrn [2005.09.24]

  Simulator unit tests:
  The old simulator nought, which had problems, also had many unit tests.
  The current simulator alpha doesn't have so many, because I decided
  to start doing things that seem like "system tests" in compiler.ss,
  and most of simulator alpha's tests fall into this category.
  I should, however, look at the progs in simulator_nought.examples.ss
  and make simulator_alpha tests for them..
  -rrn [2005.09.24]
 

NOTE on TESTING: There are a number of toggles and parameters in the
system (mostly concentrated in constants.ss).  I am following a
convention where I sprinkle the exact phrase "TOGGLE FOR UNIT TESTING"
throughout the code.  When unit testing, you should be able to change
the values of these parameters and have it complete its tests.  In
fact, to test thoroughly, you should exercise the system in all of the
major configurations.



<Debugging tips>
======================================================================

 *) Whenever trying to use Chez's interactive debugger (using "(debug)"),
you should remember to go to the top of compiler_chez.ss and set the
optimize-level to 0.  Otherwise inlining might result in you not
seeing stack frames in the inspector that you expect to see.





======================================================================

[2004.11.13]

I need to explain the multi-backend structure of this project.  For
now suffice it to say that it supports two backends (drscheme and
chezscheme).  There's a directory for shared code (generic) and
directories specific to each.  Sometimes within the shared code I
might use the "current_interpreter" variable to switch the behavior
based on which backend we're using.


[2005.02.13]

I have tagged all my little shorthand commands for invoking the system with a
";; shorthand" comment.  By searching for this I should be able to find all the 
shorthands.  These are esoteric, and will make the system confusing to
others, but you should just be able to ignore them.


