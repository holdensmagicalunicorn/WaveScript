
<INSTALLATION>
======================================================================


Quick Start:

You probably already checked out the code like this.
  svn co http://macroprogramming.ffh.us/repos/trunk macroprogramming


Slighly less Quick Start:

The install_environment_vars script is just 

Step 1: Bind enviroment variable REGIMENTD to the location of the
        regiment directory.

Step 2: add $REGIMENTD/bin to your path (or just run "regiment" from there).

Step 3: try typing 'regiment' and see if you get the help output.


If you did that means the free copy of Petite Chez Scheme was able to
run and successfully load all of the Regiment source.  Or it means
that you acquired a compiled heap image in
$REGIMENTD/build/regiment.0.heap, which Petite loaded from (this is
much faster).

Either way, try "regiment t" to run all the unit tests.
  ([2005.11.14] For me this takes 48 seconds with petite, and 18 with a
   saved heap when all debugging is turned on.)




<Running Regiment>
======================================================================

Running regiment from the command-line will enable you to.

 *) Compile Regiment source.  "regiment c"
    Compile (.rs) to Token Machines (.tm) and .tm to simulator files
    for the TM network simulator, or to NesC files for use with the
    Tossim simulator (currently incomplete).

 *) Run the TM network simulator. "regiment s"

 *) Load the Regiment source and interact with it. "regiment i"


<Using the GUI>
======================================================================

Start SWL from the $REGIMENTD/src directory, or start SWL and switch to it with
   (cd (getenv "REGIMENTD")) 
   (cd "src")

Type (load "compiler_chez.ss").

Now you should be able to load Regiment source files (or Token Machine
source files) and run them/interact with them through the GUI.

Try: (load-regiment "demos/regiment/simple_fold.rs")

You will now have three windows open.  The Scheme interaction window
(REPL), the stdout window for output messages from the simulator.  (If
you press "Print Stats" for example, the output goes here.)


<Basic Summary of Files>
======================================================================


generic/pass??_*:
  These files are the compilers primary transformations.







<WHERE STUFF IS>
======================================================================

Unit Tests:
The unit test executor itself is in generic/helpers.ss

Every file that has unit tests defines its own "these-tests" variable,
as well as a "test-this" variable.  (It may optionally bind these to
other, more unique, names as well: test1, test2, test-graphics, and so on.)

The function "test-units" runs (or should) all the unit tests in the
system.

I have made some effort to insure that a unit-tests will run after
only loading the file in question.  Anything bigger counts as a
"system test", and goes in compiler.ss.  However, in a bunch of places
this doesn't quite make sense (in particular, utility files and the
cleanup-token-machine pass), so I believe this convention is begining
to slip in certain places. -rrn [2005.09.24]

  Simulator unit tests:
  The old simulator nought, which had problems, also had many unit tests.
  The current simulator alpha doesn't have so many, because I decided
  to start doing things that seem like "system tests" in compiler.ss,
  and most of simulator alpha's tests fall into this category.
  I should, however, look at the progs in simulator_nought.examples.ss
  and make simulator_alpha tests for them..
  -rrn [2005.09.24]
 

NOTE on TESTING: There are a number of toggles and parameters in the
system (mostly concentrated in constants.ss).  I am following a
convention where I sprinkle the exact phrase "TOGGLE FOR UNIT TESTING"
throughout the code.  When unit testing, you should be able to change
the values of these parameters and have it complete its tests.  In
fact, to test thoroughly, you should exercise the system in all of the
major configurations.



======================================================================

[2004.11.13]

I need to explain the multi-backend structure of this project.  For
now suffice it to say that it supports two backends (drscheme and
chezscheme).  There's a directory for shared code (generic) and
directories specific to each.  Sometimes within the shared code I
might use the "current_interpreter" variable to switch the behavior
based on which backend we're using.


[2005.02.13]

I have tagged all my little shorthand commands for invoking the system with a
";; shorthand" comment.  By searching for this I should be able to find all the 
shorthands.  These are esoteric, and will make the system confusing to
others, but you should just be able to ignore them.


