;;; driver.ss
;;; Jan 3, 2001
;;; Kent Dybvig
;;; Modified by Ryan Newton (RRN) 2001-2002

;;; This file contains driver code for running p423 compilers through
;;; their paces.

;;; In order to use the driver, the p423 compiler must define the
;;; variable pass-names to be a list of the pass names in the order
;;; in which they should be applied.

;;; NOTE RRN: ALSO, it expects reset-name-count! to be exposed to 
;;; it from helpers.ss!!  FURTHER, it depends on the variable "tests".


;;; Entry points of interest are:

;;;  (test-one '<program>)
;;;  (test-one '<program> <emit?>)
;;;  (test-one '<program> <emit?> <verbose?>)
;;;    Compile and test <program>.  test-one first computes the correct
;;;    answer by evaluting it with Chez Scheme's interpreter.  It then
;;;    passes the program to the first pass, evalutes the resulting
;;;    program, and compares the value with the correct answer.  If it
;;;    compares equal? (RRN: replaced this with tester-eq?) 
;;;    , it goes on to the next pass, passing it the
;;;    program returned by the first.  It repeats this process until
;;;    all passes have been run, then exits.
;;;
;;;    If a pass is a code-generation pass (generate-MSIL),
;;;    its output is compiled or assembled, linked with the run-time
;;;    code in startup.c, and run.  The output is read back in and
;;;    compared with the correct answer.  The next pass, if
;;;    any, is run on the output of the preceding pass.
;;;
;;;    If the result of evaluating the program returned by any of the
;;;    passes does not equal the correct answer or if the evaluation
;;;    causes an error, test-one stops, prints the input to the pass,
;;;    prints the output to the pass, and displays the error message.
;;;    If a problem occurs while running a pass, test-one stops, prints
;;;    the input to the pass, and displays the error message.
;;;
;;;    test-one calls reset-name-count! before running the first pass
;;;    to reset rename's internal count.
;;;
;;;    If <emit?> is false, test-one doesn't build or run the code
;;;    generated by the code generation pass(es).  This is useful when
;;;    trying to test changes to earlier parts of the compiler, since
;;;    the process of building an executable file and running it is
;;;    rather slow.  <emit?> defaults to #t.
;;;
;;;    If <verbose?> is false, less diagnostic information is printed.
;;;    <verbose?> defaults to #t.
;;;
;;;  (test-all)
;;;  (test-all <emit?>)
;;;  (test-all <emit?> <verbose?>)
;;;    Runs test-one in order on the tests in the list bound to the
;;;    variable test, stopping if any test fails.  Usually used with
;;;    tests.ss loaded.  If <verbose?>  is true, test-all prints each
;;;    test before it is compiled and run.  Passes <emit?>  and <verbose?>
;;;    along to test-one.  <emit?>  and <verbose?> both default to #t.
;;;  (test-all-but)
;;;    Runs all tests, but abstains from running the last pass.  This
;;;    should run without any kind of .NET system.  -RRN
;;;
;;;  (analyze-all)
;;;  (analyze-all <emit?>)
;;;    Runs test-one in order on the tests in the list bound to the
;;;    variable test.  Does not stop for when a test fails.  Usually
;;;    used with tests.ss loaded.  Passes <emit?> along to test-one,
;;;    with <verbose?> false.  <emit?> defaults to #t.  Prints a "." for
;;;    each test before running it, but doesn't print the test itself.
;;;    Prints a summary after all tests have been run.
;;;
;;;  (tracer #t)
;;;    Causes test-one to print the output of each pass.
;;;
;;;  (tracer '<pass-name>)
;;;    Causes test-one to print only the output of the specified
;;;    pass.
;;;
;;;  (tracer '(<pass-name> ...))
;;;    Causes test-one to print only the output of the specified
;;;    passes.  Some interesting subcases here include:
;;;
;;;    (tracer '())
;;;      don't trace anything
;;;
;;;    (tracer (memq '<pass-name> pass-names))
;;;      trace everything from the specified pass on
;;;
;;;  (game-eval)
;;;  (game-eval <proc>)
;;;    game-eval is a parameter that determines the evaluator used to
;;;    evaluate the output of each nongenerator pass.  When called without
;;;    arguments, it returns the current game evaluator.  When called
;;;    with one argument, <proc>, it sets the game evaluator to <proc>.
;;;    The initial game evaluator is interpret, which provides quick
;;;    turnaround for small test cases.  Set it to compile to get better
;;;    error messages and inspector information.
;;;
;;;  (host-eval)
;;;  (host-eval <proc>)
;;;   RRN added [2004.05.04]: this parameter determines the evaluator
;;;   used to evaluate the original expression in the host scheme
;;;   system.

;;;
;;;  (print-file '<pathname>)
;;;    Prints the contents of the file specified by <pathname> to the
;;;    current output port.
;;;
;;;  (remaining-pass-names)
;;;  (remaining-pass-names <pass-names>)
;;;    Without arguments, returns the list of remaining pass names.
;;;    Otherwise, sets the list of remaining pass names to <pass-names>.
;;;    This may be used to iterate one or more passes.


;(module (tracer game-eval analyze-all test-all test-all-but test-all-toplvl
;                test-one print-file remaining-pass-names)
        
(define test-ordinal #f)

(define tracer
  (let ([trace-list '()])
    (case-lambda
      [() trace-list]
      [(x)
       (set! trace-list
             (cond
               [(eq? x #t) pass-names]
               [(and (symbol? x) (memq x pass-names)) (list x)]
               [(and (list? x) (andmap (lambda (x) (memq x pass-names)) x)) x]
               [else (error 'tracer "invalid argument ~s" x)]))])))

(define game-eval
  (make-parameter eval ;interpret
                  (lambda (x)
                    (unless (procedure? x)
                      (error 'game-eval "~s is not a procedure" x))
                    x)))

;; Used to control the host evaluator (the host scheme system that is).
(define host-eval
  (make-parameter eval ;interpret
                  (lambda (x)
                    (unless (procedure? x)
                      (error 'host-eval "~s is not a procedure" x))
                    x)))

(define analyze-all
  (case-lambda
    [() (analyze-all #t)]
    [(emit?)
     (define mod 72)
     (let f ([tests tests] [n 0] [passed 0] [m mod])
       (if (null? tests)
           (printf "~%~s of ~s tests passed~%" passed n)
           (begin
             (if (call/cc
                   (lambda (k)
                     ;; RRN [2004.04.28] Killing this for PLT compat:
;                     (parameterize ([reset-handler (lambda () (k #f))])
                       ($test-one (car tests) emit? #f n)
                       #t));)
                 (begin
                   (when (= m mod) (newline))
                   (write-char #\.)
                   (flush-output-port)
                   (f (cdr tests) (+ n 1) (+ passed 1) (+ (modulo m mod) 1)))
                 (f (cdr tests) (+ n 1) passed mod)))))]))

(define test-all-but
  (lambda ()
    ;; Remove last pass (generate-MSIL) and run test-all.
    ;; Also make sure snet-optimize-level is high enough that
    ;; primitive names are reserved.
    (fluid-let ([pass-names (rdc pass-names)])
      (test-all))))


(define test-all
  (case-lambda
    [() (real-test-all #t #t 2)]
    [(emit?) (real-test-all emit? #t 2)]
    [(emit? verbose?) (real-test-all emit? verbose? 2)]
    [(emit? verbose? optlvl) (real-test-all emit? verbose? optlvl)]))

(define real-test-all
  (lambda (emit? verbose? optlvl)
      (let f ([tests tests] [n 0])
        (unless (null? tests)
          (when verbose?
            (let ([s (format "~s: " n)])
              (display s)
;              (parameterize ([pretty-initial-indent (string-length s)])
                (pretty-print (car tests))
;		)
	      ))
          ($test-one (car tests) emit? verbose? n)
          (f (cdr tests) (+ n 1))))))

(define print-file
  (lambda (path)
    (with-input-from-file path
      (rec f
           (lambda ()
             (unless (eof-object? (peek-char))
               (write-char (read-char))
               (f)))))))

(define test-one
  (case-lambda
    [(expr)                ($test-one expr #t #t #t)]
    [(expr emit?)          ($test-one expr emit? #t #t)]
    [(expr emit? verbose?) ($test-one expr emit? verbose? #t)]
    ))

(define remaining-pass-names (make-parameter '()))

(define $test-one
  (lambda (original-input-expr emit? verbose? ordinal)
    (let ([answer 
	   ;(interpret original-input-expr)])
	   ((host-eval) original-input-expr)]
	  ;; RRN: hacking this in way that makes it highly non-general:
	  [pre-deglobalize #t]
	  [stub-eval (lambda ignored 'unspecified)]
	  )
      (define-syntax on-error
        (syntax-rules ()
          [(_ e0 e1 e2 ...)
           (parameterize ([error-handler
                            (let ([eh (error-handler)])
                              (lambda args
;; RRN 2004.04.28 - Eliminating for compatibility with PLT:
;                                (parameterize ([current-output-port
;                                                 (console-output-port)])
                                  e0;)
                                (apply eh args)))])
             e1 e2 ...)]))
      (define check-eval
        (lambda (pass-name input-expr output-expr)
          (on-error
            (when verbose?
              (printf "~%~s input:~%" pass-name)
              (pretty-print input-expr)
              (printf "========~%~s output:~%" pass-name)
              (pretty-print output-expr))
            (let ([t 
                   ;; RRN Cancelling this for PLT compatibility
;                   (parameterize ([run-cp0 (lambda (cp0 x) x)])
                       (on-error
                         (if ordinal
                             (printf "~%Error occurred running output of pass ~s on test ~s"
                                     pass-name ordinal)
                             (printf "~%Error occurred running output of pass ~s" pass-name))
                         ((if pre-deglobalize
			      (game-eval) 
			      stub-eval) output-expr));)
                       ])
              (unless (tester-eq? t answer)
                (if ordinal
                    (error pass-name
                           "test ~s answer is ~s, should have been ~s"
                           ordinal t answer)
                    (error pass-name
                           "answer is ~s, should have been ~s"
                           t answer)))))))
      (define check-build-eval
        (lambda (pass-name input-expr output-expr type pretty)
          (define src-file (format "~atst.~a" type type))
          (define err-file (format "~atst.err" type))
          (define out-file (format "~atst.out" type))
          (define exe-file (format "~atst" type))
          (with-output-to-file src-file
            (lambda ()
              (printf "/*~%")
              (pretty-print original-input-expr)
              (printf "*/~%~%")
              (newline)
              (display output-expr))
            'replace)
          (on-error
            (begin
              (if ordinal
                  (printf "~%Error occurred while running code generated by ~s for test ~s~%"
                          pass-name ordinal)
                  (printf "~%Error occurred while running code generated by ~s~%"
                          pass-name))
              (when verbose?
                (printf "~s input:~%" pass-name)
                (pretty-print input-expr)
                (printf "========~%~s output:~%" pass-name)
                (pretty output-expr)
                (printf "========~%"))
              (print-file err-file))
            (let ([t (build-and-run src-file err-file out-file exe-file)])
              (unless (tester-eq? t answer)
                (error pass-name "answer is ~s, should have been ~s"
                       t answer))))))
      (define run
        (lambda (input-expr)
          (unless (null? (remaining-pass-names))
            (let ([pass-name (car (remaining-pass-names))])
	      (if (eq? pass-name 'deglobalize) (set! pre-deglobalize #f))
              (remaining-pass-names (cdr (remaining-pass-names)))
              (when (memq pass-name (tracer))
                (printf "~%;=======================================~a~%"
                        "========================================")
                (printf "~s:~%" pass-name))
              (let ([pass (eval pass-name)])
                (let ([output-expr
                        (on-error
                          (begin
                            (if ordinal
                                (printf "~%Error occurred within pass ~s on test ~s" pass-name ordinal)
                                (printf "~%Error occurred within pass ~s" pass-name))
                            (when verbose?
                              (printf "~%~s input:~%" pass-name)
                              (pretty-print input-expr)))
                          (pass input-expr))])
                  (case pass-name
                    [(generate-C-code)
                     (when emit?
                       (check-build-eval pass-name input-expr output-expr
                                         "c" pretty-C-print))
                     (when (memq pass-name (tracer))
                       (pretty-C-print output-expr))
                     (run input-expr)]
                    [(generate-Sparc-code)
                     (when emit?
                       (check-build-eval pass-name input-expr output-expr
                                         "s" pretty-asm-print))
                     (when (memq pass-name (tracer))
                       (print-file "stst.s"))
                     (run input-expr)]
                    [else
                      (check-eval pass-name input-expr output-expr)
                      (when (memq pass-name (tracer))
                        (pretty-print output-expr))
                      (run output-expr)])))))))
      (reset-name-count!)
      (parameterize ([remaining-pass-names pass-names])
        (run original-input-expr)))))

(define pretty-asm-print
  (lambda (x)
    (printf "~a~%" x)))

(define pretty-C-print
  (lambda (output-expr)
    (let ((op (open-output-file "tmp.c" 'replace)))
      (display output-expr op)
      (close-output-port op)
      (system "/l/SUNWspro/bin/cb tmp.c | expand -2 | sed -e '2,$s/^\\([a-z]\\)/\\
              \\1/' > cbtmp.c")
      (print-file "cbtmp.c"))))

(define build-and-run
  (lambda (src-file err-file out-file exe-file)
    (unless (= 0 (shell "cc -o ~a startup.c ~a > ~a 2>&1"
                        exe-file src-file err-file))
      (error 'build-and-run "build error(s)"))
    (let ([status (shell "exec ./~a > ~a 2>&1" exe-file out-file)])
      (shell "cat ~a >> ~a" out-file err-file)
      (unless (= status 0)
        (error 'build-and-run "run error(s)")))
    ; replace #<void> with "#<void>" to make it something the reader can
    ; handle, then substitute void for "#<void>"
    (shell "sed -e 's/#<void>/\"#<void>\"/g' < ~a > ~a.tmp" out-file out-file)
    (let ([ip (open-input-file (format "~a.tmp" out-file))])
      (let ([x (subst (void) "#<void>" (read ip))])
        (close-input-port ip)
        x))))

(define shell
  (lambda (s . args)
    (system (apply format s args))))

;)  ;; End module
