 
;; These are used by code generated by compile-simulate-alpha.

;; ======================================================================
;; Simulator runtime

;; (sim-seed world simob) returns a meta-token-handler of type (msg-object -> ())

(define (sim-seed world)
  (define-structure (tokstore x))
  "This is the simulation seed."
  "It returns an initial set of scheduled actions for the simulator to execute."
  (let ((local-sense (lambda () ((current-sense-function) (node-pos (simobject-node this))))))
    (let* ()
      (letrec ((soc-start
                 (lambda (this current-vtime subtok-index)
		   (disp "soc-start" (node-id this) current-vtime subtok-index)
                   (lambda args
                     (let* ((the-store (simobject-token-store this))
                            (this-tokname (cons 'soc-start subtok-index))
                            (old-outgoing (simobject-outgoing-msg-buf this))
                            (old-local (simobject-local-msg-buf this)))
                       "Is there already an allocated token object?:"
                       (let ((tokobj (hashtab-get the-store this-tokname)))
                         (if (not tokobj)
                           (begin
                             "If not, then we allocate that token object..."
                             " setting the invoke counter to zero."
                             (set! tokobj (vector 0))
                             (hashtab-set! the-store this-tokname tokobj)))
                         (set-simobject-outgoing-msg-buf! this '())
                         (set-simobject-local-msg-buf! this '())
                         (set-simobject-local-msg-buf!
                           this
                           (cons (bare-msg-object tok1 (list)) (simobject-local-msg-buf this)))
                         (set-simobject-outgoing-msg-buf!
                           this
                           (append (reverse (simobject-outgoing-msg-buf this)) old-outgoing))
                         (set-simobject-local-msg-buf!
                           this
                           (append (reverse (simobject-local-msg-buf this)) old-local))
                         (void))))))
               (tok1
                (lambda (this current-vtime subtok-index)
		  (disp "tok1" (node-id this) current-vtime subtok-index)
                  (lambda args
                    (let* ((the-store (simobject-token-store this))
                           (this-tokname (cons 'tok1 subtok-index))
                           (old-outgoing (simobject-outgoing-msg-buf this))
                           (old-local (simobject-local-msg-buf this)))
                      "Is there already an allocated token object?:"
                      (let ((tokobj (hashtab-get the-store this-tokname)))
                        (if (not tokobj)
                          (begin
                            "If not, then we allocate that token object..."
                            " setting the invoke counter to zero."
                            (set! tokobj (vector 0))
                            (hashtab-set! the-store this-tokname tokobj)))
                        (set-simobject-outgoing-msg-buf! this '())
                        (set-simobject-local-msg-buf! this '())
;                        (bcast tok2 '3)
                        (set-simobject-outgoing-msg-buf!
                          this
                          (append (reverse (simobject-outgoing-msg-buf this)) old-outgoing))
                        (set-simobject-local-msg-buf!
                          this
                          (append (reverse (simobject-local-msg-buf this)) old-local))
                        (void))))))
               (tok2
                (lambda (this current-vtime subtok-index)
		  (disp "tok2" (node-id this) current-vtime subtok-index)
                  (lambda args
                    (let* ((the-store (simobject-token-store this))
                           (this-tokname (cons 'tok2 subtok-index))
                           (old-outgoing (simobject-outgoing-msg-buf this))
                           (old-local (simobject-local-msg-buf this)))
                      "Is there already an allocated token object?:"
                      (let ((tokobj (hashtab-get the-store this-tokname)))
                        (if (not tokobj)
                          (begin
                            "If not, then we allocate that token object..."
                            " setting the invoke counter to zero."
                            (set! tokobj (vector 0 '99))
                            (hashtab-set! the-store this-tokname tokobj)))
                        (set-simobject-outgoing-msg-buf! this '())
                        (set-simobject-local-msg-buf! this '())
                        (begin
                          (vector-set! tokobj 1 (+ (vector-ref tokobj 1) '1))
;                          (bcast tok2 (vector-ref tokobj 1))
			  )
                        (set-simobject-outgoing-msg-buf!
                          this
                          (append (reverse (simobject-outgoing-msg-buf this)) old-outgoing))
                        (set-simobject-local-msg-buf!
                          this
                          (append (reverse (simobject-local-msg-buf this)) old-local))
                        (void)))))))
        (values (list))))))


;; This builds a simulation object for a specific node in the network.
;; This object drives the simulation for that node.  
;; When the simulation object is invoked once, it processes all
;; incoming and queued messages and returns the next action to be executed.
;; The execution of that atomic action (token handler) produces new messages
;; both in *this* simobject, and in the incoming fields of other simobjects.

;; It returns this simulation object as a thunk.
(define build-node
  (lambda (ob world meta-handler)
    ;; the scheduling queue contains event entries of the format:
    ;;   [<vtime-to-exec>, <host-simob>, <execution-func>]
    ;; which are also returned from sim-seed in this format.
    (let* ([evnts (sim-seed world)]
	   [evntcmpr (lambda (a b) (<= (car a) (car b)))]
	   [evnts (sort evntcmpr evnts)])
	 ;; Schedule either adds an event to the schedule, 
	 ;; or returns the current schedule in list form.
	 (letrec ([schedule 
		   (let ([buffer '()])
		     (case-lambda 
		      [() buffer]
		      [(evnt) (set! buffer (merge evntcmpr (list evnt) buffer))]))]
		  ;; Wire the token-handler executer into our scheduler.
  	          [wrap (lambda (evnt)
			  (match evnt
				 [(,vtime ,simob ,fun) 
				  (list vtime 
					(lambda (vtimeexeced) ;args				 
					  (for-each schedule 
					       (map wrap 
						    ((fun simob world) vtimeexeced ;args
							   )))))]))])




	   ;; Put all the starting events into the schedule, while
	   ;; also wiring their return values to modify the scheduler
	   ;; further.
	   (for-each schedule (map wrap evnts))

	   
	   ;; Process incoming and local msgs:
	   ;; Add in radio delay and virtual processing time:
	   
	   

	   (action this current-vtime subtok-index args)
	   ;; Now that the atomic action is completed, we feed our own local messages
	   ;; Now deliver outgoing messages:
	   ;; TODO: Here's where we insert the better radio model!!!
	   (let ([outgoing (simobject-outgoing-msg-buf ob)])
	     ;; They're all broadcasts for now
	     (for-each 
	      (lambda (nbr)
		(set-simobject-incoming-msg-buf! 
		 nbr (cons outgoing (simobject-incoming-msg-buf nbr))))
	      (graph-neighbors ob (simworld-object-graph world)))
	     ;; They're all delivered, so we clear our own outgoing buffer.
	     (set-simobject-outgoing-msg-buf! ob '()))


))))



(define run-alpha-sim
;  (lambda (starting-evnts store-factory . stop-time)
  (lambda stop-time
    (let ([stopping-time? (if (null? stop-time)
			      (lambda (t) #f)
			      (lambda (t) (>= t (car stop-time))))])
;      (let ([stores (make-n-list numsimnodes (lambda (_) (store-factory)))])
      (let* ([sim (fresh-simulation)]
	     [soc (car (filter (lambda (n) (eq? BASE_ID (node-id (simobject-node n))))
			       (simworld-all-objs sim)))]
	     [streams 
	      (list->vector
	       (map (lambda (ob)
		      (build-node ob
		       sim ;; the world
		       sim-seed ;; TODO: READ THIS FROM FILE.		       
		       )) 
		    (simworld-all-objs sim)))])

    (let main-sim-loop ([streams streams])      
      (disp "mainsimloop" streams)
      (let* ([streams (map (lambda (s) (if procedure? s) (s) s) streams)]
	     [heads (map stream-car streams)]
	     [nexttime (apply min heads)])
	
	(let* ([next (assq nexttime heads)]
	       [nextstrm (assq next streams)])
	  (if (not (procedure? nextstrm))
	      (error 'run-alpha-sim "nextstrm should be a procedure!: ~a" nextstrm))	  
	  ;; Run this atomic action (token handler), it gets to run at its intended virtual time.
	  ((cadr next) (car next))
	  ;; That had the effect of scheduling new actions, now we keep going.
	  (main-sim-loop (cons (stream-cdr nextstrm) (alist-remove next streams))))))))))


;; From Swindle:
;;>> (merge less? a b)
;;>   Takes two lists `a' and `b' such that both (sorted? a less?) and
;;>   (sorted? b less?) are true, and returns a new list in which the
;;>   elements of `a' and `b' have been stably interleaved so that (sorted?
;;>   (merge less? a b) less?) is true.  Note: this does not accept vectors.
(define (merge less? a b)
  (cond [(null? a) b]
        [(null? b) a]
        [else (let loop ([x (car a)] [a (cdr a)] [y (car b)] [b (cdr b)])
                ;; The loop handles the merging of non-empty lists.  It has
                ;; been written this way to save testing and car/cdring.
                (if (less? y x)
                  (if (null? b)
                    (cons y (cons x a))
                    (cons y (loop x a (car b) (cdr b))))
                  ;; x <= y
                  (if (null? a)
                    (cons x (cons y b))
                    (cons x (loop (car a) (cdr a) y b)))))]))


;; ======================================================================
;; Gets set by .... Something?  TODO FIX UP:
;; All node level utilities below depend on this parameter being set properly.
[define this (make-parameter #f)]

;; ======================================================================
;; Node level utilities 

;; Is set to a list of all the leds that are toggled on.    
[define led-toggle-state '()]

;; MAKE SURE NOT TO INCLUDE OURSELVES:
[define (neighbors obj sim)
  (let ((entry (assq obj (simworld-object-graph sim))))
    (if (null? entry)
        (error 'neighbors "generated code.. .cannot find obj in graph: ~s ~n ~s"
               obj (simworld-object-graph sim))
        (begin 
          (if (memq obj (cdr entry))
              (error 'neighbors "we're in our own neighbors list"))
          (cdr entry))))]

[define sendmsg (lambda (data ob)
                  (set-simobject-incoming! ob
                                           (cons data (simobject-incoming ob)))
                  ;(set-simobject-redraw! ob #t)
                  )]


[define (sim-light-up r g b)
  ((sim-debug-logger) "~n~a: light-up ~a ~a ~a"
                      (node-id (simobject-node this)) r g b)
  (if (simobject-gobj this)
      (change-color! (simobject-gobj this) (rgb r g b))
      ;; We're allowing light-up of undrawn objects atm:
      ;(error 'sim-light-up "can't change color on undrawn object!: ~s" this)
      )]

;; INCOMPLETE (we don't yet draw the leds directly.)
[define (sim-leds what which)
  (let* ([colors 
          (case which
            [(red)   '(255 0 0)]
            [(green) '(0 255 0)]
            [(blue)  '(0 0 255)]
            [else (error 'sim-leds "bad color: ~a" which)])]
         ;; INCOMPLETE:
         ;	     [oldcolors '(0 0 0)]
         )
    (let ((string (format "~a: (time ~s) (Leds: ~a ~a ~a)~n" 	
                          (node-id (simobject-node this)) (cpu-time) which what
                          (case what
                            [(on) 
                             (set! led-toggle-state (list->set (cons which led-toggle-state)))
                             (apply sim-light-up colors)
                             "" ]
                            [(off)
                             (set! led-toggle-state (remq which led-toggle-state))
                             (sim-light-up '(0 0 0))
                             "" ]
                            [(toggle)
                             (if (memq which led-toggle-state)
                                 (begin 
                                   (set! led-toggle-state (remq which led-toggle-state))
                                   (sim-light-up 0 0 0)
                                   "off")
                                 (begin 
                                   (set! led-toggle-state (list->set (cons which led-toggle-state)))
                                   (apply sim-light-up colors)
                                   "on")
                                 )]
                            [else (error 'sim-leds "bad action: ~a" what)]))))
      ;((sim-debug-logger) string)
      (logger string)
      ))]

'[define (sim-dist . tok)
  (if (null? tok)
      (begin 
        (if (msg-object-count this-message)
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist) is broken!")))
      (let ((entry (hashtab-get (simobject-token-cache this) (car tok))))
        (if (and entry (msg-object-count entry))
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist ~s) but ~s has not been received!"
                   (car tok) (car tok))
            )))]

[define (sim-loc) ;; Return this nodes location.
  (node-pos (simobject-node this))]

[define (sim-locdiff a b)
  (sqrt (+ (expt (- (car a) (car b)) 2)
           (expt (- (cadr a) (cadr b)) 2)))]

