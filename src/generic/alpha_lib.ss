
;; These are run-time functions used by code generated by compile-simulate-alpha.

;; ======================================================================
;; Simulator runtime
  
;; This returns:
;; 1) meta-token-handler of type (msg-object, vtime -> ())
;; 2) a cost-table mapping toknames to vtime costs
;(define node-code #f)


;; [2005.09.29] Moved start-alpha-sim and some other global bindings
;; and helpers to simulator_alpha.ss


;; ======================================================================

;; [2005.10.16] The code below does not exist within the scope of the
;; "this" parameter to node-code.  Node-code is kind enough to set
;; this global parameter correctly, so that the current simobject may
;; be accessed by the below library code.
;; NOTE: this is not a "regiment-parameter" because it should not be user-adjustable.
[define current-simobject (make-parameter 'current-simobject_uninitialized!)]

;; ======================================================================
;; Node level utilities 

;; Is set to a list of all the leds that are toggled on.    
[define led-toggle-state '()]

;; [2005.10.29] These three are the interface through which the token-store is accessed.
(define (retrieve-token the-store stok)
  ;; This is defined lamely because equal? doesn't work on records.
  (let ((ls (hashtab-get the-store (token->key stok))))
;    (inspect (cons ls stok))
    (if (not ls) #f
	(let loop ((ls ls))
	  (cond 
	   [(null? ls) #f]
	   [(simtok-equal? (caar ls) stok)  (cdar ls)]
	   [else (loop (cdr ls))])))))

(define (evict-token the-store stok)
  (let* ([key (token->key stok)]
	 [ls (hashtab-get the-store key)]
	 [newls (filter (lambda (x) (not (simtok-equal? (car x) stok))) ls)])
    (if (null? newls)
	(hashtab-remove! the-store key)
	(hashtab-set! the-store key newls))))

(define (add-token the-store stok val)
  (let* ([key (token->key stok)]
	 [ls (hashtab-get the-store key)])
    (hashtab-set! the-store key 
		  (cons (cons stok val) 
			(if ls ls ())))))

;; MAKE SURE NOT TO INCLUDE OURSELVES:
[define (neighbors obj sim)
  (let ((entry (assq obj (simworld-object-graph sim))))
    (if (null? entry)
        (error 'neighbors "generated code.. .cannot find obj in graph: ~s ~n ~s"
               obj (simworld-object-graph sim))
        (begin 
          (if (memq obj (cdr entry))
              (error 'neighbors "we're in our own neighbors list"))
          (cdr entry))))]

[define sendmsg (lambda (data ob)
                  (set-simobject-incoming-msg-buf! ob
                                           (cons data (simobject-incoming-msg-buf ob)))
                  ;(set-simobject-redraw! ob #t)
                  )]


[define (sim-light-up r g b)
  ;((sim-debug-logger) "~n~s: light-up ~s ~s ~s" (node-id (simobject-node (current-simobject))) r g b)
  (logger "~n~s: light-up ~s ~s ~s" (node-id (simobject-node (current-simobject))) r g b)
  (IF_GRAPHICS ;; Fizzle if graphics is not enabled.
   (if (simobject-gobj (current-simobject))       
       (change-color! (simobject-gobj this) (rgb r g b))
      ;; We're allowing light-up of undrawn objects atm:
      ;(error 'sim-light-up "can't change color on undrawn object!: ~s" this)
       ))]

;; todo INCOMPLETE (we don't yet draw the leds directly.)
[define (sim-leds what which)
  (let* ([colors 
          (case which
            [(red)   '(255 0 0)]
            [(green) '(0 255 0)]
            [(blue)  '(0 0 255)]
            [else (error 'sim-leds "bad color: ~s" which)])]
         ;; INCOMPLETE:
         ;	     [oldcolors '(0 0 0)]
         )
    (let ((string (format "~s: (time ~s) (Leds: ~s ~s ~s)~n" 	
                          (node-id (simobject-node (current-simobject))) (cpu-time) which what
                          (case what
                            [(on) 
                             (set! led-toggle-state (list->set (cons which led-toggle-state)))
                             (apply sim-light-up colors)
                             "" ]
                            [(off)
                             (set! led-toggle-state (remq which led-toggle-state))
                             (sim-light-up '(0 0 0))
                             "" ]
                            [(toggle)
                             (if (memq which led-toggle-state)
                                 (begin 
                                   (set! led-toggle-state (remq which led-toggle-state))
                                   (sim-light-up 0 0 0)
                                   "off")
                                 (begin 
                                   (set! led-toggle-state (list->set (cons which led-toggle-state)))
                                   (apply sim-light-up colors)
                                   "on")
                                 )]
                            [else (error 'sim-leds "bad action: ~s" what)]))))
      ;((sim-debug-logger) string)
      (logger string)
      ))]

#;
[define (sim-dist . tok)
  (if (null? tok)
      (begin 
        (if (msg-object-count this-message)
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist) is broken!")))
      (let ((entry (hashtab-get (simobject-token-cache (current-simobject)) (token->key (car tok)))))
        (if (and entry (msg-object-count entry))
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist ~s) but ~s has not been received!"
                   (car tok) (car tok))
            )))]

[define (sim-loc) ;; Return this nodes location.
  (node-pos (simobject-node (current-simobject)))]

[define (sim-locdiff a b)
   (sqrt (+ (expt (- (car a) (car b)) 2)
           (expt (- (cadr a) (cadr b)) 2)))]

[define (simulator-soc-return x)
  (printf "~n  SOCRETURN(t=~s) ~s ~n" 
	  (simworld-vtime (simobject-worldptr (current-simobject)))
	  x)
  (soc-return-buffer (cons x (soc-return-buffer)))]

[define (simulator-soc-finished)
  (printf "~nSOC-FINISHED!~n")(flush-output-port)
  ((escape-alpha-sim))]

;; Just for debugging:
[define (sim-print-queue . id)
  (let ([Q (simworld-scheduler-queue (simobject-worldptr (current-simobject)))]
	[format-evt
	 (lambda (evt)
		 (list (simevt-vtime evt)
		       (list (simtok-name (msg-object-token (simevt-msgobj evt)))
			     (simtok-subid (msg-object-token (simevt-msgobj evt))))
		       (msg-object-args (simevt-msgobj evt))))])
  (printf "Current queue: \n")
  (pretty-print
	  (map (lambda (x) (format-evt (car x)))
	       (if (null? id)
		   Q
		   (filter 
		    (lambda (pr) (= (car id)
				    (node-id (simobject-node (cdr pr)))))
		    Q))))
  (printf "  With local messages: \n")
  (pretty-print (map format-evt (simobject-local-msg-buf (current-simobject))))
  (printf "  And incoming messages: \n")
  (pretty-print (map format-evt (simobject-incoming-msg-buf (current-simobject))))
  (printf "  And timed messages: \n")
  (pretty-print (map format-evt (simobject-timed-token-buf (current-simobject))))
  (newline)
  )]


;; Invariant checker: used only in DEBUGMODE
[define (check-store tokstore)
  (hashtab-for-each
   (lambda (key entries)
     (let ((token (key->token key)))
     (or (and (simtok? token) ;(pair? token)
	      (symbol? (simtok-name token)) ;(symbol? (car token))
	      (number? (simtok-subid token)) ;(number? (cdr token))
	      (andmap (lambda (entry)
			(and (pair? entry)
			     (simtok? (car entry))
			     (or (vector? (cdr entry)) ;; Not sure which of these it'll be.
				 (record? (cdr entry)))))
		      entries)
	      )
	 (error 'check-store "Bad token store at entry: key:~s, token:~s, tokobj: ~n~s" key token tokobj))))
   tokstore)]


;; [2005.11.03] Moved here from constants.ss
;; NOTE: sense-spatial-sine-wave is still in constants.ss

;; This globally defined functions decides the sensor values.
;; Here's a version that makes the sensor reading the distance from the origin:
(define (sense-dist-from-origin id x y t)
  (sqrt (+ (expt x 2) (expt y 2))))

(define (sense-sine-wave id x y t)
  ;(printf "(sensing ~a ~a ~a ~a) " id x y t)
  ;(exact->inexact
   (inexact->exact 
    (floor
     (+ 127.5 (* 127.5 (sin (* t (/ 3.14 1000))))))))

;; TODO: add noise to this, store state per ID: curry inputs:
(define (sense-noisy-rising id x y t)
  (/ t 100.))


(define (sense-random-1to100 id x y t)
  (add1 (reg:random-int 100)))

#;
(define (sense-fast-sine-wave id x y t)
  (printf "(sensing ~a ~a ~a ~a) " id x y t)
  (inexact->exact 
   (floor
    (+ 127.5 (* 127.5 (sin (* t (/ 3.14 1000))))))))


;======================================================================

(define these-tests
  `(

    ["Test adding and retrieving tokens to the store."
     (let ((s (make-default-hash-table)))
       (define-record foo (a b c))
       (apply-ordered list
	(,retrieve-token s (make-simtok 'foo 0))
	(,add-token s [make-simtok 'foo 0] [make-foo 0 'let-stored-uninitialized #f])
	(,retrieve-token s [make-simtok 'foo 0])))
     ,(match-lambda ((,x ,y ,z))
	(and (not x)
	     (pair? y)
	     (record? z)))]

    ))

(define test-this 
  (default-unit-tester "Alpha Lib. run time library supporting simulator alpha."
    these-tests))
(define test-alphalib test-this)

;; Junk:

(define (t)
  (alpha-it
   '(program
     (bindings)
     (nodepgm 
	 (tokens
	  [node-start _ () (stored) (bindings) (display "N")]
	  ;[node-start () (stored) (void)]
	  [SOC-start _ () (stored) (bindings) (begin (printf "S") (call tok1))]
	  [tok1 _ () (stored) (bindings) (begin (display ".") (bcast tok2 5))]
	  [tok2 _ (x) (stored) (bindings) (timed-call 500 tok3 x)]
	  [tok3 _ (y) (stored) (bindings)
		(if (not (= y 0))		    		    
		    (begin (display y)
			   (timed-call 1000 tok3 (- y 1))))]
	  )))))

#;
(tokens 
  [soc-start () (display "S")]
  [node-start () (display "N")])

;; Uses global "node-code" binding.
#;(define (alpha-repl)
  (printf "sim> ") (flush-output-port)
  (let ((input (read)))
    (unless (eq? 'exit input)
	    (disp "Got prgoram" input)
	    (let ((cleaned (cleanup-token-machine input)))
	      (disp "got cleaned:")(pp cleaned)
	      (alpha-it cleaned)
	      (start-alpha-sim node-code 10.0 'simple)
	      (alpha-repl)))))

(define (alpha-it tm)
  (let ([comped (compile-simulate-alpha tm)])
  ;; Bind the current program to a global variable:
    (eval `(define alph ',comped))
    (eval comped)))






;     (begin (t) (time (start-alpha-sim 10.0)))
