 
;; These are used by code generated by compile-simulate-alpha.

;; Gets set by .... Something?  TODO FIX UP:
[define this (make-parameter #f)]

;; Is set to a list of all the leds that are toggled on.    
[define led-toggle-state '()]

;; MAKE SURE NOT TO INCLUDE OURSELVES:
[define (neighbors obj sim)
  (let ((entry (assq obj (simulation-object-graph sim))))
    (if (null? entry)
        (error 'neighbors "generated code.. .cannot find obj in graph: ~s ~n ~s"
               obj (simulation-object-graph sim))
        (begin 
          (if (memq obj (cdr entry))
              (error 'neighbors "we're in our own neighbors list"))
          (cdr entry))))]

[define sendmsg (lambda (data ob)
                  (set-simobject-incoming! ob
                                           (cons data (simobject-incoming ob)))
                  ;(set-simobject-redraw! ob #t)
                  )]


[define (sim-light-up r g b)
  ((sim-debug-logger) "~n~a: light-up ~a ~a ~a"
                      (node-id (simobject-node this)) r g b)
  (if (simobject-gobj this)
      (change-color! (simobject-gobj this) (rgb r g b))
      ;; We're allowing light-up of undrawn objects atm:
      ;(error 'sim-light-up "can't change color on undrawn object!: ~s" this)
      )]

;; INCOMPLETE (we don't yet draw the leds directly.)
[define (sim-leds what which)
  (let* ([colors 
          (case which
            [(red)   '(255 0 0)]
            [(green) '(0 255 0)]
            [(blue)  '(0 0 255)]
            [else (error 'sim-leds "bad color: ~a" which)])]
         ;; INCOMPLETE:
         ;	     [oldcolors '(0 0 0)]
         )
    (let ((string (format "~a: (time ~s) (Leds: ~a ~a ~a)~n" 	
                          (node-id (simobject-node this)) (cpu-time) which what
                          (case what
                            [(on) 
                             (set! led-toggle-state (list->set (cons which led-toggle-state)))
                             (apply sim-light-up colors)
                             "" ]
                            [(off)
                             (set! led-toggle-state (remq which led-toggle-state))
                             (sim-light-up '(0 0 0))
                             "" ]
                            [(toggle)
                             (if (memq which led-toggle-state)
                                 (begin 
                                   (set! led-toggle-state (remq which led-toggle-state))
                                   (sim-light-up 0 0 0)
                                   "off")
                                 (begin 
                                   (set! led-toggle-state (list->set (cons which led-toggle-state)))
                                   (apply sim-light-up colors)
                                   "on")
                                 )]
                            [else (error 'sim-leds "bad action: ~a" what)]))))
      ;((sim-debug-logger) string)
      (logger string)
      ))]

[define (sim-dist . tok)
  (if (null? tok)
      (begin 
        (if (msg-object-count this-message)
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist) is broken!")))
      (let ((entry (hashtab-get (simobject-token-cache this) (car tok))))
        (if (and entry (msg-object-count entry))
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist ~s) but ~s has not been received!"
                   (car tok) (car tok))
            )))]

[define (sim-loc) ;; Return this nodes location.
  (node-pos (simobject-node this))]

[define (sim-locdiff a b)
  (sqrt (+ (expt (- (car a) (car b)) 2)
           (expt (- (cadr a) (cadr b)) 2)))]

