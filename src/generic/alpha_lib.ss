 
;; These are used by code generated by compile-simulate-alpha.

;; ======================================================================
;; Simulator runtime

;; This returns a meta-token-handler of type (msg-object, vtime -> ())
(define (meta-handler this)
  (define-structure (tokstore x))
  "This is the simulation seed."
  "It returns an initial set of scheduled actions for the simulator to execute."
  (let ((local-sense
          (lambda ()
            ((current-sense-function) (node-pos (simobject-node this))))))
    (let* ()
      (letrec ((soc-start
                 (lambda (current-vtime subtok-index . args)
                   (let* ((the-store (simobject-token-store this))
                          (this-tokname (cons 'soc-start subtok-index))
                          (old-outgoing (simobject-outgoing-msg-buf this))
                          (old-local (simobject-local-msg-buf this)))
                     "Is there already an allocated token object?:"
                     (let ((tokobj (hashtab-get the-store this-tokname)))
                       (if (not tokobj)
                         (begin
                           "If not, then we allocate that token object..."
                           " setting the invoke counter to zero."
                           (set! tokobj (vector 0))
                           (hashtab-set! the-store this-tokname tokobj)))
                       (set-simobject-outgoing-msg-buf! this '())
                       (set-simobject-local-msg-buf! this '())
                       (set-simobject-local-msg-buf!
                         this
                         (cons
                          (bare-msg-object tok1 (list))
                          (simobject-local-msg-buf this)))
                       (set-simobject-outgoing-msg-buf!
                         this
                         (append
                           (reverse (simobject-outgoing-msg-buf this))
                           old-outgoing))
                       (set-simobject-local-msg-buf!
                         this
                         (append
                           (reverse (simobject-local-msg-buf this))
                           old-local))
                       (void)))))
               (tok1
                (lambda (current-vtime subtok-index . args)
                  (let* ((the-store (simobject-token-store this))
                         (this-tokname (cons 'tok1 subtok-index))
                         (old-outgoing (simobject-outgoing-msg-buf this))
                         (old-local (simobject-local-msg-buf this)))
                    "Is there already an allocated token object?:"
                    (let ((tokobj (hashtab-get the-store this-tokname)))
                      (if (not tokobj)
                        (begin
                          "If not, then we allocate that token object..."
                          " setting the invoke counter to zero."
                          (set! tokobj (vector 0))
                          (hashtab-set! the-store this-tokname tokobj)))
                      (set-simobject-outgoing-msg-buf! this '())
                      (set-simobject-local-msg-buf! this '())
                      (set-simobject-outgoing-buf!
                        this
                        (cons
                         (bare-msg-object tok2 (list '3))
                         (simobject-local-msg-buf this)))
                      (set-simobject-outgoing-msg-buf!
                        this
                        (append
                          (reverse (simobject-outgoing-msg-buf this))
                          old-outgoing))
                      (set-simobject-local-msg-buf!
                        this
                        (append
                          (reverse (simobject-local-msg-buf this))
                          old-local))
                      (void)))))
               (tok2
                (lambda (current-vtime subtok-index . args)
                  (let* ((the-store (simobject-token-store this))
                         (this-tokname (cons 'tok2 subtok-index))
                         (old-outgoing (simobject-outgoing-msg-buf this))
                         (old-local (simobject-local-msg-buf this)))
                    "Is there already an allocated token object?:"
                    (let ((tokobj (hashtab-get the-store this-tokname)))
                      (if (not tokobj)
                        (begin
                          "If not, then we allocate that token object..."
                          " setting the invoke counter to zero."
                          (set! tokobj (vector 0 '99))
                          (hashtab-set! the-store this-tokname tokobj)))
                      (set-simobject-outgoing-msg-buf! this '())
                      (set-simobject-local-msg-buf! this '())
                      (begin
                        (vector-set! tokobj 1 (+ (vector-ref tokobj 1) '1))
                        (set-simobject-outgoing-buf!
                          this
                          (cons
                           (bare-msg-object tok2 (list (vector-ref tokobj 1)))
                           (simobject-local-msg-buf this))))
                      (set-simobject-outgoing-msg-buf!
                        this
                        (append
                          (reverse (simobject-outgoing-msg-buf this))
                          old-outgoing))
                      (set-simobject-local-msg-buf!
                        this
                        (append
                          (reverse (simobject-local-msg-buf this))
                          old-local))
                      (void))))))
        (let ((dyndispatch_table (make-default-hash-table)))
          (begin
            (hashtab-set 'soc-start soc-start)
            (hashtab-set 'tok1 tok1)
            (hashtab-set 'tok2 tok2))
          (lambda (msgob current-vtime)
            (mvlet
             (((name subtok)
               (let ((tok (msg-object-token msgob)))
                 (if (pair? tok) (values (car tok) (cdr tok)) (values tok 0)))))
             (let ((handler (hashtab-get dyndispatch_table name)))
               (apply
                handler
                current-vtime
                subtok
		(msg-object-args msgob))))))))))

;; This builds a simulation object for a specific node in the network.
;; This object drives the simulation for that node.  
;; When the simulation object is invoked once, it processes all
;; incoming and queued messages and returns the next action to be executed.
;; The execution of that atomic action (token handler) produces new messages
;; both in *this* simobject, and in the incoming fields of other simobjects.

;; It returns this simulation object as a thunk.
(define build-node-sim
  (lambda (ob world meta-handler)
    ;; the scheduling queue contains event entries of the format:
    ;;   [<vtime-to-exec>, <msg-object>]
    ;; which are also returned from sim-seed in this format.
    (define (evntcmpr a b) (<= (car a) (car b)))
    
      ;; Schedule either adds an event to the schedule, 
      ;; or returns the current schedule in list form.
    (define private-scheduler
      (let ([buffer '()])
	(case-lambda 
	 [() buffer]
	 [evnts (set! buffer (merge evntcmpr evnts buffer))])))
    
    (define (process-incoming current-vtime)
      (define schedule (simobject-scheduler ob))
      ;; Process incoming and local msgs:
      ;; Schedule timed local tokens:
      (apply schedule (simobject-timed-token-buf ob))
      ;; Schedule locally accumulated messages to happen immediately:
      (apply schedule 
	     (map (lambda (msg) (list current-vtime msg))
		  (simobject-local-msg-buf ob)))
      ;; Schedule incoming; add in radio delay and virtual processing time:
      (apply schedule (simobject-incoming-msg-buf ob)))
  
    (define (launch-outgoing current-vtime)
      ;; This does the radio transmission, and puts msgs in their respective incoming buffers.
      ;; TODO: Here's where we insert the better radio model!!!
      (let ([outgoing (simobject-outgoing-msg-buf ob)])
	;; They're all broadcasts for now
	(for-each 
	 (lambda (nbr)
	   (set-simobject-incoming-msg-buf! 
	    nbr (append 
		 (map (lambda (msg) 
			(list (+ RADIO_DELAY PROCESSING_TIME current-vtime) msg))
		      outgoing)
		 (simobject-incoming-msg-buf nbr))))
	 (graph-neighbors ob (simworld-object-graph world)))
	;; They're all delivered, so we clear our own outgoing buffer.
	(set-simobject-outgoing-msg-buf! ob '())))


    ;; MAIN BODY:
    ;; Install the scheduler and handler incase anybody else wants to use them:
    (set-simobject-scheduler! ob schedule)
    (set-simobject-meta-handler! ob (meta-handler ob))

    (lambda (current-vtime)
      ;; First schedule any incoming messages we've received
      (process-incoming current-vtime)
      (let ((current-schedule (simobject-scheduler ob)))
	(if (null? current-schedule)
	    (error 'build-node-sim
		   "empty schedule for node ~a" (node-id (simobject-node ob))))
	(let ([next (car current-schedule)])
	  (list (car next)
		;; Action thunk that executes message:
		(lambda () 
		  ;; For now, the time actually executed is what's scheduled
		  ((simobject-handler ob) (cadr next) (car next))
		  ;; Now that the atomic action is finished, do the radio transimission:
		  (launch-outgoing current-vtime))))))))


(define run-alpha-sim
;  (lambda (starting-evnts store-factory . stop-time)
  (lambda stop-time
    (let ([stopping-time? (if (null? stop-time)
			      (lambda (t) #f)
			      (lambda (t) (>= t (car stop-time))))])
      (let* ([sim (fresh-simulation)]
	     [soc (car (filter (lambda (n) (eq? BASE_ID (node-id (simobject-node n))))
			       (simworld-all-objs sim)))]
	     [node-sims
	       (map (lambda (ob)
		      (build-node-sim ob
		       sim ;; the world
		       meta-handler ;; TODO: read from file
		       ))
		    (simworld-all-objs sim))])

    (let main-sim-loop ([vtime 0])      
      (let* ([actions (map (lambda (th) (th)) node-sims)]
	     [nexttime (apply min (map car actions))]
	     [nextevt (assq nexttime actions)])
	(disp "Main sim loop" next "out of" actions)
	
	  ;; Run this atomic action (token handler), it gets to run at its intended virtual time.
	  ((cadr next) (car next))
	  ;; That had the effect of scheduling new actions, now we keep going.
	  (main-sim-loop (cons (stream-cdr nextstrm) (alist-remove next streams))))))))))


;; From Swindle:
;;>> (merge less? a b)
;;>   Takes two lists `a' and `b' such that both (sorted? a less?) and
;;>   (sorted? b less?) are true, and returns a new list in which the
;;>   elements of `a' and `b' have been stably interleaved so that (sorted?
;;>   (merge less? a b) less?) is true.  Note: this does not accept vectors.
(define (merge less? a b)
  (cond [(null? a) b]
        [(null? b) a]
        [else (let loop ([x (car a)] [a (cdr a)] [y (car b)] [b (cdr b)])
                ;; The loop handles the merging of non-empty lists.  It has
                ;; been written this way to save testing and car/cdring.
                (if (less? y x)
                  (if (null? b)
                    (cons y (cons x a))
                    (cons y (loop x a (car b) (cdr b))))
                  ;; x <= y
                  (if (null? a)
                    (cons x (cons y b))
                    (cons x (loop (car a) (cdr a) y b)))))]))


;; ======================================================================
;; Gets set by .... Something?  TODO FIX UP:
;; All node level utilities below depend on this parameter being set properly.
[define this (make-parameter #f)]

;; ======================================================================
;; Node level utilities 

;; Is set to a list of all the leds that are toggled on.    
[define led-toggle-state '()]

;; MAKE SURE NOT TO INCLUDE OURSELVES:
[define (neighbors obj sim)
  (let ((entry (assq obj (simworld-object-graph sim))))
    (if (null? entry)
        (error 'neighbors "generated code.. .cannot find obj in graph: ~s ~n ~s"
               obj (simworld-object-graph sim))
        (begin 
          (if (memq obj (cdr entry))
              (error 'neighbors "we're in our own neighbors list"))
          (cdr entry))))]

[define sendmsg (lambda (data ob)
                  (set-simobject-incoming! ob
                                           (cons data (simobject-incoming ob)))
                  ;(set-simobject-redraw! ob #t)
                  )]


[define (sim-light-up r g b)
  ((sim-debug-logger) "~n~a: light-up ~a ~a ~a"
                      (node-id (simobject-node this)) r g b)
  (if (simobject-gobj this)
      (change-color! (simobject-gobj this) (rgb r g b))
      ;; We're allowing light-up of undrawn objects atm:
      ;(error 'sim-light-up "can't change color on undrawn object!: ~s" this)
      )]

;; INCOMPLETE (we don't yet draw the leds directly.)
[define (sim-leds what which)
  (let* ([colors 
          (case which
            [(red)   '(255 0 0)]
            [(green) '(0 255 0)]
            [(blue)  '(0 0 255)]
            [else (error 'sim-leds "bad color: ~a" which)])]
         ;; INCOMPLETE:
         ;	     [oldcolors '(0 0 0)]
         )
    (let ((string (format "~a: (time ~s) (Leds: ~a ~a ~a)~n" 	
                          (node-id (simobject-node this)) (cpu-time) which what
                          (case what
                            [(on) 
                             (set! led-toggle-state (list->set (cons which led-toggle-state)))
                             (apply sim-light-up colors)
                             "" ]
                            [(off)
                             (set! led-toggle-state (remq which led-toggle-state))
                             (sim-light-up '(0 0 0))
                             "" ]
                            [(toggle)
                             (if (memq which led-toggle-state)
                                 (begin 
                                   (set! led-toggle-state (remq which led-toggle-state))
                                   (sim-light-up 0 0 0)
                                   "off")
                                 (begin 
                                   (set! led-toggle-state (list->set (cons which led-toggle-state)))
                                   (apply sim-light-up colors)
                                   "on")
                                 )]
                            [else (error 'sim-leds "bad action: ~a" what)]))))
      ;((sim-debug-logger) string)
      (logger string)
      ))]

'[define (sim-dist . tok)
  (if (null? tok)
      (begin 
        (if (msg-object-count this-message)
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist) is broken!")))
      (let ((entry (hashtab-get (simobject-token-cache this) (car tok))))
        (if (and entry (msg-object-count entry))
            (msg-object-count this-message)
            (error 'simulator_nought.process-statement:dist
                   "inside simulator (dist ~s) but ~s has not been received!"
                   (car tok) (car tok))
            )))]

[define (sim-loc) ;; Return this nodes location.
  (node-pos (simobject-node this))]

[define (sim-locdiff a b)
  (sqrt (+ (expt (- (car a) (car b)) 2)
           (expt (- (cadr a) (cadr b)) 2)))]

