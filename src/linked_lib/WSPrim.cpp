

// Global setting:
bool WSOUTPUT_PREFIX = TRUE;

// This is a lame work-around:
static char global_show_buffer[500];
static ostringstream global_show_stream(ostringstream::out);


// LISTS: 
//==============================================================================
// We can't define list functions inside the WSPrim class because of template magic

template<typename T>
bool IS_NULL(boost::shared_ptr< cons<T> > p) 
{ 
  return ((cons<T>*)0 == p.get());
}

template <class T>
cons<T>::cons(T a, boost::shared_ptr< cons<T> > b)
{
    car = a;
    cdr = b;
}



// SIGSEGS:
//==============================================================================
//

/*
 * FIXME: this is a slightly nasty hack to give us direct access to
 *        to subseg() function defined in WaveScope's Signal.h, which
 *        is a friend to SigSeg, and necessary for WSPrim::subseg().
 *        the problem here is that the name subseg is used for both
 *        functions.
 */
template <class T> inline
SigSeg<T> SigSeg_subseg(const SigSeg<T> &x, uint32_t offset, uint32_t length)
{
   return subseg(x, offset, length);
}

template <class T>
uint32_t getTotalByteSize(const SigSeg<T> &e)
{
   return e.getTotalByteSize();
}


//============================================================
// This defines the WaveScript primitives that the code generated by
// the WaveScript compiler depends upon.
 class WSPrim {

   public:   
   
   inline static wsfloat_t CNorm(wscomplex_t c) {
      wsfloat_t re =  __real__ (c);
      wsfloat_t im =  __imag__ (c);

     return sqrt ((re*re) + (im*im));
     /*
     if     (0.0 == re)  return im;
     else if (0.0 == im) return re;
     else {
       wsfloat_t absre = abs(re);
       wsfloat_t absim = abs(im);
       if (absre >= absim ) return (absre * sqrt(1.0 + (im*im / (re*re))));
       else                 return (absim * sqrt(1.0 + (im*im / (re*re))));
     }
     */
   }

    // FIXME: changed with assumption that wsfloat_t is class FLOAT;
    //        should overload operators for FLOAT instead
   inline static wscomplex_t csqrt(wscomplex_t c) {
     wsfloat_t sqrt2 = 1.4142135623730951;
     wsfloat_t a =  __real__ (c);
     wsfloat_t b =  __imag__ (c);
     wsfloat_t norm = CNorm(c);          
     wsfloat_t p = sqrt(norm + a) / sqrt2;
     wsfloat_t q = sqrt(norm - a) / sqrt2;
     if (b < 0) q *= -1;
     return p + (q * 1.0fi);
   }
  
   // This is a work-around to the fact that we can't have stmt blocks
   // {...} in expression position.
   inline static string show_helper(int ignored) {
     return string(global_show_buffer);
   }
   // This is a work-around to the fact that we can't have stmt blocks
   // {...} in expression position.
   inline static string show_helper2(void* ignored) {
     string result = global_show_stream.str();
     global_show_stream.str(string(""));
     return string(result);
   }
   static wsstring_t stringappend(const wsstring_t& A, const wsstring_t& B) {
     return A + B;
   }
   static wsstring_t Stringimplode(boost::shared_ptr< cons<wschar_t> > ls) {
     // TEMP, capping the length of this string at 100 for the moment:
     char buf[100];
     boost::shared_ptr< cons<wschar_t> > ptr = ls;
     int i = 0;
     while (!IS_NULL(ptr) && i<100) {
       buf[i] = ptr->car;
       ptr = ptr->cdr;
       i++;
     }
     return string(buf);
   }

   inline static wsbool_t wsnot(wsbool_t b) {
     return (wsbool_t)!b;
   }

   // SigSegs:
    /*
   static wsint_t width(const RawSeg& w) {
     return (wsint_t)w.length();
   }
   static wsint_t start(const RawSeg& w) {
     return (wsint_t)w.start();
   }
   static wsint_t end(const RawSeg& w) {
     return (wsint_t)w.end();
   }
    */

   template <class T>
   static wsint_t width(const SigSeg<T>& w) {
      return (wsint_t)w.length();
   }
   template <class T>
   static wsint_t start(const SigSeg<T>& w) {
      return (wsint_t)w.start();
   }
   template <class T>
   static wsint_t end(const SigSeg<T>& w) {
      return (wsint_t)w.end();
   }



   // Old Array representation.
   /*
   template <class T>
   static RawSeg toSigseg(const boost::shared_ptr< vector< T > >& arr, 
			  wsint_t startsamp, int timebase) {
     int len = (*arr).size();
     RawSeg rs((SeqNo)startsamp,len, DataSeg,0,sizeof(T),Unitless,true);     
     Byte* direct;
     rs.getDirect(0, len, direct);
     for(int i=0; i<len; i++) ((T*)direct)[i] = (*arr)[i];
     rs.releaseAll();
     return rs;
   }
   */

    /*
   static RawSeg joinsegs(const RawSeg& a, const RawSeg& b) {
     return RawSeg::append(a,b);
   }
    */

   template <class T>
   static SigSeg<T> joinsegs(const SigSeg<T>& a, const SigSeg<T>& b) {
      return append(a, b);
   }

   // Currently takes start sample number (inclusive) and length.
   // TODO: Need to take SeqNo for start!
   /*
   static RawSeg subseg(const RawSeg& ss, wsint_t start, wsint_t len) {
     uint32_t offset = (uint32_t)((SeqNo)start - ss.start());
     //return ss.subseg(offset, offset+len);
     return RawSeg::subseg(ss, offset, len); // INCONSISTENT DOCUMENTATION! FIXME!
   }
   */
   template <class T>
   static SigSeg<T> subseg(const SigSeg<T> &ss, wsint_t start, wsint_t len)
   {
     uint32_t offset = (uint32_t)((SeqNo)start - ss.start());
    return SigSeg_subseg(ss, offset, len); // INCONSISTENT DOCUMENTATION! FIXME!
   }


      
   // Simple hash function, treat everything as a block of bits.
   static size_t generic_hash(unsigned char* ptr, int size) {
     size_t hash = 5381;
     int c;
     for(int i=0; i<size; i++) 
       hash = ((hash << 5) + hash) + ptr[i]; /* hash * 33 + c */	 	 
     return hash;
   }   
   
   static void wserror(wsstring_t str) {
     printf("wserror: %s\n", str.c_str());
     
     exit(1);
   }

//    template <class T>
//    static boost::shared_ptr<vector< boost::shared_ptr< vector<T> > > >
//        m_invert(boost::shared_ptr<vector< boost::shared_ptr< vector<T> > > > mat)
//    {
//      return mat;
//    }


   // Optimized version, unfinished.
   /*
   static unsigned long hash(unsigned char* ptr, int size) {
     int stride = sizeof(unsigned long);
     unsigned long hash = 5381;
     unsigned long* chunked = (unsigned long*)ptr;
     int rem = size % stride;
     for (int i=0; i < size/stride; i++) {
       hash = ((hash << 5) + hash) + chunked[i];
     }
     for (int i=0; i < rem; i++) {
       //FINISH
     }
     return hash;
   }
   */

};


// ARRAYS: 
//==============================================================================


// FIXME: may not work for arrays of arrays (or other variable-sized things)
template <class T>
uint32_t getTotalByteSize(const boost::intrusive_ptr< WSArrayStruct<T> > &e)
{
  // FIXME: does this work for arrays of arrays?
  return sizeof(int)*2 + e->len;
}


// LISTS: 
//==============================================================================
// We can't define list functions inside the WSPrim class because of template magic

// Recursive for now... should change.
template <class T>
bool wsequal(const boost::shared_ptr< cons<T> > & x, 
             const boost::shared_ptr< cons<T> > & y) 
{
  //printf("EQUALITY: \n");
  //printf("   %d %d \n", (x==null_ls), (y==null_ls));
   if (IS_NULL(x)) {
     if (IS_NULL(y))
       return TRUE;
     else return FALSE;
   } else if (IS_NULL(y))
     return FALSE;
   else 
     if (wsequal(x->car, y->car))
       return wsequal(x->cdr, y->cdr);
     else return FALSE;
}


uint32_t getTotalByteSize(const wsint16_t &e)   { return sizeof(e); }
uint32_t getTotalByteSize(const wsuint16_t &e)  { return sizeof(e); }
uint32_t getTotalByteSize(const wsint64_t &e)   { return sizeof(e); }
uint32_t getTotalByteSize(const wsint_t &e)     { return sizeof(e); }
uint32_t getTotalByteSize(const wsfloat_t &e)   { return sizeof(e); }
uint32_t getTotalByteSize(const wsdouble_t &e)  { return sizeof(e); }
uint32_t getTotalByteSize(const wsbool_t &e)    { return sizeof(e); }
uint32_t getTotalByteSize(const wsstring_t &e)  { return sizeof(e); } // FIXME: incorrect
uint32_t getTotalByteSize(const wschar_t &e)    { return sizeof(e); }
uint32_t getTotalByteSize(const wscomplex_t &e) { return sizeof(e); }


// FIXME: should verify that this is right, particularly if lists
//        are just spliced into queues
template <class T>
uint32_t getTotalByteSize(const boost::shared_ptr< cons<T> > &e)
{
   boost::shared_ptr< cons<T> > p;
   uint32_t sz;

   
   for (sz=0, p=e; !IS_NULL(p); p = p->cdr)
   {
      sz += sizeof(*p) + getTotalByteSize(p->car);
   }

   return sz;
}


// Currently unused:
template <class T>
ostream& operator<< (ostream& output, const boost::shared_ptr< cons<T> > & ls) 
{
  boost::shared_ptr< cons<T> > ptr = ls;
  output << "[";
  while(! IS_NULL(ptr)) {
    // Problem here is that we need to cast RawSeg to SigSeg and can't:
    //output << (RawSeg)(ptr->car);
    //output << (wsint_t)3;
    output << ptr->car;
    output << ", ";
    ptr = ptr->cdr;
  }
  output << "]";
  return output;
}

// Not tail recursive!
template <class T>
//cons<T>::ptr cons<T>::append(const cons<T>::ptr & x, const cons<T>::ptr & y) {
boost::shared_ptr< cons<T> > cons<T>::append(
       const boost::shared_ptr< cons<T> > & x, 
       const boost::shared_ptr< cons<T> > & y) 
{
  if (IS_NULL(x))   return y;
  else return ptr(new cons<T>(x->car, append(x->cdr, y)));
}


template <class T>
boost::shared_ptr< cons<T> > cons<T>::reverse(
       const boost::shared_ptr< cons<T> > & ls)
{
  boost::shared_ptr< cons<T> > ptr = ls;
  boost::shared_ptr< cons<T> > acc( (cons<T>*) 0);
  while (!IS_NULL(ptr)) {
    acc = boost::shared_ptr< cons<T> >(new cons<T>(ptr->car, acc));
    ptr = ptr->cdr;
  }
  return acc;
}

template <class T>
T cons<T>::ref(const boost::shared_ptr< cons<T> > & ls,
               wsint_t ind)
{  
  boost::shared_ptr< cons<T> > ptr = ls;
  for(int i=0; i<ind; i++) {       
    if (IS_NULL(ptr)) WSPrim::wserror(string("listRef: not enough elements"));
    ptr = ptr->cdr;
  }
  if (IS_NULL(ptr)) WSPrim::wserror(string("listRef: not enough elements"));
  return ptr->car;
}

template <class T>
wsint_t cons<T>::length(const boost::shared_ptr< cons<T> > & ls)
{  
  boost::shared_ptr< cons<T> > ptr = ls;
  int count = 0;
  while (!(IS_NULL(ptr))) { 
    ptr = ptr->cdr;
    count++; 
  }
  return (wsint_t)count;
}

template <class T>
boost::shared_ptr< cons<T> > cons<T>::make(wsint_t n, T init)
{
  int count = n;
  // Start out null.
  boost::shared_ptr< cons<T> > p((cons<T>*)0);
  while (count > 0) {
    p = boost::shared_ptr< cons<T> >(new cons<T>(init, p));
    count--;
  }  
  return p;
}





//==============================================================================
// These are built-in WSBoxes. 
// Most of these are intended to go away at some point.
class WSBuiltins {
   
public:

   /* Zip2 operator: takes 2 input streams of types T1 and T2 and emits zipped
      tuples, each containing exactly one element from each input stream. */
   template <class T1, class T2> class Zip2: public WSBox {
   public:
     Zip2< T1, T2 >() : WSBox("zip2") {}
  
     /* Zip2 output type */
     struct Output
     {
       T1 _first;
       T2 _second;
    
       Output(T1 first, T2 second) : _first(first), _second(second) {}
       friend ostream& operator << (ostream& o, const Output& output) { 
	 cout << "< " << output._first << ", " << output._second << " >"; return o; 
       }
     };

   private:
     DEFINE_OUTPUT_TYPE(Output);
  
     bool iterate(uint32_t port, void *item)
     {
       m_inputs[port]->requeue(item);

       bool _e1, _e2; /* indicates if elements available on input streams */
       _e1 = (m_inputs[0]->peek() != NULL); _e2 = (m_inputs[1]->peek() != NULL);
    
       while(_e1 && _e2) {
	 T1* _t1 = (T1*)(m_inputs[0]->dequeue()); 
	 T2* _t2 = (T2*)(m_inputs[1]->dequeue()); 
	 emit(Output(*_t1, *_t2)); /* emit zipped tuple */
	 delete _t1; delete _t2;
	 _e1 = (m_inputs[0]->peek() != NULL); _e2 = (m_inputs[1]->peek() != NULL);
       }
       return true;
     }
   };


  /* This takes Signal(T) to Signal(SigSeg(T)) */
   /*
  class Window : public WSBox{    
   
    public:
    Window(int winsize, size_t bitsize) : WSBox("Window"),
      //rs(new RawSeg(RawSignalPtr(new RawSignal(0)),(SeqNo)0,winsize))
      rs(new RawSeg((SeqNo)0,winsize,DataSeg,0,bitsize,Unitless,true))      
      //RawSeg(const RawSignalPtr parent, SeqNo start, uint32_t length, GapType isGap = DataSeg);
    {      
      window_size = winsize;
      elem_size = bitsize;
      ind = 0;      
      sampnum = 0;      
      assert(rs->getDirect(0,winsize,current_buf));
    }

    private:
    WS_DEFINE_OUTPUT_TYPE_EX(RawSeg);
    
    int window_size;
    size_t elem_size;

    SeqNo sampnum;
    RawSeg* rs;
    Byte* current_buf;
    int ind;
        
    bool iterate(uint32_t port, void *item)
    {
      memcpy((current_buf + (ind*elem_size)),
	     item,
	     elem_size);
      ind++;
      sampnum++;
      if (ind == window_size) {
	rs->release(current_buf);
	emit(*rs);
	ind = 0;
	rs = new RawSeg(sampnum,window_size,DataSeg,0,elem_size,Unitless,true);
	//rs = new RawSeg(RawSignalPtr(new RawSignal(0)), sampnum, window_size);
	assert(rs->getDirect(0,window_size,current_buf));
      }
      return true;
    }
  };
   */


   /* This takes Signal(T) to Signal(SigSeg(T)) */
   template <class T>
   class Window : public WSBox
   {
   public:
      Window(int winsize)
         : WSBox("Window"),
           ss(new SigSeg<T>(Unitless, (SeqNo)0, winsize, DataSeg)),
           window_size(winsize),
           elem_size(sizeof(T)),
           ind(0),
           sampnum(0)
      {
         current_buf = ss.getDirect(0, window_size);
         // assert(_rawseg.getDirect(0, length(), resbuf)) is done in SigSeg<T>::getDirect()
      }

   private:
      DEFINE_OUTPUT_TYPE(SigSeg<T>);
      
      int window_size;
      size_t elem_size;

      SeqNo sampnum;
      SigSeg<T> *ss;
      T *current_buf;
      int ind;

      bool iterate(uint32_t port, void *item)
      {
         memcpy((Byte*)(current_buf + ind),
                item,
                elem_size);
         ind++;
         sampnum++;
         if (ind == window_size) {
            ss->release(current_buf);
            emit(*ss);
            ind = 0;
            ss = new SigSeg<T>(Unitless, sampnum, window_size, DataSeg);
            current_buf = ss->getDirect(0, window_size);
         }

         return true;
      }
   };


  /* This takes Signal(T) to Signal(SigSeg(T)) */
  class Timer : public WSSource{
   
    public:
     Timer(wsfloat_t freq) :
        WSSource("Timer"),
        period((int)(1000000.0 * (1.0 / freq)))
     {
       Launch();
     }

     DEFINE_SOURCE_TYPE(bool);

     private:
     int period; 

    void *run_thread()
    {
      while (!Shutdown())
      {
        source_emit(0);
        usleep(period);
      }
      return NULL;
    }
  };
  
};


typedef wsbool_t        wsunit_t;
