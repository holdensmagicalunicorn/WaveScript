


// This defines the WaveScript primitives that the code generated by
// the WaveScript compiler depends upon.
 class WSPrim {

   public:
   

  // TODO, replace with FFTW:
//   static SigSeg<complex> fft(SigSeg<float> input) {
//       /* Currently we just use the unitless timebase: */ 
//       Timebase _freq = Unitless;
//       SigSeg<float>* casted = &input;
      
//       /* alloc buffer for FFT */
//       Signal<complex> s = Signal<complex>(_freq);
//       //complex *fft_buf = s.getBuffer(casted->length()/2);
//       complex *fft_buf = s.getBuffer(casted->length());
//       float *fft_flt = (float *)fft_buf;

//       /* copy input over to output buffer */
//       float *cbuf = casted->getDirect();
//       memmove(fft_flt, cbuf, sizeof(float)*casted->length());
//       casted->release(cbuf);
      
//       /* do the fft */
//       FFT::realft(fft_flt-1, casted->length(), +1);

//       /* return the sigseg */
//       SigSeg<complex> output = s.commit(casted->length()/2);
//       delete casted;
//       return(output);
//   }


//    //  We should keep a hash table of common plans.
//    static SigSeg<complex> fft(SigSeg<double> input) {
     
//      // Heap allocate a struct.
//      int len = input.length();

//      double *in_buf = input.getDirect();

//      Timebase _freq = Unitless;
//      Signal<complex> output = Signal<complex>(_freq);
//      complex *out_buf = output.getBuffer(len);

//      plan_t p;
//      p.vec_len = len;
//      p.vec = out_buf;
//      p.plan = fftw_plan_dft_1d(N, in_buf, out_buf, FFTW_FORWARD, FFTW_ESTIMATE);
     

//   clock_t start, end;
//   plan_t* p = (plan_t*) plan;

//   /*printf("Executing!! len %i  incoming len %i\n", p->vec_len, Svector_length(vec));
//   for (i=0; i<10; i++)
//     printf("  Got element %i %lf\n", i, ((double*)p->vec)[i]);
//   printf("  Got element %i %lf\n", 262000, ((double*)p->vec)[262000]);
//   printf("  Got element %i %lf\n", 524000, ((double*)p->vec)[524000]);*/

//   // TODO: CHECK THAT LENGTH IS RIGHT!
//   if (N != p->vec_len) {
//     printf("Mismatched lengths! %i %i\n", N, p->vec_len);
//     return(Sfixnum((uptr)p->vec_len));
//   }


//   for(i=0; i<len; i+=2) {
//     ((double*)p->vec)[i]   = Sflonum_value(Svector_ref(vec, i));
//     ((double*)p->vec)[i+1] = Sflonum_value(Svector_ref(vec, i+1));
//   }

//   fftw_execute(p->plan); 
  



//   plan_t* p = (plan_t*)ptr;
//   fftw_destroy_plan(p->plan);
//   fftw_free(p->vec);
//   p->vec_len = 0;
//   p->vec = 0;
//   p->plan = 0;
//   printf(".");     
//    }


   inline static wsbool_t wsnot(wsbool_t b) {
     return (wsbool_t)!b;
   }

   static wsint_t width(const RawSeg& w) {
     return (wsint_t)w.length();
   }
   static wsint_t start(const RawSeg& w) {
     return (wsint_t)w.start();
   }
   static wsint_t end(const RawSeg& w) {
     return (wsint_t)w.end();
   }

   static RawSeg joinsegs(const RawSeg& a, const RawSeg& b) {
     return RawSeg::append(a,b);
   }
   // Currently takes start sample number (inclusive) and length.
   // TODO: Need to take SeqNo for start!
   static RawSeg subseg(const RawSeg& ss, wsint_t start, wsint_t len) {
     uint32_t offset = (uint32_t)((SeqNo)start - ss.start());
     //return ss.subseg(offset, offset+len);
     return RawSeg::subseg(ss, offset, len); // INCONSISTENT DOCUMENTATION! FIXME!
   }
      
   static wsstring_t stringappend(const wsstring_t& A, const wsstring_t& B) {
     return A+B;
   }

   // Simple hash function, treat everything as a block of bits.
   static size_t generic_hash(unsigned char* ptr, int size) {
     size_t hash = 5381;
     int c;
     for(int i=0; i<size; i++) 
       hash = ((hash << 5) + hash) + ptr[i]; /* hash * 33 + c */	 	 
     return hash;
   }   
   
   // Optimized version, unfinished.
   /*
   static unsigned long hash(unsigned char* ptr, int size) {
     int stride = sizeof(unsigned long);
     unsigned long hash = 5381;
     unsigned long* chunked = (unsigned long*)ptr;
     int rem = size % stride;
     for (int i=0; i < size/stride; i++) {
       hash = ((hash << 5) + hash) + chunked[i];
     }
     for (int i=0; i < rem; i++) {
       //FINISH
     }
     return hash;
   }
   */

};



// These are built-in WSBoxes. 
// Most of these are intended to go away at some point.
class WSBuiltins {
   
   /* Zip2 operator: takes 2 input streams of types T1 and T2 and emits zipped
      tuples, each containing exactly one element from each input stream. */
   template <class T1, class T2> class Zip2: public WSBox {
   public:
     Zip2< T1, T2 >() : WSBox("zip2") {}
  
     /* Zip2 output type */
     struct Output
     {
       T1 _first;
       T2 _second;
    
       Output(T1 first, T2 second) : _first(first), _second(second) {}
       friend ostream& operator << (ostream& o, const Output& output) { 
	 cout << "< " << output._first << ", " << output._second << " >"; return o; 
       }
     };

   private:
     DEFINE_OUTPUT_TYPE(Output);
  
     bool iterate(uint32_t port, void *item)
     {
       m_inputs[port]->requeue(item);

       bool _e1, _e2; /* indicates if elements available on input streams */
       _e1 = (m_inputs[0]->peek() != NULL); _e2 = (m_inputs[1]->peek() != NULL);
    
       while(_e1 && _e2) {
	 T1* _t1 = (T1*)(m_inputs[0]->dequeue()); 
	 T2* _t2 = (T2*)(m_inputs[1]->dequeue()); 
	 emit(Output(*_t1, *_t2)); /* emit zipped tuple */
	 delete _t1; delete _t2;
	 _e1 = (m_inputs[0]->peek() != NULL); _e2 = (m_inputs[1]->peek() != NULL);
       }
       return true;
     }
   };


};
