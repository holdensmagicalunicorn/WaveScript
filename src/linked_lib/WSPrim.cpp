
// This defines the WaveScript primitives that the code generated by
// the WaveScript compiler depends upon.
 class WSPrim {

   public:
   
//   static SigSeg<complex> fft(SigSeg<float> input) {
//       /* Currently we just use the unitless timebase: */ 
//       Timebase _freq = Unitless;
//       SigSeg<float>* casted = &input;
      
//       /* alloc buffer for FFT */
//       Signal<complex> s = Signal<complex>(_freq);
//       complex *fft_buf = s.getBuffer(casted->length()/2);
//       float *fft_flt = (float *)fft_buf;

//       /* copy input over to output buffer */
//       float *cbuf = casted->getDirect();
//       memmove(fft_flt, cbuf, sizeof(float)*casted->length());
//       casted->release(cbuf);
      
//       /* do the fft */
//       FFT::realft(fft_flt-1, casted->length(), +1);

//       /* return the sigseg */
//       SigSeg<complex> output = s.commit(casted->length()/2);
//       delete casted;
//       return(output);
//   }



   static wsint_t width(const RawSeg& w) {
     return (wsint_t)w.length();
   }
   static wsint_t start(const RawSeg& w) {
     return (wsint_t)w.start();
   }
   static wsint_t end(const RawSeg& w) {
     return (wsint_t)w.end();
   }

   static RawSeg joinsegs(const RawSeg& a, const RawSeg& b) {
     return RawSeg::append(a,b);
   }
   // Currently takes start sample number (inclusive) and length.
   // TODO: Need to take SeqNo for start!
   static RawSeg subseg(const RawSeg& ss, wsint_t start, wsint_t len) {
     uint32_t offset = (uint32_t)((SeqNo)start - ss.start());
     //return ss.subseg(offset, offset+len);
     return RawSeg::subseg(ss, offset, len); // INCONSISTENT DOCUMENTATION! FIXME!
   }
      
   static wsstring_t stringappend(const wsstring_t& A, const wsstring_t& B) {
     return A+B;
   }
};

