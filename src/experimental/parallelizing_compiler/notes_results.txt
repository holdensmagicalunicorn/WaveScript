
;; This is pertinent mainly to threaded_utils.ss, but it was growing to big to leave in there.

;; ================================================================================
;; SUMMARY:
;;
;; Coming back to glance at this a bit [2010.10.30] a little unclear what the bottom line(s) were.

;; First, what are all these files:
;; The main implementation is in threaded_utils.ss

  standalone.ss         -- 
  standalone_pcall.ss   -- 

  pipelined_bottumup.ws -- a little conceptual model of a streaming compiler
  pipelined_compiler.ws -- 

  partest_eightway.sh   -- 
  partest_tree.sh       -- 
  test_standalone.sh    -- 


;; ================================================================================
;;; Little tests:

;; ------------------------------------------------------------
;; Embarassingly Parallel:

;; This type of test can get 7.18X speedup on 8-way valor (work-stealing).
#;
(let ()
  (define count (* 100 1000 1000))
  ;(define count (* 500 ))
  ;; Decrement a counter in two threads vs. one.
  (define (l1 x) (unless (zero? x) (l1 (sub1 x))))
  ;(define (l2 x) (unless (zero? x) (l2 (sub1 x))))
  ;(time (rep 10000 (par (l1 10000) (l2 10000))))

  (par-reset!)
  (time (parmv (l1 count) (l1 count)))
  ;(time (par (l1 count) (l1 count)(l1 count)(l1 count)(l1 count)(l1 count)(l1 count)(l1 count)))
  ;(time (list (l1 count) (l2 count)))
  (par-status)
  )

;; This won't work because of shared code:
;; WAIT it works!
#;
(let ()
  (define (l1 x) (unless (zero? x) (l1 (sub1 x))))
  ;(time (rep 10000 (par (l1 10000) (l2 10000))))
  (time (par (l1 10000000) (l1 10000000)))
  (time (list (l1 10000000) (l1 10000000)))
  )


;; ------------------------------------------------------------
;; "parallel fib" style test:

#;
(let ()
  ;; Make a million threads:
  (define (tree n)
    (if (zero? n) 1
	(apply + (par (tree (sub1 n)) (tree (sub1 n))))))
  (par-reset!)
  (printf "\n~s\n\n" (time (tree 20)))
  (par-status))

#;
(let ()
  ;; Make a million threads:
  (define (tree n)
    (if (zero? n) 1
	(call-with-values (lambda () (parmv (tree (sub1 n)) (tree (sub1 n)))) +)))
  (par-reset!)
  (printf "\n~s\n\n" (time (tree 23)))
  (par-status))


;; [2007.09.18] Hmm, on this one it displays the "taking turns" behavior (work sharing)
;; [2007.09.18] With work-stealing this gets a MEAGER 1.6X speedup on 8-way valor!!
;;  7684ms 8-way (3611 collecting) vs. 12228ms (2370 collecting)
;; Clearly our implementation of the "parallel stack" isn't that good.
;;
;; [2007.09.20] By the way, non-par mode (2^22) on justice gives: 459ms cpu (80ms gc)
;;   par-mode 1-thread gives: 10s cpu, 2.1s gc
;; This is a factor of 20... wait is Chez optimizing away the list creation?  
;; Sadly no... it is 200ms with no list creation. (changing to fixnum doesn't improve!)
;;
;; [2007.09.21] Doing everything in opt-level 3, still get only a 10X par overhead.
;;  (Was afraid that would be much worse.)
;; For parallel speedup, only getting 52% speedup on 8-processor valor!!
;; (It gets a 42% speedup with just two threads.)

#|
;; [2007.09.21] Now working on this parallel speedup issue:
;; Valor results for 1-8 threads, Tree test: 2^23
    4967 ms elapsed real time, including 1301 ms collecting
    3550 ms elapsed real time, including 1367 ms collecting
    3638 ms elapsed real time, including 1440 ms collecting
    3192 ms elapsed real time, including 1479 ms collecting
    3210 ms elapsed real time, including 1481 ms collecting
    3197 ms elapsed real time, including 1537 ms collecting
    3248 ms elapsed real time, including 1504 ms collecting
    3396 ms elapsed real time, including 1447 ms collecting
;; Again, for memory alloc:
    1006856992 bytes allocated, including 1010763328 bytes reclaimed
    1011154424 bytes allocated, including 1014860008 bytes reclaimed
    1012952928 bytes allocated, including 1017063744 bytes reclaimed
    1018558520 bytes allocated, including 1022404432 bytes reclaimed
    1018210016 bytes allocated, including 1021627432 bytes reclaimed
    1020242232 bytes allocated, including 1023440936 bytes reclaimed
    1020832072 bytes allocated, including 1025132040 bytes reclaimed
    1023607520 bytes allocated, including 1027770504 bytes reclaimed

;; And on justice:
    4314 ms elapsed real time, including 1215 ms collecting  3099 nongc
    2934 ms elapsed real time, including 1247 ms collecting  1687
    2918 ms elapsed real time, including 1315 ms collecting  1603
    3190 ms elapsed real time, including 1305 ms collecting  1885
    3345 ms elapsed real time, including 1299 ms collecting  2046
    3360 ms elapsed real time, including 1329 ms collecting  2031
    3387 ms elapsed real time, including 1365 ms collecting  2022
    3455 ms elapsed real time, including 1379 ms collecting  2076

;; For simple eight-way loops.
    4525 ms elapsed real time
    3917 ms elapsed real time
    3505 ms elapsed real time
    2807 ms elapsed real time
    2239 ms elapsed real time
    1686 ms elapsed real time
    1247 ms elapsed real time
    652  ms elapsed real time
;; And justice:
    4658 ms elapsed real time
    4078 ms elapsed real time
    3813 ms elapsed real time
    3493 ms elapsed real time
    3194 ms elapsed real time
    2913 ms elapsed real time
    2634 ms elapsed real time, including 0 ms collecting
    2343 ms elapsed real time, including 0 ms collecting
;; On valor that's almost linear:  (1. 1.2  1.3  1.6  2.0  2.7  3.6  6.9)
|#


#|
;; [2007.09.21] Ok trying the one-thunk version.
;; This time using optimize-level 3 for everything.
;; (BUT still using the test with generic arithmetic... 
;;  Replacing generic with fixnum arith makes almost no difference.)
;;
;; Justice does well here, 63% speedup on 2 processors.
    2826 ms elapsed real time, including 330 ms collecting 2496
    1726 ms elapsed real time, including 340 ms collecting 1386
    1785 ms elapsed real time, including 348 ms collecting
    2036 ms elapsed real time, including 388 ms collecting
    2172 ms elapsed real time, including 368 ms collecting
    2129 ms elapsed real time, including 368 ms collecting
    1993 ms elapsed real time, including 361 ms collecting
    2127 ms elapsed real time, including 385 ms collecting
;; Valor doesn't do so great, a mere 72% on 8 processors.
    3619 ms elapsed real time, including 389 ms collecting 3230
    2386 ms elapsed real time, including 372 ms collecting 2014
    2498 ms elapsed real time, including 394 ms collecting
    2248 ms elapsed real time, including 422 ms collecting
    2016 ms elapsed real time, including 438 ms collecting
    2125 ms elapsed real time, including 436 ms collecting
    2132 ms elapsed real time, including 428 ms collecting
    2100 ms elapsed real time, including 428 ms collecting 1672
;; Maybe I need to let it warm up before timing it...


;; Tried removing global lock on steal... shouldn't do much, steal happens only a few times.
;; Ok, now I'm trying standalone.ss.. I've bumped the GC trip way up (20mb).
;; Justice:
    2765 ms elapsed real time, including 9 ms collecting
    1477 ms elapsed real time, including 11 ms collecting
    1818 ms elapsed real time, including 14 ms collecting
    2561 ms elapsed real time, including 13 ms collecting
    8495 ms elapsed real time, including 37 ms collecting
    3033 ms elapsed real time, including 20 ms collecting
    3414 ms elapsed real time, including 23 ms collecting
    6000 ms elapsed real time, including 18 ms collecting
;; Valor:
    3614 ms elapsed real time, including 5 ms collecting
    2181 ms elapsed real time, including 11 ms collecting
    3007 ms elapsed real time, including 12 ms collecting
    2610 ms elapsed real time, including 10 ms collecting
    2351 ms elapsed real time, including 18 ms collecting
    4495 ms elapsed real time, including 56 ms collecting
    2837 ms elapsed real time, including 37 ms collecting
    3164 ms elapsed real time, including 43 ms collecting


;; Let's just pump it up a little bit, doing 2^25
;; Justice:
    12069 ms elapsed real time, including 38 ms collecting
    5935 ms elapsed real time, including 41 ms collecting
    7226 ms elapsed real time, including 48 ms collecting
    8365 ms elapsed real time, including 53 ms collecting
    8081 ms elapsed real time, including 55 ms collecting
    39304 ms elapsed real time, including 159 ms collecting
    9678 ms elapsed real time, including 72 ms collecting
    7367 ms elapsed real time, including 68 ms collecting
;; Valor:
    14483 ms elapsed real time, including 34 ms collecting
    8573 ms elapsed real time, including 46 ms collecting
    11175 ms elapsed real time, including 47 ms collecting
    10491 ms elapsed real time, including 66 ms collecting
    9644 ms elapsed real time, including 64 ms collecting
    18048 ms elapsed real time, including 207 ms collecting
    12123 ms elapsed real time, including 159 ms collecting
    13114 ms elapsed real time, including 169 ms collecting

    4026577360 bytes allocated, including 4010964504 bytes reclaimed
    4027445984 bytes allocated, including 4012676928 bytes reclaimed
    4027724376 bytes allocated, including 4013371024 bytes reclaimed
    4028370376 bytes allocated, including 4016095424 bytes reclaimed
    4029065272 bytes allocated, including 4017681984 bytes reclaimed
    13650460264 bytes allocated, including 13644598008 bytes reclaimed
    9851505424  bytes allocated, including 9845509264 bytes reclaimed
    10284491240 bytes allocated, including 10270320416 bytes reclaimed

;; INTERESTING, with this ^^ "parmv" version it's doing 120 bytes of
;; allocation per iteration.  Oh wait, valor is 64-bit so that's only
;; 15 words... that's not that bad.



;; Hmm... I did the pcall hack and it's still allocating 104 bytes per
;; iteration (more than that really, because 50% of all iterations are
;; leaf nodes). This must be counting the allocation of chez stack
;; frames or something...?
;; Pcall on Valor:
    14520 ms elapsed real time, including 34 ms collecting
    8630 ms elapsed real time, including 40 ms collecting
    8193 ms elapsed real time, including 53 ms collecting
    8423 ms elapsed real time, including 48 ms collecting
    9313 ms elapsed real time, including 54 ms collecting
    17892 ms elapsed real time, including 183 ms collecting
    11387 ms elapsed real time, including 138 ms collecting
    12867 ms elapsed real time, including 194 ms collecting

    3489700464 bytes allocated, including 3484829360 bytes reclaimed
    3490497824 bytes allocated, including 3487546112 bytes reclaimed
    3490588744 bytes allocated, including 3487478928 bytes reclaimed
    3490491216 bytes allocated, including 3488751648 bytes reclaimed
    3491867480 bytes allocated, including 3491136560 bytes reclaimed
    13147459104 bytes allocated, including 13140928488 bytes reclaimed
    9123752016  bytes allocated, including 9109261240 bytes reclaimed
    10978387408 bytes allocated, including 10963775480 bytes reclaimed

;; Just ran on hydra.

    17256 ms elapsed real time, including 42 ms collecting
    9277 ms elapsed real time, including 50 ms collecting
    13226 ms elapsed real time, including 57 ms collecting
    12144 ms elapsed real time, including 58 ms collecting
    9091 ms elapsed real time, including 62 ms collecting
    9058 ms elapsed real time, including 63 ms collecting
    6943 ms elapsed real time, including 71 ms collecting
    8079 ms elapsed real time, including 76 ms collecting
    9387 ms elapsed real time, including 70 ms collecting
    6023 ms elapsed real time, including 83 ms collecting
    6616 ms elapsed real time, including 83 ms collecting
    6205 ms elapsed real time, including 85 ms collecting
    10015 ms elapsed real time, including 197 ms collecting
    8695 ms elapsed real time, including 152 ms collecting
    7486 ms elapsed real time, including 183 ms collecting
    13219 ms elapsed real time, including 338 ms collecting

    3489700464 bytes allocated, including 3484829360 bytes reclaimed
    3490540520 bytes allocated, including 3487485432 bytes reclaimed
    3490556208 bytes allocated, including 3487629400 bytes reclaimed
    3491434064 bytes allocated, including 3490506304 bytes reclaimed
    3491507864 bytes allocated, including 3490645512 bytes reclaimed
    3492019568 bytes allocated, including 3492957752 bytes reclaimed
    3492718056 bytes allocated, including 3493541040 bytes reclaimed
    3493242040 bytes allocated, including 3474629096 bytes reclaimed
    3490651720 bytes allocated, including 3491345440 bytes reclaimed
    3494329216 bytes allocated, including 3477931520 bytes reclaimed
    3494864312 bytes allocated, including 3478745896 bytes reclaimed
    3494978880 bytes allocated, including 3479921840 bytes reclaimed
    9102705792 bytes allocated, including 9098978320 bytes reclaimed
    6564471288 bytes allocated, including 6555174608 bytes reclaimed
    7549604712 bytes allocated, including 7550149648 bytes reclaimed
    14419644312 bytes allocated, including 14418772056 bytes reclaimed


;; SIGH, for larger numbers of threads I seem to get:

[thread 3] Error in shadowstack-frames: 0 is not of type #<record type shadowstack>. 
[thread 3] Error: attempt to apply non-procedure 1.

;; Top says that scheme will get to using ~740% cpu.

;; For reference, did the pcall version on Valor grabbing cpu time:
    15080 ms elapsed cpu time, including 28 ms collecting
    16789 ms elapsed cpu time, including 60 ms collecting
    16301 ms elapsed cpu time, including 24 ms collecting
    23365 ms elapsed cpu time, including 36 ms collecting
    15920 ms elapsed cpu time, including 100 ms collecting
    105934 ms elapsed cpu time, including 184 ms collecting
    75764 ms elapsed cpu time, including 148 ms collecting
    85893 ms elapsed cpu time, including 152 ms collecting

|#


#|
;;================================================================================
;; [2007.09.22] Ah, this is nice.  With current standalone_pcall
;; getting proper speedups beyond two threads.  Here's on hydra using
;; optimize-level 2 (but with a matlab process eating one cpu).

1    8779 ms elapsed real time
2    4611 ms elapsed real time
3    3473 ms elapsed real time
4    2721 ms elapsed real time
5    2899 ms elapsed real time
6    2335 ms elapsed real time
7    1797 ms elapsed real time
8    1629
9    1260
10   1198
11   1222
12   1215
13   1210
14   1223
15   1011
16   -- got an error, overflowed the shadowstack!!!
 
Seemed to choke on 8 threads.... having to run manually some.

Par overhead on one thread is currently at 7.5X.  Not bad at all.

Doing par with fixnum arithmetic instead of generic arith doesn't seem
to make much difference... but switchng to O3 jumps us back up to 11X
overhead.

|#
;; [2010.10.30] Note -- this is still the fib test right?

#|
;;================================================================================
;; [2007.09.23] Running again on hydra after some fixes (for various errors.)

    9575 ms elapsed real time
    4954 ms elapsed real time
    3322 ms elapsed real time
    2961 ms elapsed real time
    2404 ms elapsed real time
    1691 ms elapsed real time
    1476 ms elapsed real time
    1392 ms elapsed real time
    1237 ms elapsed real time
    1075 ms elapsed real time
    1007 ms elapsed real time
    957 ms elapsed real time
    898 ms elapsed real time
    863 ms elapsed real time
    804 ms elapsed real time
    810 ms elapsed real time

It's possible that we're plateauing at the end because the absolute
amounts of work are getting too small.  Cpu time stays fairly constant, which is good.

;; Here's 10-16 threads on 2^27th work:
10:    42193 ms elapsed cpu time
11:    42135 ms elapsed cpu time
12:    42700 ms elapsed cpu time
13:    43553 ms elapsed cpu time
14:    43302 ms elapsed cpu time
15:    44507 ms elapsed cpu time
16:    46628 ms elapsed cpu time

;; But real time is not improving much.  This must mean that
;; processors cannot keep busy:
    4392 ms elapsed real time
    4050 ms elapsed real time
    3825 ms elapsed real time
    3649 ms elapsed real time
    3388 ms elapsed real time
    3276 ms elapsed real time
    3194 ms elapsed real time


;; Now with things working well I'm going back to see if we can speed
;; up the compiler on run_3phases.ws.  For now I'm using parmv and
;; par-map (not pcall directly).

;; Testing on laptop:
;; nonPar version: 9.0s real on static-elab
;; par 1T: 9.2s
;; par 2T: 9.2s
;; par 8T: 93.s -- WHOA, 10X slowdown as we increase the number of threads!!
;; Something is seriously wrong.

nonpar: 14.6s
    1T: 14.7
    2T: 14.0
    4T: 13.98
    8T: 14.3
   16T: 15.5

|#

#|

Ran it on 2^28th with opt-level 3.  Parallel efficiency isn't getting
any better at the large numbers of cores.  I think I need to make some
improvements to the algorithm and data structures.  For example, using
a ready-queue, etc.

    67270 ms elapsed real time
    33978 ms elapsed real time
    22769 ms elapsed real time
    17530 ms elapsed real time
    13922 ms elapsed real time
    12001 ms elapsed real time
    10218 ms elapsed real time
    8982 ms elapsed real time
    8315 ms elapsed real time
    7832 ms elapsed real time
    7355 ms elapsed real time
    6959 ms elapsed real time
    6533 ms elapsed real time
    6222 ms elapsed real time
    5960 ms elapsed real time
    5602 ms elapsed real time




|#




====================================================================================================

[2010.10.31] {Apparent nondeterministic failure}

I just ran into a failure taht is difficult to reproduce... ah the
trick must be that shutdown doesn't block yet, so the two consecutive
par phases are interfering:

    [newton@wasp ~/wavescript/src/experimental/parallelizing_compiler] $ chez test.ss
    Chez Scheme Version 8.0
    Copyright (c) 1985-2010 Cadence Research Systems

    Starting simple test

    [collecting generation 4 into generation 4...done]

      [par] Initializing PAR system for 4 threads.

    [collecting generation 0 into generation 1...done]

    [collecting generation 0 into generation 1...done]
      [par] Everyone's awake!
    Run using parallel add-tree via pcall mechanism:
    (time (tree test-depth))
	no collections
	275 ms elapsed cpu time
	97 ms elapsed real time
	32768 bytes allocated

    32768

      [par] Par status:
      par-finished #f
      allstacks: 4
      stacksizes: (0 0 0 0)

      [par] worker 2 terminating (TID 2).
      [par] worker 4 terminating (TID 3).
      [par] Par status:
      par-finished #t
      allstacks: 4
      stacksizes: (0 0 0 0)


      [par] Initializing PAR system for 2 threads.
    Exception in ASSERT: failed: #<syntax (eq? threads-registered 1) [line 766, char 15 of chez_threaded_utils.ss]>



[2010.10.31] {Timings and unpredictability}

I notice that on wasp on four threads doing an add-tree of 2^23 it
can occassionally take 335ms but usually takes 600+ms.

But two threads is pretty dependably good... hmm.
Would be nice to have compare and swap (CAS)...

Right now the safe/unsafe with-mutex doesn't make any difference at
all.



====================================================================================================
[2010.10.31] {Doing some hacking for ivars}

Hmm... just got it to segfault in opt level 2.


Just ran Will's example for the first time... got a bunch (infinite?) of these on
one run:

    (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
    (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex


In this run it is successfully waking up the critical ivar-blocked
computation, but then it deadlocks right after that!
================================================================================

    Test #1: William Leiserson's example
    (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
    |(ivar-apply-or-block #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()])


    (TID 1) BLOCKING ON IVAR fn = #<procedure kont>

    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
    *** Bar: after spawns
    | (ivar-apply-or-block #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()])


    (TID 1) BLOCKING ON IVAR fn = #<procedure kont>

    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
    | |(ivar-apply-or-block #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()])


    (TID 1) BLOCKING ON IVAR fn = #<procedure kont>

    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    *** Foo: Done with work now writing I1
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #t: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> 33 ()]]
    (TID 1) STOLE work! #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> 33 ()]]
    *** Snafoo: Read I1, now writing I2

================================================================================
Wow, what a good test!  On two threads this will currently either,
pass, diverge with lots of attempted steals, deadlock after success
steal, or finally accidentally pass an ivar-boxed value to +...  (The
last one is below):

    Test #1: William Leiserson's example
    (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
    |(ivar-apply-or-block #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()])


    (TID 1) BLOCKING ON IVAR fn = #<procedure kont>

    (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
    *** Bar: after spawns
    | (ivar-apply-or-block #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()])


    (TID 1) BLOCKING ON IVAR fn = #<procedure kont>

    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
    | |(ivar-apply-or-block #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()])


    (TID 1) BLOCKING ON IVAR fn = #<procedure kont>

    *** Foo: Done with work now writing I1
    (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #t: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> 33 ()]]
    (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #t: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> 33 ()]]
    (TID 0) STOLE work! #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> 33 ()]]
    *** Snafoo: Read I1, now writing I2
    Exception in +: #[ivar #<mutex> 33 ()] is not a number

How exactly are we seeing TWO attempts to steal for the available ivar
above... Each of those must hold the lock, and after the first one
succeeds it shouldn't have released the lock to let the second one
in!!!  That "unpacking" print I put in isn't printing...
Oops.. silly bug, fixed that and now I can get a deadlock like the following.
Ack, not only that it looks like there's DUPLICATE EXECUTION!!!
================================================================================

      Test #1: William Leiserson's example
      (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
      |(ivar-apply-or-block #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()])


      (TID 1) BLOCKING ON IVAR fn = #<procedure kont>

      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
      *** Bar: after spawns
      | (ivar-apply-or-block #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()])


      (TID 1) BLOCKING ON IVAR fn = #<procedure kont>

      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
      | |(ivar-apply-or-block #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()])


      (TID 1) BLOCKING ON IVAR fn = #<procedure kont>

      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
      *** Foo: Done with work now writing I1
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #t: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> 33 ()]]
      (TID 1) STOLE work! #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> 33 ()]]
      (TID 0) STOLE work! #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> 33 ()]]
      Unpacking ivar for continuation: #[ivar #<mutex> 33 ()]*** Snafoo: Read I1, now writing I2
      Unpacking ivar for continuation: #[ivar #<mutex> 33 ()]*** Bar: done reading I1
      |(ivar-apply-or-block #<procedure kont> #[ivar #<mutex> 77 ()])
      *** Bar: done reading I2
      |2541
      (TID 1) Polling ivar: #[ivar #<mutex> 77 ()]
      *** Quux: done reading I2
      (TID 1) IVAR unblocked, returning: #[ivar #<mutex> 77 ()]
      | |#<void>
      *** Bar: done reading I1
      | |(ivar-apply-or-block #<procedure kont> #[ivar #<mutex> 77 ()])
      *** Bar: done reading I2
      | |2541
      (TID 1) IVAR unblocked, returning: #[ivar #<mutex> 33 ()]
      | #<void>
      *** Snafoo: Read I1, now writing I2

================================================================================
Ok... if I fix my error handling that turns into a proper error
instead of a deadlock.

      Test #1: William Leiserson's example
      (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
      |(ivar-apply-or-block #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()])


      (TID 1) BLOCKING ON IVAR fn = #<procedure kont>

      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
      *** Bar: after spawns
      | (ivar-apply-or-block #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()])


      (TID 1) BLOCKING ON IVAR fn = #<procedure kont>

      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
      | |(ivar-apply-or-block #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()])


      (TID 1) BLOCKING ON IVAR fn = #<procedure kont>

      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      *** Foo: Done with work now writing I1
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #t: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> 33 ()]]
      (TID 1) STOLE work! #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> 33 ()]]
      Unpacking ivar for continuation: #[ivar #<mutex> 33 ()]*** Snafoo: Read I1, now writing I2
      (TID 1) Polling ivar: #[ivar #<mutex> 77 ()]
      *** Quux: done reading I2
      (TID 1) IVAR unblocked, returning: #[ivar #<mutex> 77 ()]
      | |#<void>
      (TID 1) Polling ivar: #[ivar #<mutex> 33 ()]
      *** Bar: done reading I1
      | |(ivar-apply-or-block #<procedure kont> #[ivar #<mutex> 77 ()])
      *** Bar: done reading I2
      | |2541
      (TID 1) IVAR unblocked, returning: #[ivar #<mutex> 33 ()]
      | #<void>
      *** Snafoo: Read I1, now writing I2
      error ivar should only be assigned once!  Already contains value 77

================================================================================

I ran a simpler test that also duplicates the continuation:

      Test #1: Cilk Ivar with blocking 2
	(TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
      |(ivar-apply-or-block #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()])


	(TID 1) BLOCKING ON IVAR fn = #<procedure kont>

	(TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
	(TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
	(TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
	(TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
	(TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
	(TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
	(TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
	(TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> empty-ivar-sym ()]]
	(TID 1) STOLE work! #[shadowframe #<mutex> ivar-blocked #<procedure kont> #[ivar #<mutex> 33 ()]]
      Unpacking ivar for continuation: #[ivar #<mutex> 33 ()] *** Woo, read completed! 33
      | (ivar-apply-or-block #<procedure kont> #[ivar #<mutex> 99 ()])
      | #<void>

      ERROR: error ivar should only be assigned once!  Already contains value 99
	[par] Par status:
	      par-finished #f
	      allstacks: 2
	      stacksizes: (1 0)

      STACK 0:
      (#[shadowframe #<mutex> stolen #<procedure> ignored])
      STACK 1:
      ()

Here's the macro expanded version of what it is running:

    (let ([iv 'cilk-var-uninit]
	  [iv2 'cilk-var-uninit]
	  [x 'cilk-var-uninit]
	  [y 'cilk-var-uninit])
      (set! iv (empty-ivar))
      (pcall
	(lambda (a b) a)
	(let ([_ 'ignored])
	  (set! iv2 (empty-ivar))
	  (let ([kont (lambda (tmp)
			(set! x tmp)
			(#2%printf " *** Woo, read completed! ~s\n" x)
			(set-ivar! iv2 99)
			'yay
			(let ([kont (lambda (tmp) (set! y tmp) (#2%void))])
			  (ivar-apply-or-block kont iv2)))])
	    (ivar-apply-or-block kont iv)))
	(begin
	  ((letrec ([loop (lambda (i)
			    (if (#2%not (#2%= 0 i))
				(loop (#2%sub1 i))
				(#2%void)))])
	     loop)
	    1000000)
	  (set-ivar! iv 33)))
      (#2%+ x y))

================================================================================
UPDATE:
Great, fixed duplication bug.  Now a different problem with Will's example.

     Test #1: William Leiserson's example
       (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
     |(ivar-apply-or-block #<procedure> #[ivar #<mutex> empty-ivar-sym ()])


       (TID 1) BLOCKING ON IVAR fn = #<procedure>

       (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
     *** Bar (TID 1): after spawns
     | (ivar-apply-or-block #<procedure> #[ivar #<mutex> empty-ivar-sym ()])


       (TID 1) BLOCKING ON IVAR fn = #<procedure>

       (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
     | |(ivar-apply-or-block #<procedure> #[ivar #<mutex> empty-ivar-sym ()])


       (TID 1) BLOCKING ON IVAR fn = #<procedure>

       (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
       (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
       (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
       (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: 
     *** Foo (TID 0): Done with work now writing I1
       (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: 
       (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: 
       (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
       (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: 
       (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: 
       (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f: 
       (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
       (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
       (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
       (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
       (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
       (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
       (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #t: 
       (TID 1) STOLE work! #[shadowframe #<mutex> ivar-blocked #<procedure> #[ivar #<mutex> 33 ()]]
     Unpacking ivar for continuation: #[ivar #<mutex> 33 ()]| | (x1 33)
     *** Snafoo (TID 1): Done read I1, now writing I2
     | | #<void>
       (TID 1) DONE with stolen work: #[shadowframe #<mutex> stolen #<procedure> #<void>]
       (TID 1) Polling ivar: #[ivar #<mutex> 77 ()]
       (TID 1) Frame nuked.  Original owner executing continuation on ivar #[ivar #<mutex> 77 ()]
     | | (x2 77)
     *** Quux (TID 1): done reading I2
     | | 77
       (TID 1) IVAR unblocked, returning: #[ivar #<mutex> 77 ()]
     | |#<void>
       (TID 1) DONE with stolen work: #[shadowframe #<mutex> stolen #<procedure> #<void>]
       (TID 1) Polling ivar: #[ivar #<mutex> 33 ()]
       (TID 1) Frame nuked.  Original owner executing continuation on ivar #[ivar #<mutex> 33 ()]
     | |(x3 33)
     *** Bar (TID 1): done reading I1
     | |(ivar-apply-or-block #<procedure> #[ivar #<mutex> 77 ()])
       (TID 1) Ivar available on first try #[ivar #<mutex> 77 ()]
     | |(y 77)
     *** Bar (TID 1): done reading I2
     | |2541
       (TID 1) IVAR unblocked, returning: #[ivar #<mutex> 33 ()]
     | #<void>
       (TID 1) DONE with stolen work: #[shadowframe #<mutex> stolen #<procedure> #<void>]
       (TID 1) IVAR unblocked, returning: #[ivar #<mutex> 33 ()]
     |#<void>
       (TID 1) DONE with stolen work: #[shadowframe #<mutex> stolen #<procedure> #<void>]
     Exception in unit-test: Test #1: FAILED, expected 2541 received #<void>!


INTERESTING.  If I put the (sync) before the final (+ x3 y) line it
fixes this problem and then passes williams test the vast majority of
the time... but it IS possible to deadlock it... here's an execution:


      [par] Initializing PAR system for 2 threads.
      [par] Everyone's awake!
    ================================================================================
    Test #1: William Leiserson's example
      (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
    |(ivar-apply-or-block #<procedure> #[ivar #<mutex> empty-ivar-sym ()])


      (TID 1) BLOCKING ON IVAR fn = #<procedure>

      (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
    *** Bar (TID 1): after spawns
    | (ivar-apply-or-block #<procedure> #[ivar #<mutex> empty-ivar-sym ()])


      (TID 1) BLOCKING ON IVAR fn = #<procedure>

      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
    | |(ivar-apply-or-block #<procedure> #[ivar #<mutex> empty-ivar-sym ()])


      (TID 1) BLOCKING ON IVAR fn = #<procedure>

      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
    *** Foo (TID 0  (TID ): Done with work now writing I1
    1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) STOLE work! #[shadowframe #<mutex> ivar-blocked #<procedure> #[ivar #<mutex> 33 ()]]
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
    Unpacking ivar for continuation: #[ivar #<mutex> 33 ()]| | (x3 33)
    *** Bar (TID 1): done reading I1
    | | (ivar-apply-or-block #<procedure> #[ivar #<mutex> empty-ivar-sym ()])
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 


      (TID 1) BLOCKING ON IVAR fn = #<procedure>

      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #t 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) STOLE work! #[shadowframe #<mutex> ivar-blocked #<procedure> #[ivar #<mutex> 33 ()]]
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
    Unpacking ivar for continuation: #[ivar #<mutex> 33 ()]| | |(x1 33)
    *** Snafoo (TID 1): Done read I1, now writing I2
    | | |#<void>
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) DONE with stolen work: #[shadowframe #<mutex> stolen #<procedure> #<void>]
      (TID 0) STOLE work! #[shadowframe #<mutex> ivar-blocked #<procedure> #[ivar #<mutex> 77 ()]]
    Unpacking ivar for continuation: #[ivar #<mutex> 77 ()]|(y 77)
    *** Bar (TID 0): done reading I2
    |#<void>
      (TID 0) DONE with stolen work: #[shadowframe #<mutex> stolen #<procedure> #<void>]
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #t 
      (TID 0) STOLE work! #[shadowframe #<mutex> ivar-blocked #<procedure> #[ivar #<mutex> 77 ()]]
    Unpacking ivar for continuation: #[ivar #<mutex> 77 ()]|(x2 77)
    *** Quux (TID 0): done reading I2
    |77
      (TID 0) DONE with stolen work: #[shadowframe #<mutex> stolen #<procedure> 77]

This is a bit confusing because it seems to finish doing all the
meaningful work... maybe it threw an error on a different thread.

INTERESTING... it actually gets stuck at the final (sync) essentially...

WOW, I can ALSO get an infinite loop on attempt to steal for an ivar
that doesn't become available.
Ok, here's the expanded version of the cilk macro:
================================================================================

    (letrec* ([i1 (empty-ivar)]
	      [i2 (empty-ivar)]
	      [foo (lambda ()
		     (begin
		       ((letrec ([loop (lambda (i)
					 (if (#2%not (#2%= 0 i))
					     (loop (#2%sub1 i))
					     (#2%void)))])
			  loop)
			 1000000)
		       (#2%printf
			 "*** Foo (TID ~s): Done with work now writing I1\n"
			 (#2%get-thread-id))
		       (set-ivar! i1 33)))]
	      [snafoo (lambda ()
			(let ([x1 'cilk-var-uninit])
			  (let ([kont (#2%$trace-closure
					'x1
					(lambda (tmp)
					  (set! x1 tmp)
					  (#2%printf
					    "*** Snafoo (TID ~s): Done read I1, now writing I2\n"
					    (#2%get-thread-id))
					  (set-ivar! i2 (#2%+ x1 44))))])
			    (ivar-apply-or-block kont i1))))]
	      [quux (lambda ()
		      (let ([y1 'cilk-var-uninit])
			(pcall
			  (lambda (a b) a)
			  (let ([_ 'ignored])
			    (let ([kont (#2%$trace-closure
					  'y1
					  (lambda (tmp)
					    (set! y1 tmp)
					    (#2%printf
					      "*** Quux (TID ~s): done reading I2\n"
					      (#2%get-thread-id))))])
			      (ivar-apply-or-block kont i2)))
			  (snafoo))))]
	      [baz (lambda ()
		     (let ([x2 'cilk-var-uninit] [y2 'cilk-var-uninit])
		       (pcall
			 (lambda (a b) a)
			 (let ([_ 'ignored])
			   (pcall
			     (lambda (a b) a)
			     (let ([_ 'ignored])
			       (#2%printf
				 "*** Bar (TID ~s): after spawns\n"
				 (#2%get-thread-id))
			       (let ([kont (#2%$trace-closure
					     'x2
					     (lambda (tmp)
					       (set! x2 tmp)
					       (#2%printf
						 "*** Bar (TID ~s): done reading I1\n"
						 (#2%get-thread-id))
					       (let ([kont (#2%$trace-closure
							     'y2
							     (lambda (tmp)
							       (set! y2 tmp)
							       (#2%printf
								 "*** Bar (TID ~s): done reading I2\n"
								 (#2%get-thread-id))))])
						 (ivar-apply-or-block
						   kont
						   i2))))])
				 (ivar-apply-or-block kont i1)))
			     (quux)))
			 (foo))
		       (#2%printf
			 "*** Bar (TID ~s): Return final value... \n"
			 (#2%get-thread-id))
		       (#2%* x2 y2)))])
      (baz))

Well... it seems that the problem is returning from down inside that
double-pcall with double ivar-apply-or-block.  Here's the final stack state:

     *** Bar (TID 0): done reading I2
       [par] Par status:
	     par-finished #f
	     allstacks: 2
	     stacksizes: (1 6)

     STACK 0:
     (#[shadowframe #<mutex> stolen #<procedure> ignored])
     STACK 1:
     (#[shadowframe #<mutex> stolen #<procedure> ignored] #[shadowframe #<mutex> stolen #<procedure> ignored]
       #[shadowframe #<mutex> done #<procedure> #<void>]
       #[shadowframe #<mutex> stolen #<procedure> #[ivar #<mutex> 33 ()]]
       #[shadowframe #<mutex> ivar-blocked #<procedure> #[ivar #<mutex> 77 ()]]
       #[shadowframe #<mutex> stolen #<procedure> #[ivar #<mutex> 77 ()]])
     |#<void>
       (TID 0) DONE with stolen work: #[shadowframe #<mutex> stolen #<procedure> #<void>]


Hmm... added a message for popping frames... the deadlocking run
doesn't pop ANY frames.  It gets stuck at this innermost point.... But
the odd thing is that it looks like TID 0 does finish some stolen
work... and that that should unblock TID 1...  I could probably
disable self-stealing to make this a little clearer.

While using petite I noticed a different deadlock... it stopped right
after reading I1 in Will's example...


====================================================================================================
Also, here's one of the runs that tries to steal forever:

    Test #1: William Leiserson's example
      (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]


      (TID 1) BLOCKING ON IVAR fn = #<procedure>

      (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]
    *** Bar (TID 1): after spawns


      (TID 1) BLOCKING ON IVAR fn = #<procedure>

      (TID 1) STOLE work! #[shadowframe #<mutex> available #<procedure> ignored]


      (TID 1) BLOCKING ON IVAR fn = #<procedure>

      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
    *** Foo (TID   (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
    0  (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
    ): Done with work now writing I1
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) Polling ivar: #[ivar #<mutex> empty-ivar-sym ()]
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 1) STOLE work! #[shadowframe #<mutex> ivar-blocked #<procedure> #[ivar #<mutex> 33 ()]]
    Unpacking ivar for continuation: #[ivar #<mutex> 33 ()]|(x2 33)
    *** Bar (TID 1): done reading I1


      (TID 1) BLOCKING ON IVAR fn = #<procedure>

      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      (TID 0) ATTEMPT TO STEAL ivar-blocked FRAME, avail #f 
      .......


[2010.11.01] {FFI adventures}

Trying to do a wrapper around TBB... these symbols are undefined:

                 U _Znwm
                 U __gxx_personality_v0
                 U sched_yield@@GLIBC_2.2.5

Even more with ICC.... hmm... what is the solution?

                 U _Unwind_Resume@@GCC_3.0
                 U _ZdlPv@@GLIBCXX_3.4
                 U _Znwm@@GLIBCXX_3.4
                 U __gxx_personality_v0@@CXXABI_1.3
                 U sched_yield@@GLIBC_2.2.5


[2010.11.02] {Working on par6}

Works sometimes on small fibs...
Getting some deadlocks.  Probably need to lock that head.

Is the following correct?  I'm seeing many hits against the bottom of
the stack:

     |(pop!
	#[shadowstack 407 #0=#[shadowframe #<mutex> #f #<procedure fib> 3 #f #f] #0#])
       (TID 0) Stack went empty!
     |#<void>
     |(pop!
	#[shadowstack 407 #0=#[shadowframe #<mutex> #f #<procedure fib> 2 #f #f] #0#])
       (TID 0) Stack went empty!
     |#<void>
     |(pop!
	#[shadowstack 407 #0=#[shadowframe #<mutex> #f #<procedure fib> 1 #f #f] #0#])
       (TID 0) Stack went empty!

I guess so...

I'm having a lot of trouble reproducing that deadlock now...  Alas,
the deadlock could also be an EXCEPTION on another thread... sigh.
I should redefine the exception handler.


