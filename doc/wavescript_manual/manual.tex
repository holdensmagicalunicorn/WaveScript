
%\documentstyle[refman.sty]{article}
%\documentstyle[twocolumn]{report}
\documentclass[twocolumn]{report}
\usepackage{color}
%\usepackage{code}

%\usepackage{hyperref}
\usepackage{html}


\setlength{\textheight}{9.25in}
\setlength{\columnsep}{0.33in} %RRN changed: {0.33in}
\setlength{\textwidth}{7.48in}
\setlength{\footskip}{0.0in}
\setlength{\topmargin}{-0.25in}
\setlength{\headheight}{0.0in}
\setlength{\headsep}{0.0in}
\setlength{\oddsidemargin}{-.45in}
\setlength{\parindent}{1pc}


% page size commands

\title{WaveScript 0.1.4 Users Manual}

\newcommand{\rednote}[1]{{\textcolor{blue}{#1}}}
%\newcommand{\rednote}[1]{{\em \bf{}}}

\newcommand{\evalsto}[2]{\[ \begin{array}{rcl}
$\tt #1 $&$ \arr $&$ #2 $
\end{array} \]}

\newcommand{\arr}{\ensuremath{\rightarrow}}

\newcommand{\cd}{\tt}

\newcommand{\ws}{WaveScript}

\newcommand{\ra}{\ensuremath{\rightarrow}}

\newenvironment{wscode}{\begin{center}\tt}{\end{center}}

\begin{document}

\maketitle

% title page commads

\pagenumbering{arabic}
\tableofcontents
\clearpage

\chapter{Introduction}

% [2007.12.01] nixing metaprogramming ...
WaveScript is a functional language for writing highly abstract
programs that generate efficient dataflow graphs through a two-stage
evaluation model.  These graphs are
executable in several backends (Scheme, ML, C++) that offer different
tradeoffs in features, performance, and compile times.  The compiler
has several command line entrypoints for the different backends.

%Calling {\bf ws}
% linking them to the {\em XStream} engine.

%\section{Bottom-up Tutorial}
\section{A taste of the language}\label{s:taste}

The academic publications on WaveScript will give you a top-down
account of its features, reason for being, and so on.  In this manual,
our goal is instead to introduce you to programming in WaveScript in a
bottom-up manner.  We'll start from ``Hello-world'' and proceed from
there.

%Here's the simplest complete WaveScript program that you can write:
Here's a simple but complete {\ws} program:
\begin{verbatim}
  main = timer(10.0)
\end{verbatim}
This creates a timer that fires at 10hz.  The {\em return value} of
the {\cd timer} function is a stream of empty-tuples (events carrying
no information).  The return value of the whole program is, by
convention, the stream named ``main''.  The {\em type} of the above
program is {\cd Stream ()}, where {\cd ()} designates the empty-tuple.

In our next program, we will print ``Hello world'' forever.
\begin{verbatim}
  main = iterate x in timer(10.0) {
           emit "Hello world!";
         }
\end{verbatim}
The {\cd iterate} keyword provides a special syntax for accessing
every element in a stream, running arbitrary code using that element's
value, and producing a new stream as output.  In the above example,
our {\cd iterate} ignores the values in the timer stream (``x''), and
produces one string value on the output stream on each invocation
(thus, it prints ``Hello world!'' at 10hz).  The type of the program
is {\tt Stream String}. 

Note, that we may produce two or more elements on the output stream
during each invocation.  For example, the following would produce two
string elements for each input element on the timer stream.
\begin{verbatim}
  main = iterate x in timer(10.0) {
           emit "Hello world!";
           emit "Hello again!";
         }
\end{verbatim}


\section{Pragmatics: Using WaveScript}

% This section discusses to setup and run {\ws}, what the different
% backends are, and how to make best use of them.  If you want to first
% find out more about the language, skip to Chapter~\ref{s:lang} and
% return here later.

This section addresses pragmatic issues concerning invoking
the system and running dataflow graphs.  If you are new to WaveScript,
it may help to skip to chapter \ref{s:lang} to get a sense for the
language itself, then come back to this section afterwards.

\subsection*{Installing}

See the README for install instructions.  The bottom line is that you
will need Mzscheme and Petite Chez Scheme to run the WaveScript
compiler and the Scheme backend.  (Petite for Linux is included in the
repository.)  You will need Boost, the Gnu Scientific Library (GSL),
FFTW, and their respective headers to run compiled C++ code.

Once the system is installed you should be able to execute {\bf \tt
  ws} on any WaveScript source files ({\tt .ws} files).  This will
compile the query and execute it directly in the Scheme backend.
Other backends (and variations on this one) will be discussed in this
section.  

\subsection*{Develop Incrementally}

WaveScript is a research compiler.  It doesn't offer the same
level of support that you expect from production-quality
compilers.  Sometimes the error messages might be difficult to
interpret.  (However, the type checker messages have been improved
immensely and do include code locations [04/08/2007].)

Therefore it helps to build your program bit by bit.  Compile often to make
sure that the pieces of your program parse and type-check.

{\tt \bf wsparse:} While entrypoints such as {\tt \bf ws} parse source files
internally, if you want the full error message for a parser error
(including line and column number!), run {\tt wsparse} directly on the
{\tt .ws} file.  It will either print the AST (abstract syntax tree) for the
file, or will give you an error message that does include line and
character numbers.

\subsection{{\tt \bf ws}: The Interactive Scheme Backend}

Running the command ``{\tt ws mysource.ws}'' will compile your source
file, and execute the resultant dataflow graph directly within Scheme,
without generating code for another platform.
%
The dataflow graph is converted to a Scheme program which is compiled
to native code and executed on the fly.  Compile time is low, because
we need not call a separate backend compiler.  However, performance is
not as good as the other backends we will discuss.  Further, the
Scheme backend does not support external (real time) data sources,
only queries running in virtual time using data stored in files.

One major advantage of the Scheme backend is that it's {\em
  interactive}.  The query starts up paused, and the user may step
through and inspect the elements of the output stream.  Thus the user
may {\em pull} on the stream rather than being {\em pushed} a torrent
of output.

%% Further, hardware
%% sensors cannot be accessed from the emulator (except through the
%% foreign interface \ref{s:foreign}), and so data must be read from
%% trace files.

\subsection*{Variants of {\tt \bf ws}}

There are several other useful ways to invoke WaveScript with the
Scheme backend.

\subsubsection*{Consider {\tt \bf ws.opt} for higher performance}

The first thing to do to improve the performance of {\tt ws} is make
sure that you have the full version of Chez Scheme.  This version
includes the incremental native code compiler.  If you are using the
free, Petite Chez Scheme interpreter, your {\tt .ws} query files will
be converted to {\em interpreted} Scheme code, which runs considerably
slower.  The executable {\tt chez} should be in your path.

To go further, you might consider running {\tt ws.opt} in place of {\tt
ws}.  First, {\tt ws.opt} has debugging assertions disabled. 
Second, {\tt ws.opt} is compiled in the highest Chez Scheme optimize
level, and also compiles your query in this higher optimize level.
However, this optimize level is dangerous in that it omits various
checks necessary to maintaining type safety.  Thus the process can
crash if there's an error, or memory can become corrupted (just like
C/C++).  Therefore, debug your code using {\tt ws} first.

\subsubsection*{Run {\tt \bf ws.debug} occasionally for sanity-checking}

Ws.debug is too slow for the normal development cycle, but it is
important to occasionally compile your program with ws.debug.  Mainly
this is important for building confidence that the compiler is
behaving properly on your program.  If the
compiler were a mature system not under active development, this would
not be as important.  


Specifically, when you run {\tt ws.debug}:

\begin{enumerate}
\item It turns on extra ASSERT statements in the code that check data
structure invariants to help ensure proper operation.

\item It dumps the whole program at several points in the
  compilation to files such as ``.\_\_elaboratedprog.ss''.  It can be
  helpful to look at these for debugging.

\item It includes additional type checks of the entire program between
  passes (regular {\tt ws} type checks several times, but {\tt
  ws.debug} does more).  This helps expose compiler bugs.

\item Finally, it does ``grammar checks'' on the output of each compiler
  pass. Each pass includes a BNF grammar that describes its output.
  {\tt ws.debug} mechanically checks to make sure every intermediate
  expression conforms to the appropriate grammar.  Again, this helps
  to expose compiler bugs.
\end{enumerate}


\subsubsection*{For very low compile times: {\tt \bf ws.early}}

If you are running many small programs --- stream ``queries'' --- then
the latency of compilation may be more important to you than the
throughput of the query once it is running.  In this case it is
reasonable to use {\tt ws.early}.


%When you run {\bf ws.debug} the compiler runs extensive
%invariant checks on the data structures it uses, in particular it
%checks the intermediate forms between compiler passes for
%conformance to explicit grammars.  Further it inserts extra
%type-checks to make sure that the intermediate programs are well-formed.


\subsection{The WaveScript MLton Backend}

The WaveScript Scheme backend (ws) provides a reference implementation suitable
to prototyping and debugging applications.  The eventual target for
most WaveScript programs is to generate an efficient stand-alone
binary using one of our other backends.  One of these backends is the
MLton backend, invoked with {\bf wsmlton}.

MLton is an aggressive, whole-program optimizing compiler for Standard
ML.  Generating ML code from the {\ws} dataflow graph is
straightforward because of the similarities between the languages'
type systems.  This provides us with an easy to implement
single-threaded solution that exhibits surprisingly good performance
\cite{mlton}, while also ensuring type- and memory-safe
execution.  

\subsection{The WaveScript CaML Backend}

\rednote{This backend is no longer supported and will receive no new features!}

\subsection{The WaveScript C++ Backend}
The C++ backend\footnote{It uses a C++ compiler not because it
  generates object-oriented code, but because the runtime engine it
  links with has been engineered in C++.} is invoked the {\bf wsc}
command.  
In practice, as WaveScript undergoes development, the {\bf wsc}
compiler often lags behind {\bf ws} in terms of features and
functionality.  Again, develop incrementally, refer to {\tt
  wavescript/demos/wavescope} for programs that should work with {\bf
  wsc}.

Refer to the XStream documentation\footnote{\rednote{[2007.03.09] Currently nonexistent}} 
for information on how to configure the XStream engine
(number of threads, scheduling policy, etc)).

\rednote{[2007.03.09] Ideally the output from the XStream-executed
query would be the same as the ws's output.  Currently, however, there are
some basic disparities in how objects are printed to text form.  Hopefully, these
are straightforward to work around, and should go away shortly.}

Originally, we had intended for our C++ backend to be the
best-performing of our backends, as it includes a low-level
runtime specifically tailored for our streaming domain.
%, as C and C++ are generally regarded as the languages of choice for performance-oriented systems programming. 
However, in our current implementation the MLton backend actually
outperforms our C++ backend, due to three primary factors:  
%
\vspace{-1.5mm}
\begin{enumerate}

\item The C++ backend leverages the flexible XStream scheduling engine for
executing stream graphs.  The cost of this flexibility is that
transferring control between operators is at least a virtual method
invocation, and may involve a queue. The MLton and Scheme backends
support only single-threaded depth-first traversal, where control
transfers between operators are direct function calls.

%% that attempts to
%% distribute operators across a collection of processors which introduces
%% some overhead; though our compiler optimizations try to limit this
%% overhead by reducing operators where possible, it is still slower than

\item MLton incorporates years of work on high-level program
optimizations that GCC cannot reproduce (the abstractions are lost by
the time it gets to C code), and which we do not have time to reproduce
within the {\ws} compiler.

\item Our prototype uses a naive reference counting scheme that is less
efficient than MLton's tracing collector.  (Although it does reduce
pauses relative to MLton's collector; the C++ backend uses the type
system to enforce that cycles cannot occur, and thus pure reference
counting is sufficient.) 
%
In the future we believe that we can implement a substantially more
efficient collector by combining deferred reference counting with the
fact that our stream operators do not share mutable state.

%% In particular, our collector can take advantage
%% of the fact that {\ws} code must be first-order and monomorphic, and
%% there can be no mutable pointers to recursive datatypes.  The former we
%% ensure by defunctionalization and specialization and the latter we
%% simply do not allow the programmer to express. Thee restrictions ensure
%% there are no cyclic data structures and therefore avoid the necessity of
%% a backup tracing collector and the pauses it entails.  Unfortunately,
%% our current system XXX \srm{ryan,fill in something here about why what
%% we have is slow -- Boost pointers???}.

\end{enumerate}
%
%We are exploring methods to reflect this restriction in the type
%system of the source language without undue burden on the programmer.
%However, even the with the current method, a violation of these
%restrictions gives a compile-time error with a source location.  The
%status quo is not bad.

%% There is another substantial advantage to our C++ backend, which
%% motivates us to continue to further develop it: it is the only backend
%% which currently supports intra-machine parallelism -- that is,
%% scheduling of stream graphs on multiple processors in a single
%% machine, which 

However, in spite of its limitations, our current prototype C++
runtime is the best choice when parallelism is available.  The MLton
runtime and garbage collector do not support concurrent threads.




%================================================================================
\chapter{Language Basics}\label{s:lang}

Please make liberal use of the demo files located at {\tt wavescript/demos/wavescope/*.ws} as a reference
when learning WaveScript.  These demos cover most of the basic
functionality in the language.

%\section{Naming conventions}
%\chapter{Basics}

Wavescript is a functional language with many similarities to ML or
Haskell.  Functions are values.  The language is strongly typed and uses a
type-inference algorithm to infer types from variable usages.
It provides the usual basic datatypes, including various
numeric types, strings, lists, arrays, hash tables as well as the more
WaveScript-specific Streams and Sigsegs.  Valid {\em expressions} in
WaveScript are written much as in C.
\[
\begin{array}{rcl}
arithmetic       & : & $\tt 3 + 4 * 10 $  \\
function\; calls & : & $\tt f(x, y)$  \\
blocks           & : & $\tt \{ e$_1$; e$_2$; \ldots$\:$ e$_n$ \}$  \\
\end{array}
\]

But there are also many syntactic differences from C.  For example,
WaveScript doesn't have a sharp division between commands and
expressions.  Conditionals use a different syntax and are valid in
{\em any}
expression position.
%
\evalsto{3 + (if true then 1 else 2)} {4}
%
(Note that the arrow above means ``evaluates to'', but {\ws} does not
currently have an interactive read-eval-print-loop in which you can
type such incomplete program fragments.)

Moreover, {\em blocks} in WaveScript---delimited by curly
braces---are just expressions!

\evalsto{3 + \{1; 2; 3\}} {6}
%
This is similar to the {\tt begin}/{\tt end} blocks found in other
functional languages, or the ``comma operator'' sequencing construct
in C++.  Only the value of the last expression within the block is
returned, the other statements/expressions only bind variables or
perform side effects.

Note that this different convention makes semi-colon usage in
WaveScript somewhat unintuitive.  Within blocks, semi-colons are only
required as {\em separators}; they are permitted, but not required
after the last expression in the block.  Also, since curly-brace
delimited blocks are merely expressions, they sometimes must be
followed with a semi-colon, as below:\footnote{As a special case, when
a function body consists of curly braces, it needn't be followed by a semi-colon.}

%\vspace{-5mm}
\begin{verbatim}
        {
          foo;
          if b then {
            bar();
          } else {
            baz();
          };  <-- SEMICOLON REQUIRED
          done();
        }
\end{verbatim}

\rednote{[2007.03.09] Be wary that with the current parser, a
  semi-colon error may appear as a strange parse error in the next
  or previous line.}

%================================================================================
\subsection{Streams}

WaveScript is for stream-processing and it would be useless without
Streams.  
Streams in WaveScript are like any other values: bound to variables,
passed and returned from functions.
The primary means of operating on the data inside streams is the {\tt
  iterate} syntactic construct.

\begin{verbatim}
        S2 = iterate x in S1  {
          state{ counter = 0 }
          counter := counter + 1;
          emit counter + x;
        }
\end{verbatim}

The {\tt iterate} construct can be placed in any {\em expression
position}.  It produces a new stream by applying the supplied code to
every element of its input stream.  The above example executes the
body of the iterate every time data is received on the stream {\tt
  S1}, it adds an increasing quantity to each element of {\tt S1}, and the
resulting stream is bound to the variable {\tt S2}.

In addition to {\tt iterate} several library procedures (such as {\tt
stream\_map}) and many primitives (such as {\tt unionList}) operate on
{\tt Stream} values.  For example, {\tt merge} combines two streams of the same
type (their tuples interleaved in real time), whereas {\tt
  unionList} also combines streams of the same type, but tags all
output tuples with an integer index indicating from which of the input
streams it originated.


%========================================
\subsection{Defining functions}
\label{udfs}

Named functions can be defined at the top-level, or within a {\tt
  \{\ldots\}} block as follows:
\begin{verbatim}
       fun f(x,y) {
         z = x+y;
         sqrt(z)
       }
\end{verbatim}

The function body, following the argument list can be any expression.
Above it happens to be a statement block that returns the
square-root of {\tt z}.

Unnamed, or anonymous, functions can occur anywhere that an expression
might occur. In the following we pass an anonymous ``plus three''
function as the first input to {\tt stream\_map}.  Note that the body
of the function is a single expression, not a statement block, and is
not delimited by curly braces.

\begin{wscode}
stream\_map(fun(x) x+3, S)
\end{wscode}

%========================================
\subsection{Constructing complete programs}

A complete program file contains function and variable declarations.
As seen in Section~\ref{s:taste}, a special variable declaration
binds the name ``main'' to a stream:
%as well as a {\em stream wiring statement} of the form:
\begin{wscode}
main = stream-valued-expression;
\end{wscode}
%This wiring statement determines the stream of values returned as
%a result of running the program.
As a side-note, {\ws} can be called with a ``-ret foo'' flag to return
the stream ``foo'' instead of the stream ``main''.  This is frequently
useful for invoking testing entrypoints as well as the production
entrypoint for the program.  

Note also that {\em only} the returned stream is instantiated at runtime.
Other streams declared in the program will simply be ignored.  They
become dead code.


%================================================================================
\section{Datatypes}

This section goes over syntax and primitives for manipulating
built-in data structures.

\subsection{Tuples}

Tuples, or {\em product types}, are ordered sets of elements which can
each be of different types. 
\evalsto{(1,``hello'')}{A tuple of type {\tt (Int * String)}}
%\begin{wscode}
Tuples are accessed by a pattern-matching against them and binding
variable names to their constituent components.  This process is
described in section \ref{s:patterns}.

\subsection{Numbers}

WaveScript supports several different types of numbers.  \rednote{Currently,
this set includes Int, Int16, Int64, Float, Double, Complex, but it will be extended
to include 8-bit integers, unsigned integers, and complex-doubles.}
WaveScript includes generic numeric arithmetic operations ($+$, $-$,
$*$, $/$) that work for any numeric types, but must be used on two
numbers of the same type.  There are also type-specific numeric
operations that are not used frequently:

\[
\begin{array}{rcl}
%generic          & : & +,\; -,\; $*$,\; /,\; ^{\wedge}   \\
generic          & : & $\tt + - * / \^{}$   \\
Int              & : & $\tt +\_ -\_ *\_ /\_ \^{}\_ $ \\
Float            & : & $\tt +. -. *. /. \^{}. $ \\
Complex          & : & $\tt +: -: *: /: \^{}: $ \\
Int16            & : & $\tt +I16 -I16 *I16 /I16 \^{}I16 $   \\
Int64            & : & $\tt +I64 -I64 *I64 /I64 \^{}I64 $   \\
\end{array}
\]

Other numeric operations, such as {\tt abs} or {\tt sqrt}, follow the
naming convention {\tt absI} for integers, {\tt absF} for floats, {\tt
absC} for complex, and {\tt absI16} for 16-bit integers.
\rednote{Eventually, {\ws} will include a type-class facility which
  will simplify the treatment of numeric operations.}

% int, uint16, uint8, float, double, complex 

% Could just have NUMBER in the FIRST type check..
% Then type check again AFTER elaboration.
% (It would be really nice to keep source info....)

\subsection{Lists}

Lists can be written as constants and support the usual primitive
operations.  
\begin{verbatim}
      ls = [1, 2, 3];
      ls2 = head(ls):::ls;
      print(List:length(ls2)); // Prints '4'
      print(ls == []);         // Prints 'false'
\end{verbatim}

The {\tt :::} operator adds an element to the front of a list.  Also
use {\tt head}, {\tt tail}, {\tt List:reverse}, {\tt List:append} to operate on
lists.  

Other operations include, but are not limited to the following. {\tt
List:zip} combines two equal-length lists into a list of two-tuples.
{\tt List:map(f,ls)} returns a new list generated by applying the
function {\tt f} to each element of the input list.  {\tt
List:filter(pred,ls)} returns only those elements of the list that
satisfy {\tt pred}.  {\tt List:fold(op,init,ls)} reduces a list by
repeatedly applying {\tt op} to pairs of elements, for example, to sum
the elements of a list.  {\tt List:mapi(f,ls)} is a variant of map
that also passes the index of the element to the input function.  {\tt
List:foreach(f,ls)} applies a function to each element for side effect
only, not building a new list.  {\tt List:build(len, f)} builds a new
list, using a function (on index) to populate each position in the
list.

Many of these operators (map, filter, foreach, mapi, fold, build, etc) are used consistently
for different container types (lists, arrays, matrices, etc).

\subsection{Arrays}

Arrays are mutable and cannot currently be written as constants.  Use
{\em Array:make} to produce arrays, {\tt arr[i]} to access arrays, and
{\tt arr[i] = x;} to modify them.  Many array operations are analogous
to the list operations (map, fold, etc).  See the documentation for
additional primitives below.

%Refer to {\tt prim_defs.ss} for more array operations.

\subsection{Additional primitive functions}

Appendix~\ref{s:primtable} contains a table of all currently supported
{\ws} primitives, together with their type signatures.

For more documentation on these primitives, please refer to this file
within your working copy:
\vspace{-2mm}
\begin{center}
{\tt{wavescript/src/generic/\\compiler\_components/prim\_defs.ss}}
\end{center}

You can find the online documentation at:
\vspace{-2mm}
\begin{center}
\url{http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html}
\end{center}

%\htmladdnormallink {my Web page} {http://www.astro.ku.dk/\~{}milvang/}

%\htmladdnormallink{\tt{wavescript/src/generic/\\compiler\_components/prim\_defs.ss}}{http://regiment.us/codedoc/html/generic/compiler_components/prim_defs.ss}

%\htmladdnormallink{wavescript/src/generic/compiler\_components/prim\_defs.ss}{http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html}

This file contains type-signatures (and minimal documentation) for all built-in
wavescript primitives, many of which are not covered in this manual.
Within the online documentation linked above you should look at 
\htmladdnormallink{regiment-primitives}{http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#regiment-primitives}
which is defined in terms of 
\htmladdnormallink{regiment-basic-primitives}      {http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#regiment-basic-primitives},
\htmladdnormallink{regiment-distributed-primitives}{http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#regiment-distributed-primitives},
\htmladdnormallink{wavescript-primitives}          {http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#wavescript-primitives},
\htmladdnormallink{meta-only-primitives}           {http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#meta-only-primitives},
\htmladdnormallink{higher-order-primitives}        {http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#higher-order-primitives},
and
\htmladdnormallink{regiment-constants}             {http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#regiment-constants}~.

Please also examine the library files found in the {\tt wavescript/lib}
directory.  These files, for example {\tt ``stdlib.ws''} and {\tt
  ``matrix.ws''}, include library routines written in WaveScript.  As
a general design principle, it is best to implement as much as
possible in the language, while keeping the set of built-in primitives
relatively small.

For various historical reasons there are several primitives included
in the current primitive table that {\em should not} ultimately be
primitive.  These will eventually be removed and implemented instead
as library routines.  Likewise, there are certainly many additional
primitives that one might like to see incorporated as the language matures.


%================================================================================
\section{Type Annotations}

We have already seen several types in textual form within this manual:
{\tt Float}, {\tt (Int * String)} These are valid WaveScript types.
WaveScript also has compound types such as {\tt Sigseg (Array Int)}.

Similar to Haskell or ML, the user is permitted, but not generally
required to add explicit type annotations in the program.  For
example, we may annotate a function {$\tt f$} with its type by writing
the following.
%
\begin{verbatim}
        f :: (Type, Type) -> Type;
        fun f(x,y) { ... }
\end{verbatim}

Indeed, a type annotation may be attached to any expression with
the following syntax:
\begin{wscode}
(expression :: Type)
\end{wscode}

Further, type annotations may be added to variable declarations with:
\begin{wscode}
 var :: Type = expression;
\end{wscode}

In general, compound types may be built from other types in several
ways.  
\[
\begin{array}{rcl}
tuples           & : & $\tt (T1 * T2 * T3) $   \\
lists            & : & $\tt List T1 $ \\
arrays           & : & $\tt Array T1 $ \\
hashtables       & : & $\tt HashTable (T1,T2) $ \\
functions        & : & $\tt (T1, T2, T3) -> T4 $ \\
\end{array}
\]
Note that parentheses must be used when nesting type
constructors as in {\tt List (List T)}.

\rednote{[2007.03.09] In the future, the user will be able to create
  their own type definitions and type constructors, including
  tagged-union or {\em sum} types.}


\subsection{Reading data with readFile}

The one place where type annotations {\em are} currently mandated is
when importing data from a file.  This is done with the primitive {\tt
readFile}.
%
\begin{verbatim}
       BASE <- 
         (readFile("foo.txt", "") 
          :: Stream (Int16 * Float))
\end{verbatim}

The above complete program reads space-separated values from a text
file, one-tuple-per-line.  In this case, each tuple contains two
values: a 16 bit integer, and a floating point value.
The {\tt readFile} primitive may also be
used to read data from a file in blocks (Sigsegs), which is generally
more efficient.  All that is required is to specify a stream of
{\tt Sigseg} type, as follows.

\begin{verbatim}
       BASE <- 
         (readFile("foo.dat", 
                   "mode: binary  repeat: 3")
          :: Stream (Sigseg Int16))
\end{verbatim}

Also note that the second argument to {\tt readFile} is an option
string.  This string is parsed at compile time (during meta-program
evaluation).  The string must contain a (space separated) list of
alternating option names and option values.  The following are the
available options, and their default values.

\begin{itemize}
\item {\bf mode:} one of 'text' or 'binary' (default {\bf 'text'})

\item {\bf repeats:} a number specifying whether to replay the file's
  contents when the end of file is reached.  Set to a non-negative
  integer to specify the number of repeats, or to {\bf -1} to repeat
  indefinitely.  (default {\bf 0})

\item {\bf rate:} the rate (in tuples per second) to play the back the
  data from the file.  For the emulator, this refers to virtual time,
  and is used only to maintain relative timing of different data
  streams.  Note that this is orthogonal to windowing; whether data is
  windowed or not, the rate will be interpreted in the same
  way. (default {\bf 1000}) 

\item {\bf offset:}
  The offset, in bytes, at which to start reading from the
  file. (default {\bf 0})

\item {\bf skipbytes:}
The number of bytes to skip between reading each tuple
  from the data file. (default {\bf 0})

\item {\bf window:} If the output stream is blocked into Sigsegs
  (windows), this parameter determines the size of each
  Sigseg. (default {\bf 1})

\end{itemize}


%%  and reads them at a virtual ``rate'' of
%% 44Khz (this is important for the relative timing of different
%% streams).  Finally, the last number is the replay argument.  If it's greater
%% than zero, {\tt dataFile} will replay the data that many times after
%% reading the file.  If the replay value is $-1$, then the data will be
%% replayed indefinitely.



%================================================================================
\subsection{Type Aliases}

Because types can grow large and complex, it is often helpful to
define aliases, or shorthands, similar to C/C++'s {\tt typedef}s.

\begin{center}
\begin{verbatim}
       type MyType        = List Int;
       type MyType2  t    = Stream (List t);
       type MyType3 (x)   = List (x);
       type MyType4 (x,y) = List (x * y);

       x :: MyType;
       x = [3];

       s1 :: MyType2 Int;
       ...
\end{verbatim}
\end{center}


%================================================================================
\section{Sigsegs}

Sigsegs are a flexible ADT for representing windows of samples on a stream.
Please refer to the CIDR'07 publication with the title
``The Case for a Signal-Oriented Data Stream Management System'' for
details.  Also check {\tt prim\_defs.ss} for the specific names and
type signatures of the Sigseg primitives.

% smap$((+3))
% smap(f$(x), S)
%%  ls.List:ref(i)
%%  ls.list:ref(i)

%% list:ref 
%% List:ref 

%% list|ref 

%% ls.List|ref(i)


%% namespace Matrix {
  
%% }

%% Matrix:make
%% Array:make

%% using Matrix;




%================================================================================
\section{Namespaces}

WaveScript, while not having a sophisticated module system, does
include a simple system for managing namespaces.

\begin{center}
\begin{verbatim}
      namespace Foo {
        x = ...;
        y = ...;
      }
      var = Foo:x + Foo:y;
      fun f() {
        using Foo;
        var = x + y;
      }
\end{verbatim}
\end{center}


%================================================================================
\section{Patterns}
\label{s:patterns}

WaveScript allows pattern matching in addition to plain variable-
In any variable-binding position it is valid to use a pattern rather
than a variable name---this includes the arguments to a function, a
local variable binding, or the variable binding within an {\tt
 iterate} construct.  Currently, patterns are used to bind names
to the interior parts of tuples.  In the future, we will support list
patterns, and tagged union patterns.  

Let's look at an example.
We saw how to bind variables in WaveScript:
\begin{center}
{\tt \bf{z} = (1,2);}
\end{center}
This binds {\tt z} to a tuple containing two elements.  
This is actually a shorthand for the more verbose syntax:
\begin{center}
{\tt let \bf{z} = (1,2);}
\end{center}

An unfortunate limitation of the parser is that {\tt 'let'} cannot be
omitted if we a pattern is used in place of a simple identifier.  The
following binds the individual components of the tuple by using a
pattern in place of the variable {\tt 'z'}:
\begin{center}
{\tt let \bf{(x,y)} = (1,2);}
\end{center}

Similarly, we may use patterns within a function's argument list.  Here's
a function that takes a 2-tuple as its second argument:

\begin{center}
{\tt {\bf fun} foo (x,\bf{(y,z)}) \{ \dots \}}
\end{center}


%================================================================================
\section{Syntactic Sugar}

Syntactic sugars are convenient shorthands that are implemented by the
parser and make programming in WaveScript more convenient (at the risk
of making reading code more difficult for the uninitiated).

%\noindent {\bf Dot syntax:}
\subsection{Dot syntax}
  For convenience, functions can be applied using an
alternative ``dot syntax''.  For example rather than taking the first
element of a list with ``{\cd head(ls)}'', we can write ``{\cd ls.head}''.
This generalizes to functions of more than one argument; only the
first argument is moved before the dot.  For example, 
\vspace{-2mm}
\begin{wscode}
List:ref(ls,i)
\end{wscode}
\vspace{-2mm}
 may be written as 
\vspace{-2mm}
\begin{wscode}
ls.List:ref(i)
\end{wscode}
\vspace{-2mm}
This is useful because many functions on data structures take the
data structure itself as their first argument.  Thus it is concise to
write the following:
\vspace{-2mm}
\begin{wscode}
ls.tail.tail.head
\end{wscode}
\vspace{-2mm}


\subsection{\$: ``Unary parentheses''}

The ``\$'' operator for procedure application is taken from Haskell
and sometimes called the ``unary parenthesis''.  Instead of {\cd
  f(g(x))}, we write ``{\cd f \$ g \$ x}''.
This is useful if you have a large expression spanning many lines to
which you want to apply a function:
\begin{verbatim}
   iterate x in strm { 
      (many lines) ... 
\end{verbatim}
We can apply a function {\cd myfunction} without scrolling down to
insert a close parenthesis:
\begin{verbatim}
   myfunction $
   iterate x in strm { 
      (many lines) ... 
\end{verbatim}


\subsection{Stream Projectors}

WaveScript also includes a syntax for binding streams of tuples in a
 way that associates a projector function for each of
the tuples' fields.  For example:

\begin{wscode}
S as (a,b) = someStream;
\end{wscode}

Subsequently, ``{\tt S.(a)}'' or ``{\tt S.(a,b,a)}'' can be used to
project a new stream where each tuple represents an arrangement of
the fields within each tuple in {S}.  If used in conjunction with the
type-annotation syntax, note that the ``{\tt as}'' clause must go first:

\begin{wscode}
S as (a,b) :: Stream(Int * Float) = someStream;
\end{wscode}


\input{foreign.tex}
\input{libraries.tex}

%================================================================================

\chapter{WaveScript Evaluation Model}

WaveScript is a {\em metaprogramming} language.  For further
explanation, I'll refer you to a quote from the {\em Matrix Reloaded}
that was brought to my attention by Yannis Smaragdakis.

\begin{center}
NEO: Programs hacking programs. Why?

ORACLE: They have their reasons, ...
\end{center}

The {\em reason} in WaveScript, is that we want to write programs of a
different character than we want to {\em run}.  We call this {\em asymmetric metaprogramming}.
We want to {\em write}
abstract, reusable, polymorphic, higher-order programs, but we want to
{\em run} fast, monomorphic, first-order, C-programs representing
parallelizable dataflow graphs.
In WaveScript your program essentially {\em
generates} the specialized, high-performance stream-processing
program that is subsequently compiled and run.  


How does this work?  Currently {\em all} user defined functions (as
described in section \ref{udfs}) {\bf will be inlined at metaprogram
evaluation}.  What results is a dataflow graph of {\tt iterate} blocks.
Thus, only bounded-recursions are permitted in user defined functions,
and excessive code bloat becomes a real possibility.  In the future, we will
allow a ``noinline'' or ``library function'' annotation that specifies
that a function is to be compiled as a C-function, rather than
inlined.  Of course, such a function will not be allowed to take or
return {\tt Stream} values.

\rednote{\em \bf Keep the metaprogram pure for now! (free of side-effects)}

\chapter{WaveScript Execution Model}

After the metaprogram evaluates, what is left is a dataflow graph of
stream operators (kernels).  Now you may ask: what are the semantics
of this dataflow graph's execution?  WaveScript implements an {\em
asynchronous dataflow} model.  Streams are sequences discrete events,
with no implied synchronization.  Stream kernels are thus
event-handlers.  Further, the order of evaluation of kernels within a
data flow graph is entirely at the whim of the scheduler, subject to
loose fairness constraints.  Any kernel with input data available is
{\em ready} and may execute at any time; yet no ready kernel may
execute an infinite number of times without all other ready kernels
executing.

\rednote{Other guarantees?  There was supposed to be one more...}

Of course, in practice we have slightly stronger expectations of the
scheduler.  We expect that it is reasonably well engineered, and does not
follow perverse practices regarding fairness.  For example,
depth-first traversals

However, ultimately, computations must be robust to the timing of the
communication channels between kernels.  After all, the program may be
distributed, with some channels going over slow wireless links, and
other channels intra-node.  How do we accomplish this?  Well, we rely
on well-engineered libraries to insulate programmers from as much of
the pain of asynchronicity as possible.

\rednote{TODO: go over and expand this}

\section{Debugging}

\rednote{TODO}

%% pos#0: 
%% seg-get: index 474 is out of bounds for sigseg:
%% #<struct:sigseg>

%%  === context ===
%% /Users/newton/wavescript/src/generic/sim/wavescript_sim_library_push.ss:1314:5: seg-get
%% /Users/newton/temp/__lang_running.tmp.ss:359:30
%% /Users/newton/wavescript/src/generic/sim/wavescript_sim_library_push.ss:357:6: wsbox
%% /Users/newton/wavescript/src/generic/sim/wavescript_sim_library_push.ss:282:13: global-loop



\end{document}
