
%\documentstyle[refman.sty]{article}
%\documentstyle[twocolumn]{report}
\documentclass[twocolumn]{report}
\usepackage{color}
%\usepackage{code}


\setlength{\textheight}{9.25in}
\setlength{\columnsep}{0.25in} %RRN changed: {0.33in}
\setlength{\textwidth}{7.4in}
\setlength{\footskip}{0.0in}
\setlength{\topmargin}{-0.25in}
\setlength{\headheight}{0.0in}
\setlength{\headsep}{0.0in}
\setlength{\oddsidemargin}{-.45in}
\setlength{\parindent}{1pc}


% page size commands

\title{WaveScript 0.1 Users Manual}

\newcommand{\rednote}[1]{{\textcolor{blue}{#1}}}
%\newcommand{\rednote}[1]{{\em \bf{}}}

\newcommand{\evalsto}[2]{\[ \begin{array}{rcl}
$\tt #1 $&$ \arr $&$ #2 $
\end{array} \]}

\newcommand{\arr}{\ensuremath{\rightarrow}}

\newcommand{\cd}{\tt}


\newenvironment{wscode}{\begin{center}\tt}{\end{center}}

\begin{document}

\maketitle

% title page commads

\pagenumbering{arabic}
\tableofcontents
\clearpage

\chapter{Introduction}

WaveScript is a functional metaprogramming language for writing highly abstract
programs that generate efficient dataflow graphs.  These graphs are
executable in an emulator (ws) or by compiling to C++ (wsc) and linking them
to the {\em XStream} engine.

\section{Using WaveScript}

See the README for install instructions.  The bottom line is that you
will need Mzscheme and Petite Chez Scheme to run the WaveScript
emulator.  (Petite for Linux is included in the repository.)  You will
need Boost, the Gnu Scientific Library (GSL), FFTW, and their
respective headers to run {\bf wsc}-compiled code.

Once the system is installed you should be able to execute {\tt ws} or
{\tt wsc} on any WaveScript source files ({\tt .ws} files).

\subsection*{Develop Incrementally}

WaveScript is still very much a prototype.  It doesn't offer the same
level of support that you expect from production-quality
compilers.  For example, the compiler doesn't track code locations.
It will often print the surrounding context of an error (in abstract
syntax), but nothing more.

Therefore it helps to build your program bit by bit.  Compile often to make
sure that the pieces of your program parse and type-check.

{\tt \bf wsparse:}
If you want the full error message for a stubborn parser error, run
{\tt wsparse} directly on the ws file.  It will either print the AST
(abstract syntax tree) for the file, or will give you an error message
that does include line and character numbers.

\subsection{The WaveScript Emulator: {\tt \bf ws} }

Running {\tt ws} on a WaveScript file will simulate the functionality
of the query without actually compiling the query to C++ code.  The
query is converted to a Scheme program which is compiled to native
code and executed on the fly.  Hardware sensors cannot be accessed,
and so data must be read from trace files.

\subsubsection*{Consider {\tt \bf ws.opt} for high-performance emulation}

The first thing to do to improve the performance of {\tt ws} is make
sure that you have the full version of Chez Scheme.  This version
includes the incremental native code compiler.  If you are using the
free, Petite Chez Scheme interpreter, your {\tt .ws} query files will
be converted to {\em interpreted} Scheme code, which runs considerably
slower.  The executable {\tt chez} should be in your path.

To go further, you might consider runnig {\tt ws.opt} in place of {\tt
ws}.  First, {\tt ws.opt} has debugging assertions disabled. 
Second, {\tt ws.opt} is compiled in the highest Chez Scheme optimize
level, and also compiles your query in this higher optimize level.
However, this optimize level is dangerous in that it omits various
checks necessary to maintaining type safety.  Thus the process can
crash if there's an error, or memory can become corrupted (just like
C/C++).  Therefore, debug your code using {\tt ws} first.

\subsubsection*{Run {\tt \bf ws.debug} occasionally for sanity-checking}

Ws.debug is too slow for the normal development cycle, but t is
important to occasionally compile your program with ws.debug.  Mainly
this is important for building confidence that the compiler is
behaving properly on your program.  If the
compiler were a mature system not under active development, this would
not be as important.  When you run {\bf ws.debug} the compiler runs
extensive invariant checks on the data structures it uses, in
particular it checks the intermediate forms between compiler passes
for conformance to explicit grammars.  Further it inserts extra
type-checks to make sure that the intermediate programs are
well-formed.

\subsection{The WaveScript Compiler: {\tt \bf wsc}}

The WaveScript emulator provides a reference implementation suitable
to prototyping and debugging applications.  The eventual target is to
generate an efficient C++ program from the WaveScript source.  This is
accomplished with the {\bf wsc} compiler.  In practice, as WaveScript
undergoes development, the {\bf wsc} compiler often lags behind the {\bf ws}
emulator in terms of features and functionality.  Again, develop
incrementally, refer to {\tt wavescript/demos/wavescope} for programs that
should work with {\bf wsc}.

Refer to the XStream documentation\footnote{\rednote{[2007.03.09] Currently nonexistent}} 
for information on how to configure the XStream engine
(number of threads, scheduling policy, etc)).

\rednote{[2007.03.09] Ideally the output from the XStream-executed
query would be the same as the emulator output.  Currently, however, there are
some basic disparities in how objects are printed to text form.  Hopefully, these
are straightforward to work around, and should go away shortly.}








%================================================================================
\chapter{Language Basics}

Please make liberal use of {\tt wavescript/demos/wavescope/*.ws} as a reference
when learning WaveScript.  These demos cover most of the basic
functionality in the language.

%\section{Naming conventions}
%\chapter{Basics}

WaveScript is a functional language with many similarities to ML or
Haskell.  Functions are values.  The language is strongly typed and uses a
type-inference algorithm to infer types from variable usages.
It provides the usual basic datatypes, including various
numeric types, strings, lists, arrays, hash tables as well as the more
WaveScript-specific Streams and Sigsegs.  Valid {\em expressions} in
WaveScript are written much as in C.
\[
\begin{array}{rcl}
arithmetic       & : & $\tt 3 + 4 * 10 $  \\
function\; calls & : & $\tt f(x, y)$  \\
blocks           & : & $\tt \{ e$_1$; e$_2$; \ldots$\:$ e$_n$ \}$  \\
\end{array}
\]

But there are also many syntactic differences from C.  For example,
WaveScript doesn't have a sharp division between commands and
expressions.  Conditionals use a different syntax and are valid in
{\em any}
expression position.
%
\evalsto{3 + (if true then 1 else 2)} {4}
%
Moreover, {\em blocks} in WaveScript---delimited by curly
braces---are just expressions!

\evalsto{3 + \{1; 2; 3\}} {6}
%
This is similar to the {\tt begin}/{\tt end} blocks found in other
functional languages, or the ``comma operator'' sequencing construct
in C++.  Only the value of the last expression within the block is
returned, the other statements/expressions only bind variables or
perform side effects.

Note that this different convention makes semi-colon usage in
WaveScript somewhat un-intuitive.  Within blocks, semi-colons are only
required as {\em separators}; they are permitted, but not required
after the last expression in the block.  Also, since curly-brace
delimited blocks are merely expressions, they sometimes must be
followed with a semi-colon, as below:\footnote{As a special case, when
a function body consists of curly braces, it needn't be followed by a semi-colon.}

%\vspace{-5mm}
\begin{verbatim}
        {
          foo;
          if b then {
            bar();
          } else {
            baz();
          };  <-- SEMICOLON REQUIRED
          done();
        }
\end{verbatim}

\rednote{[2007.03.09] Be wary that with the current parser, a
  semi-colon error may appear as a strange parse error in the next
  or previous line.}

\subsection{Constructing complete programs}

A complete program file contains function and variable
declarations as well as a single {\em stream wiring statement} of the form:
\begin{wscode}
BASE <- expression;
\end{wscode}
This wiring statement determines the stream of values returned as
a result of running the program.



%================================================================================
\section{Datatypes}

This section goes over syntax and primitives for manipulating
built-in data structures.

\subsection{Tuples}

Tuples, or {\em product types}, are ordered sets of elements which can
each be of different types. 
\evalsto{(1,``hello'')}{A tuple of type {\tt (Int * String)}}
%\begin{wscode}
Tuples are accessed by a pattern-matching against them and binding
variable names to their constituent components.  This process is
described in section \ref{s:patterns}.

\subsection{Numbers}

WaveScript supports several different types of numbers.  \rednote{Currently,
this set includes Int, Int16, Float, Complex, but it will be extended
to include 8-bit integers, unsigned integers, doubles, and complex-doubles.}
WaveScript includes generic numeric arithmetic operations ($+$, $-$,
$*$, $/$) that work for any numeric types, but must be used on two
numbers of the same type.  There are also type-specific numeric
operations that are not used frequently:

\[
\begin{array}{rcl}
%generic          & : & +,\; -,\; $*$,\; /,\; ^{\wedge}   \\
generic          & : & $\tt + - * / \^{}$   \\
Int              & : & $\tt +. -. *. /. \^{}. $ \\
Float            & : & $\tt +. -. *. /. \^{}. $ \\
Complex          & : & $\tt +: -: *: /: \^{}: $ \\
Int16            & : & $\tt +I16 -I16 *I16 /I16 \^{}I16 $   \\
\end{array}
\]

Other numeric operations, such as {\tt abs} or {\tt sqrt}, follow the
naming convention {\tt absI} for integers, {\tt absF} for floats, {\tt
absC} for complex, and {\tt absI16} for 16-bit integers.

% int, uint16, uint8, float, double, complex 

% Could just have NUMBER in the FIRST type check..
% Then type check again AFTER elaboration.
% (It would be really nice to keep source info....)

\subsection{Lists}

Lists can be written as constants and support the usual primitive
operations.  
\begin{verbatim}
      ls = [1, 2, 3];
      ls2 = head(ls):::ls;
      print(List:length(ls2)); // Prints '4'
      print(ls == []);         // Prints 'false'
\end{verbatim}

The {\tt :::} operator adds an element to the front of a list.  Also
use {\tt head}, {\tt tail}, {\tt reverse}, {\tt append} to operate on
lists. 

\subsection{Arrays}

Arrays are mutable and cannot currently be written as constants.  Use
{\em makeArray} to produce arrays, {\tt arr[i]} to access arrays, and
{\tt arr[i] = x;} to modify them.

%Refer to {\tt prim_defs.ss} for more array operations.

\subsection{Additional primitive functions}

Please refer to the file 
\vspace{-2mm}
\begin{center}
{\tt{wavescript/src/generic/\\compiler\_components/prim\_defs.ss}}
\end{center}
%
for type-signatures (and minimal documentation) for all built-in
wavescript primitives, many of which are not covered in this manual.

Please also examine the library files found in the {\tt wavescript/lib}
directory.  These files, for example {\tt ``stdlib.ws''} and {\tt
  ``matrix.ws''}, include library routines written in WaveScript.  As
a general design principle, it is best to implement as much as
possible in the language, while keeping the set of built-in primitives
relatively small.


%================================================================================
\section{User defined functions}

Named functions can be defined at the top-level, or within a {\tt
  \{\ldots\}} block as follows:

\begin{verbatim}
       fun f(x,y) {
         z = x+y;
         sqrt(z)
       }
\end{verbatim}

The function body, following the argument list can be any expression.
Above it just happens to be a statement block that returns the
square-root of {\tt z}.

Unnamed, or anonymous, functions can occur anywhere that an expression
might occur. In the following we pass the anonymous ``plus three''
function as th efirst input to {\tt stream\_map}.  Note that the body
of the function is a single expression, not a statement block, and is
not delimited by curly braces.

\begin{wscode}
stream\_map(fun(x) x+3, S)
\end{wscode}




%================================================================================
\section{Type Annotations}

We have already seen several types in textual form within this manual:
{\tt Float}, {\tt (Int * String)} These are valid WaveScript types.
WaveScript also has compound types such as {\tt Sigseg (Array Int)}.

Similar to Haskell or ML, the user is permitted, but not generally
required to add explicit type annotations in the program.  For
example, we may annotate a function {$\tt f$} with its type by writing
the following.
%
\begin{verbatim}
        f :: (Type, Type) -> Type;
        fun f(x,y) { ... }
\end{verbatim}

Indeed, a type annotation may be attached to any expression with
the following syntax:
\begin{wscode}
(expression :: Type)
\end{wscode}

Further, type annotations may be added to variable declarations with:
\begin{wscode}
 var :: Type = expression;
\end{wscode}

In general, compound types may be built from other types in several
ways.  
\[
\begin{array}{rcl}
tuples           & : & $\tt (T1 * T2 * T3) $   \\
lists            & : & $\tt List T1 $ \\
arrays           & : & $\tt Array T1 $ \\
hashtables       & : & $\tt HashTable (T1,T2) $ \\
functions        & : & $\tt (T1, T2, T3) -> T4 $ \\
\end{array}
\]
Note that parentheses must be used when nesting type
constructors as in {\tt List (List T)}.

\rednote{[2007.03.09] In the future, the user will be able to create
  their own type definitions and type constructors, including
  tagged-union or {\em sum} types.}


\subsection{Reading data with dataFile}

The one place where type annotations {\em are} currently mandated is
when importing data from a file.  This is done with the primitive {\tt
datafile}.
%
\begin{verbatim}
BASE <- 
  (dataFile("./countup.txt", "text", 44000, 0) 
   :: Stream (Int16 * Float))
\end{verbatim}

The above complete program reads space-separated values from a text
file, one-tuple-per-line, and reads them at a virtual ``rate'' of
44Khz (this is important for the relative timing of different
streams).  Finally, the last number is the replay argument.  If it's greater
than zero, {\tt dataFile} will replay the data that many times after
reading the file.  If the replay value is $-1$, then the data will be
replayed indefinitely.





%================================================================================
\section{Streams}

WaveScript is for stream-processing and it would be useless without
Streams.  
Streams in WaveScript are like any other values: bound to variables,
passed and returned from functions.
The primary means of operating on the data inside streams is the {\tt
  iterate} syntactic construct.

\begin{verbatim}
        S2 = iterate( x in S1 ) {
          state{ counter = 0 }
          counter := counter + 1;
          emit counter + x;
        }
\end{verbatim}

The {\tt iterate} construct can be placed in any {\em expression}
position.  It produces a new stream by applying the supplied code to
every element of its input stream.  The above example executes the
body of the iterate every time data is received on the stream {\tt
  S1}, it adds an increasing quantity to each element of {\tt S1}, and the
resulting stream is bound to the variable {\tt S2}.

In addition to {\tt iterate} several library procedures (such as {\tt
stream\_map}) and many primitives (such as {\tt unionList}) operate on
{\tt Stream} values.





%================================================================================
\section{Sigsegs}

Sigsegs are a flexible ADT for representing windows of samples on a stream.
Please refer to the CIDR'07 publication by the title 
``The Case for a Signal-Oriented Data Stream Management System'' for
details.  Also check {\tt prim\_defs.ss} for the specific names and
type signatures of the Sigseg primitives.

% smap$((+3))
% smap(f$(x), S)
%%  ls.List:ref(i)
%%  ls.list:ref(i)

%% list:ref 
%% List:ref 

%% list|ref 

%% ls.List|ref(i)


%% namespace Matrix {
  
%% }

%% Matrix:make
%% Array:make

%% using Matrix;




%================================================================================
\section{Namespaces}

WaveScript, while not having a sophisticated module system, does
include a simple system for managing namespaces.

\begin{center}
\begin{verbatim}
      namespace Foo {
        x = ...;
        y = ...;
      }
      var = Foo:x + Foo:y;
      fun f() {
        using Foo;
        var = x + y;
      }
\end{verbatim}
\end{center}




%================================================================================
\section{Patterns}
\label{s:patterns}

WaveScript allows pattern matching in addition to plain variable-
In any variable-binding position it is valid to use a pattern rather
than a variable name---this includes the arguments to a function, a
local variable binding, or the variable binding within an {\tt
 iterate} construct.  Currently, patterns are used to bind names
to the interior parts of tuples.  In the future, we will support list
patterns, and tagged union patterns.  

Let's look at an example.
We saw how to bind variables in WaveScript:
\begin{center}
{\tt \bf{z} = (1,2);}
\end{center}
This binds {\tt z} to a tuple containing two elements.  
This is actually a shorthand for the more verbose syntax:
\begin{center}
{\tt let \bf{z} = (1,2);}
\end{center}

An unfortunate limitation of the parser is that {\tt 'let'} cannot be
omitted if we a pattern is used in place of a simple identifier.  The
following binds the individual components of the tuple by using a
pattern in place of the variable {\tt 'z'}:
\begin{center}
{\tt let \bf{(x,y)} = (1,2);}
\end{center}

Similarly, we may use patterns within a function's argument list.  Here's
a function that takes a 2-tuple as its second argument:

\begin{center}
{\tt {\bf fun} foo (x,\bf{(y,z)}) \{ \dots \}}
\end{center}


%================================================================================
\section{Syntactic Sugar}

Syntactic sugars are convenient shorthands that are implemented by the
parser and make programming in WaveScript more convenient (at the risk
of making reading code more difficult for the uninitiated).

%\noindent {\bf Dot syntax:}
\subsection{Dot syntax}
  For convenience, functions can be applied using an
alternative ``dot syntax''.  For example rather than taking the first
element of a list with ``{\cd head(ls)}'', we can write ``{\cd ls.head}''.
This generalizes to functions of more than one argument; only the
first argument is moved before the dot.  For example, 
\vspace{-2mm}
\begin{wscode}
List:ref(ls,i)
\end{wscode}
\vspace{-2mm}
 may be written as 
\vspace{-2mm}
\begin{wscode}
ls.List:ref(i)
\end{wscode}
\vspace{-2mm}
This is useful because many functions on data structures take the
data structure itself as their first argument.  Thus it is concise to
write the following:
\vspace{-2mm}
\begin{wscode}
ls.tail.tail.head
\end{wscode}
\vspace{-2mm}

\subsection{Stream Projectors}

WaveScript also includes a syntax for binding variables to
Stream-of-tuple values that binds projector functions for each of
the tuples' fields.  For example:

\begin{wscode}
S as (a,b) = someStream;
\end{wscode}

Subsequently, ``{\tt S.(a)}'' or ``{\tt S.(a,b,a)}'' can be used to
project-out a new stream where each tuple represents an arrangement of
the fields within each tuple in {S}.  If used in conjunction with the
type-annotation syntax, note that the ``{\tt as}'' clause must go first:

\begin{wscode}
S as (a,b) :: Stream(Int * Float) = someStream;
\end{wscode}




\chapter{Signal Processing Libraries}

\section{Fourier Transforms}

WaveScript uses fftw.

\section{Matrix Operations}

WaveScript uses the Gnu Scientific Library to support matrix operations.

\rednote{[2007.03.09] Currently, GSL is only used for a builtin matrix
  inversion, {\tt m\_invert}}, 

\chapter{WaveScript Evaluation Model}

\rednote{\em \bf Keep the metaprogram pure! (free of side-effects)}

\end{document}
