
%\documentstyle[refman.sty]{article}
%\documentstyle[twocolumn]{report}
\documentclass[twocolumn]{report}
\usepackage{color}
%\usepackage{code}

\usepackage{hyperref}


\setlength{\textheight}{9.25in}
\setlength{\columnsep}{0.25in} %RRN changed: {0.33in}
\setlength{\textwidth}{7.4in}
\setlength{\footskip}{0.0in}
\setlength{\topmargin}{-0.25in}
\setlength{\headheight}{0.0in}
\setlength{\headsep}{0.0in}
\setlength{\oddsidemargin}{-.45in}
\setlength{\parindent}{1pc}


% page size commands

\title{WaveScript 0.1.3 Users Manual}

\newcommand{\rednote}[1]{{\textcolor{blue}{#1}}}
%\newcommand{\rednote}[1]{{\em \bf{}}}

\newcommand{\evalsto}[2]{\[ \begin{array}{rcl}
$\tt #1 $&$ \arr $&$ #2 $
\end{array} \]}

\newcommand{\arr}{\ensuremath{\rightarrow}}

\newcommand{\cd}{\tt}


\newenvironment{wscode}{\begin{center}\tt}{\end{center}}

\begin{document}

\maketitle

% title page commads

\pagenumbering{arabic}
\tableofcontents
\clearpage

\chapter{Introduction}

WaveScript is a functional metaprogramming language for writing highly abstract
programs that generate efficient dataflow graphs.  These graphs are
executable in an emulator (ws) or by compiling to C++ (wsc) and linking them
to the {\em XStream} engine.

\section{Using WaveScript}

See the README for install instructions.  The bottom line is that you
will need Mzscheme and Petite Chez Scheme to run the WaveScript
emulator.  (Petite for Linux is included in the repository.)  You will
need Boost, the Gnu Scientific Library (GSL), FFTW, and their
respective headers to run {\bf wsc}-compiled code.

Once the system is installed you should be able to execute {\tt ws} or
{\tt wsc} on any WaveScript source files ({\tt .ws} files).

\subsection*{Develop Incrementally}

WaveScript is still very much a prototype.  It doesn't offer the same
level of support that you expect from production-quality
compilers.  Sometimes the error messages might be difficult to
interpret.  (However, the type checker messages have been improved
immensely and do include code locations [04/08/2007].)

Therefore it helps to build your program bit by bit.  Compile often to make
sure that the pieces of your program parse and type-check.

{\tt \bf wsparse:}
If you want the full error message for a stubborn parser error, run
{\tt wsparse} directly on the ws file.  It will either print the AST
(abstract syntax tree) for the file, or will give you an error message
that does include line and character numbers.

\subsection{The WaveScript Emulator: {\tt \bf ws} }

Running {\tt ws} on a WaveScript file will simulate the functionality
of the query without actually compiling the query to C++ code.  The
query is converted to a Scheme program which is compiled to native
code and executed on the fly.  Hardware sensors cannot be accessed
from the emulator (except through the foreign interface \ref{s:foreign}), 
and so data must be read from trace files.

\subsubsection*{Consider {\tt \bf ws.opt} for high-performance emulation}

The first thing to do to improve the performance of {\tt ws} is make
sure that you have the full version of Chez Scheme.  This version
includes the incremental native code compiler.  If you are using the
free, Petite Chez Scheme interpreter, your {\tt .ws} query files will
be converted to {\em interpreted} Scheme code, which runs considerably
slower.  The executable {\tt chez} should be in your path.

To go further, you might consider running {\tt ws.opt} in place of {\tt
ws}.  First, {\tt ws.opt} has debugging assertions disabled. 
Second, {\tt ws.opt} is compiled in the highest Chez Scheme optimize
level, and also compiles your query in this higher optimize level.
However, this optimize level is dangerous in that it omits various
checks necessary to maintaining type safety.  Thus the process can
crash if there's an error, or memory can become corrupted (just like
C/C++).  Therefore, debug your code using {\tt ws} first.

\subsubsection*{Run {\tt \bf ws.debug} occasionally for sanity-checking}

Ws.debug is too slow for the normal development cycle, but it is
important to occasionally compile your program with ws.debug.  Mainly
this is important for building confidence that the compiler is
behaving properly on your program.  If the
compiler were a mature system not under active development, this would
not be as important.  


Specifically, when you run {\tt ws.debug}:

\begin{enumerate}
\item It turns on extra ASSERT statements in the code that check data
structure invariants to help ensure proper operation.

\item It dumps the whole program at several points in the
  compilation to files such as ``.\_\_elaboratedprog.ss''.  It can be
  helpful to look at these for debugging.

\item It includes additional type checks of the entire program between
  passes (regular {\tt ws} type checks several times, but {\tt
  ws.debug} does more).  This helps expose compiler bugs.

\item Finally, it does ``grammar checks'' on the output of each compiler
  pass. Each pass includes a BNF grammar that describes its output.
  {\tt ws.debug} mechanically checks to make sure every intermediate
  expression conforms to the appropriate grammar.  Again, this helps
  to expose compiler bugs.
\end{enumerate}

%When you run {\bf ws.debug} the compiler runs extensive
%invariant checks on the data structures it uses, in particular it
%checks the intermediate forms between compiler passes for
%conformance to explicit grammars.  Further it inserts extra
%type-checks to make sure that the intermediate programs are well-formed.

\subsection{The WaveScript Compiler: {\tt \bf wsc}}

The WaveScript emulator provides a reference implementation suitable
to prototyping and debugging applications.  The eventual target is to
generate an efficient C++ program from the WaveScript source.  This is
accomplished with the {\bf wsc} compiler.  In practice, as WaveScript
undergoes development, the {\bf wsc} compiler often lags behind the {\bf ws}
emulator in terms of features and functionality.  Again, develop
incrementally, refer to {\tt wavescript/demos/wavescope} for programs that
should work with {\bf wsc}.

Refer to the XStream documentation\footnote{\rednote{[2007.03.09] Currently nonexistent}} 
for information on how to configure the XStream engine
(number of threads, scheduling policy, etc)).

\rednote{[2007.03.09] Ideally the output from the XStream-executed
query would be the same as the emulator output.  Currently, however, there are
some basic disparities in how objects are printed to text form.  Hopefully, these
are straightforward to work around, and should go away shortly.}








%================================================================================
\chapter{Language Basics}

Please make liberal use of {\tt wavescript/demos/wavescope/*.ws} as a reference
when learning WaveScript.  These demos cover most of the basic
functionality in the language.

%\section{Naming conventions}
%\chapter{Basics}

WaveScript is a functional language with many similarities to ML or
Haskell.  Functions are values.  The language is strongly typed and uses a
type-inference algorithm to infer types from variable usages.
It provides the usual basic datatypes, including various
numeric types, strings, lists, arrays, hash tables as well as the more
WaveScript-specific Streams and Sigsegs.  Valid {\em expressions} in
WaveScript are written much as in C.
\[
\begin{array}{rcl}
arithmetic       & : & $\tt 3 + 4 * 10 $  \\
function\; calls & : & $\tt f(x, y)$  \\
blocks           & : & $\tt \{ e$_1$; e$_2$; \ldots$\:$ e$_n$ \}$  \\
\end{array}
\]

But there are also many syntactic differences from C.  For example,
WaveScript doesn't have a sharp division between commands and
expressions.  Conditionals use a different syntax and are valid in
{\em any}
expression position.
%
\evalsto{3 + (if true then 1 else 2)} {4}
%
Moreover, {\em blocks} in WaveScript---delimited by curly
braces---are just expressions!

\evalsto{3 + \{1; 2; 3\}} {6}
%
This is similar to the {\tt begin}/{\tt end} blocks found in other
functional languages, or the ``comma operator'' sequencing construct
in C++.  Only the value of the last expression within the block is
returned, the other statements/expressions only bind variables or
perform side effects.

Note that this different convention makes semi-colon usage in
WaveScript somewhat unintuitive.  Within blocks, semi-colons are only
required as {\em separators}; they are permitted, but not required
after the last expression in the block.  Also, since curly-brace
delimited blocks are merely expressions, they sometimes must be
followed with a semi-colon, as below:\footnote{As a special case, when
a function body consists of curly braces, it needn't be followed by a semi-colon.}

%\vspace{-5mm}
\begin{verbatim}
        {
          foo;
          if b then {
            bar();
          } else {
            baz();
          };  <-- SEMICOLON REQUIRED
          done();
        }
\end{verbatim}

\rednote{[2007.03.09] Be wary that with the current parser, a
  semi-colon error may appear as a strange parse error in the next
  or previous line.}

\subsection{Constructing complete programs}

A complete program file contains function and variable
declarations as well as a single {\em stream wiring statement} of the form:
\begin{wscode}
BASE <- expression;
\end{wscode}
This wiring statement determines the stream of values returned as
a result of running the program.



%================================================================================
\section{Datatypes}

This section goes over syntax and primitives for manipulating
built-in data structures.

\subsection{Tuples}

Tuples, or {\em product types}, are ordered sets of elements which can
each be of different types. 
\evalsto{(1,``hello'')}{A tuple of type {\tt (Int * String)}}
%\begin{wscode}
Tuples are accessed by a pattern-matching against them and binding
variable names to their constituent components.  This process is
described in section \ref{s:patterns}.

\subsection{Numbers}

WaveScript supports several different types of numbers.  \rednote{Currently,
this set includes Int, Int16, Float, Complex, but it will be extended
to include 8-bit integers, unsigned integers, doubles, and complex-doubles.}
WaveScript includes generic numeric arithmetic operations ($+$, $-$,
$*$, $/$) that work for any numeric types, but must be used on two
numbers of the same type.  There are also type-specific numeric
operations that are not used frequently:

\[
\begin{array}{rcl}
%generic          & : & +,\; -,\; $*$,\; /,\; ^{\wedge}   \\
generic          & : & $\tt + - * / \^{}$   \\
Int              & : & $\tt +\_ -\_ *\_ /\_ \^{}\_ $ \\
Float            & : & $\tt +. -. *. /. \^{}. $ \\
Complex          & : & $\tt +: -: *: /: \^{}: $ \\
Int16            & : & $\tt +I16 -I16 *I16 /I16 \^{}I16 $   \\
\end{array}
\]

Other numeric operations, such as {\tt abs} or {\tt sqrt}, follow the
naming convention {\tt absI} for integers, {\tt absF} for floats, {\tt
absC} for complex, and {\tt absI16} for 16-bit integers.

% int, uint16, uint8, float, double, complex 

% Could just have NUMBER in the FIRST type check..
% Then type check again AFTER elaboration.
% (It would be really nice to keep source info....)

\subsection{Lists}

Lists can be written as constants and support the usual primitive
operations.  
\begin{verbatim}
      ls = [1, 2, 3];
      ls2 = head(ls):::ls;
      print(List:length(ls2)); // Prints '4'
      print(ls == []);         // Prints 'false'
\end{verbatim}

The {\tt :::} operator adds an element to the front of a list.  Also
use {\tt head}, {\tt tail}, {\tt List:reverse}, {\tt List:append} to operate on
lists. 

\subsection{Arrays}

Arrays are mutable and cannot currently be written as constants.  Use
{\em makeArray} to produce arrays, {\tt arr[i]} to access arrays, and
{\tt arr[i] = x;} to modify them.

%Refer to {\tt prim_defs.ss} for more array operations.

\subsection{Additional primitive functions}

Please refer to the file 
\vspace{-2mm}
\begin{center}
{\tt{wavescript/src/generic/\\compiler\_components/prim\_defs.ss}}

% \htmladdnormallink{wavescript/src/generic/\\compiler\_components/prim\_defs.ss}{ERRRRERR}

%\htmladdnormallink{TEST}{SOMEURL}

%\hyperref{FOOBAR}{BAZZZZ}

\hyperref{FOOBAR}{BAZZZZ}{}{}

\url{http://regiment.us/codedoc/html/generic/compiler_components/prim_defs.ss}

\end{center}

for type-signatures (and minimal documentation) for all built-in
wavescript primitives, many of which are not covered in this manual.

Please also examine the library files found in the {\tt wavescript/lib}
directory.  These files, for example {\tt ``stdlib.ws''} and {\tt
  ``matrix.ws''}, include library routines written in WaveScript.  As
a general design principle, it is best to implement as much as
possible in the language, while keeping the set of built-in primitives
relatively small.


%================================================================================
\section{User defined functions}
\label{udfs}

Named functions can be defined at the top-level, or within a {\tt
  \{\ldots\}} block as follows:

\begin{verbatim}
       fun f(x,y) {
         z = x+y;
         sqrt(z)
       }
\end{verbatim}

The function body, following the argument list can be any expression.
Above it happens to be a statement block that returns the
square-root of {\tt z}.

Unnamed, or anonymous, functions can occur anywhere that an expression
might occur. In the following we pass an anonymous ``plus three''
function as the first input to {\tt stream\_map}.  Note that the body
of the function is a single expression, not a statement block, and is
not delimited by curly braces.

\begin{wscode}
stream\_map(fun(x) x+3, S)
\end{wscode}




%================================================================================
\section{Type Annotations}

We have already seen several types in textual form within this manual:
{\tt Float}, {\tt (Int * String)} These are valid WaveScript types.
WaveScript also has compound types such as {\tt Sigseg (Array Int)}.

Similar to Haskell or ML, the user is permitted, but not generally
required to add explicit type annotations in the program.  For
example, we may annotate a function {$\tt f$} with its type by writing
the following.
%
\begin{verbatim}
        f :: (Type, Type) -> Type;
        fun f(x,y) { ... }
\end{verbatim}

Indeed, a type annotation may be attached to any expression with
the following syntax:
\begin{wscode}
(expression :: Type)
\end{wscode}

Further, type annotations may be added to variable declarations with:
\begin{wscode}
 var :: Type = expression;
\end{wscode}

In general, compound types may be built from other types in several
ways.  
\[
\begin{array}{rcl}
tuples           & : & $\tt (T1 * T2 * T3) $   \\
lists            & : & $\tt List T1 $ \\
arrays           & : & $\tt Array T1 $ \\
hashtables       & : & $\tt HashTable (T1,T2) $ \\
functions        & : & $\tt (T1, T2, T3) -> T4 $ \\
\end{array}
\]
Note that parentheses must be used when nesting type
constructors as in {\tt List (List T)}.

\rednote{[2007.03.09] In the future, the user will be able to create
  their own type definitions and type constructors, including
  tagged-union or {\em sum} types.}


\subsection{Reading data with readFile}

The one place where type annotations {\em are} currently mandated is
when importing data from a file.  This is done with the primitive {\tt
readFile}.
%
\begin{verbatim}
       BASE <- 
         (readFile("foo.txt", "") 
          :: Stream (Int16 * Float))
\end{verbatim}

The above complete program reads space-separated values from a text
file, one-tuple-per-line.  In this case, each tuple contains two
values: a 16 bit integer, and a floating point value.
The {\tt readFile} primitive may also be
used to read data from a file in blocks (Sigsegs), which is generally
more efficient.  All that is required is to specify a stream of
{\tt Sigseg} type, as follows.

\begin{verbatim}
       BASE <- 
         (readFile("foo.dat", 
                   "mode: binary  repeat: 3")
          :: Stream (Sigseg Int16))
\end{verbatim}

Also note that the second argument to {\tt readFile} is an option
string.  This string is parsed at compile time (during meta-program
evaluation).  The string must contain a (space separated) list of
alternating option names and option values.  The following are the
available options, and their default values.

\begin{itemize}
\item {\bf mode:} one of 'text' or 'binary' (default {\bf 'text'})

\item {\bf repeats:} a number specifying whether to replay the file's
  contents when the end of file is reached.  Set to a non-negative
  integer to specify the number of repeats, or to {\bf -1} to repeat
  indefinitely.  (default {\bf 0})

\item {\bf rate:} the rate (in tuples per second) to play the back the
  data from the file.  For the emulator, this refers to virtual time,
  and is used only to maintain relative timing of different data
  streams.  (default {\bf 1000})

\item {\bf offset:}
  The offset, in bytes, at which to start reading from the
  file. (default {\bf 0})

\item {\bf skipbytes:}
The number of bytes to skip between reading each tuple
  from the data file. (default {\bf 0})

\item {\bf window:} If the output stream is blocked into Sigsegs
  (windows), this parameter determines the size of each
  Sigseg. (default {\bf 1})

\end{itemize}


%%  and reads them at a virtual ``rate'' of
%% 44Khz (this is important for the relative timing of different
%% streams).  Finally, the last number is the replay argument.  If it's greater
%% than zero, {\tt dataFile} will replay the data that many times after
%% reading the file.  If the replay value is $-1$, then the data will be
%% replayed indefinitely.



%================================================================================
\subsection{Type Aliases}

Because types can grow large and complex, it is often helpful to
define aliases, or shorthands, similar to C/C++'s {\tt typedef}s.

\begin{center}
\begin{verbatim}
       type MyType        = List Int;
       type MyType2  t    = Stream (List t);
       type MyType3 (x)   = List (x);
       type MyType4 (x,y) = List (x * y);

       x :: MyType;
       x = [3];

       s1 :: MyType2 Int;
       ...
\end{verbatim}
\end{center}


%================================================================================
\section{Streams}

WaveScript is for stream-processing and it would be useless without
Streams.  
Streams in WaveScript are like any other values: bound to variables,
passed and returned from functions.
The primary means of operating on the data inside streams is the {\tt
  iterate} syntactic construct.

\begin{verbatim}
        S2 = iterate( x in S1 ) {
          state{ counter = 0 }
          counter := counter + 1;
          emit counter + x;
        }
\end{verbatim}

The {\tt iterate} construct can be placed in any {\em expression}
position.  It produces a new stream by applying the supplied code to
every element of its input stream.  The above example executes the
body of the iterate every time data is received on the stream {\tt
  S1}, it adds an increasing quantity to each element of {\tt S1}, and the
resulting stream is bound to the variable {\tt S2}.

In addition to {\tt iterate} several library procedures (such as {\tt
stream\_map}) and many primitives (such as {\tt unionList}) operate on
{\tt Stream} values.





%================================================================================
\section{Sigsegs}

Sigsegs are a flexible ADT for representing windows of samples on a stream.
Please refer to the CIDR'07 publication by the title 
``The Case for a Signal-Oriented Data Stream Management System'' for
details.  Also check {\tt prim\_defs.ss} for the specific names and
type signatures of the Sigseg primitives.

% smap$((+3))
% smap(f$(x), S)
%%  ls.List:ref(i)
%%  ls.list:ref(i)

%% list:ref 
%% List:ref 

%% list|ref 

%% ls.List|ref(i)


%% namespace Matrix {
  
%% }

%% Matrix:make
%% Array:make

%% using Matrix;




%================================================================================
\section{Namespaces}

WaveScript, while not having a sophisticated module system, does
include a simple system for managing namespaces.

\begin{center}
\begin{verbatim}
      namespace Foo {
        x = ...;
        y = ...;
      }
      var = Foo:x + Foo:y;
      fun f() {
        using Foo;
        var = x + y;
      }
\end{verbatim}
\end{center}


%================================================================================
\section{Patterns}
\label{s:patterns}

WaveScript allows pattern matching in addition to plain variable-
In any variable-binding position it is valid to use a pattern rather
than a variable name---this includes the arguments to a function, a
local variable binding, or the variable binding within an {\tt
 iterate} construct.  Currently, patterns are used to bind names
to the interior parts of tuples.  In the future, we will support list
patterns, and tagged union patterns.  

Let's look at an example.
We saw how to bind variables in WaveScript:
\begin{center}
{\tt \bf{z} = (1,2);}
\end{center}
This binds {\tt z} to a tuple containing two elements.  
This is actually a shorthand for the more verbose syntax:
\begin{center}
{\tt let \bf{z} = (1,2);}
\end{center}

An unfortunate limitation of the parser is that {\tt 'let'} cannot be
omitted if we a pattern is used in place of a simple identifier.  The
following binds the individual components of the tuple by using a
pattern in place of the variable {\tt 'z'}:
\begin{center}
{\tt let \bf{(x,y)} = (1,2);}
\end{center}

Similarly, we may use patterns within a function's argument list.  Here's
a function that takes a 2-tuple as its second argument:

\begin{center}
{\tt {\bf fun} foo (x,\bf{(y,z)}) \{ \dots \}}
\end{center}


%================================================================================
\section{Syntactic Sugar}

Syntactic sugars are convenient shorthands that are implemented by the
parser and make programming in WaveScript more convenient (at the risk
of making reading code more difficult for the uninitiated).

%\noindent {\bf Dot syntax:}
\subsection{Dot syntax}
  For convenience, functions can be applied using an
alternative ``dot syntax''.  For example rather than taking the first
element of a list with ``{\cd head(ls)}'', we can write ``{\cd ls.head}''.
This generalizes to functions of more than one argument; only the
first argument is moved before the dot.  For example, 
\vspace{-2mm}
\begin{wscode}
List:ref(ls,i)
\end{wscode}
\vspace{-2mm}
 may be written as 
\vspace{-2mm}
\begin{wscode}
ls.List:ref(i)
\end{wscode}
\vspace{-2mm}
This is useful because many functions on data structures take the
data structure itself as their first argument.  Thus it is concise to
write the following:
\vspace{-2mm}
\begin{wscode}
ls.tail.tail.head
\end{wscode}
\vspace{-2mm}


\subsection{Stream Projectors}

WaveScript also includes a syntax for binding variables to
Stream-of-tuple values that binds projector functions for each of
the tuples' fields.  For example:

\begin{wscode}
S as (a,b) = someStream;
\end{wscode}

Subsequently, ``{\tt S.(a)}'' or ``{\tt S.(a,b,a)}'' can be used to
project-out a new stream where each tuple represents an arrangement of
the fields within each tuple in {S}.  If used in conjunction with the
type-annotation syntax, note that the ``{\tt as}'' clause must go first:

\begin{wscode}
S as (a,b) :: Stream(Int * Float) = someStream;
\end{wscode}





\chapter{Foreign (C/C++) Interface}

The WaveScript compiler provides a facility for calling external
(foreign) functions written in C or C++.  The primary reasons for this
are two-fold.

\begin{enumerate}
\item We wish to reuse existing libraries without modification (e.g. Gnu
  Scientific Library, FFTW, etc).
\item We wish to add new stream sinks --- for network communication, disk access and so
  on --- without modifying the WaveScript compiler itself.  Also, we
  frequently want to add support for new hardware data-sources
  (sensors)\footnote{New data {\em souces} are not always convenient
  or possible to implement
  with the current foreign function interface.  In the future we will
  have a {\tt foreign\_box} syntax similar to {\tt foreign}, but
  allowing the user to write a WSSource class usable by the WaveScope engine.}.
\end{enumerate}

The WaveScript construct used to accomplish this is:
  ``{\tt foreign {\em <function-name>} in {\em <files>}}''.
The {\tt foreign} syntax can be used anywhere within a WaveScript
program.  It returns a WaveScript function representing the
corresponding C function.
For example, the following would import a function ``foo'' from ``foo.c''.

\begin{wscode}
c\_foo :: Int -> Int = foreign "foo" in ["foo.c"]
\end{wscode}

Note that, as when reading data from a file, the compiler has no way
to know the type of the external function, so an explicit type
annotation is required.

Currently C-code can be loaded from source files ({\tt .c}, {\tt
  .cpp}) or object files ({\tt .o}, {\tt .a}, {\tt .so}).  When
  loading from object files, it's necessary to also include a header
  ({\tt .h}, {\tt .hpp}).  For example:

\begin{wscode}
c\_bar :: Int -> Int = foreign "bar" in ["bar.h", "bar.a"]
\end{wscode}

Of course, you may want to import many functions from the same file or
library.  WaveScript uses a very simple rule.  If a file has already
been imported once, repeated imports are suppressed.  (This goes for
source and object files.)  Also, if you try to import multiple files with
the same basename (e.g. ``bar.o'' and ``bar.so'') the behavior is
currently undefined.

The foreign-function facility works under the {\bf Scheme} and {\bf
 C++/XStream} backends ({\tt ws} and {\tt wsc}).  The behavior differs
 slightly in that the Scheme system can only load shared-object files,
 thus when passed {\tt .o} or {\tt .a} files, it simply invokes a
 shell command to convert them to shared-object files before loading
 them.

Including source files also has a slightly different meaning between
the two backends.  Scheme will ignore header files (it doesn't need
them).  C source files ({\tt .c} or {\tt .cpp}) are compiled by
invoking the system's C compiler.  On the other hand, in the XStream backend, C source
files are simply {\tt \#include}d into the output C++ query file.  In
the former case, the source is compiled with no special link options
or compiler flags, and in the latter it is compiled under the same
environment as the C++ query file itself.

Thus, if the imported foreign functions require any customization of
the build environment whatsoever, it is recommended to compile them
yourself and import the object files into WaveScript, rather than
importing the C source files.

\rednote{[2007.05.03] Note: Currently the foreign function interface is only
supported on Linux platforms.  It also has very preliminary support
for Mac OS but is mostly subsection.}

\subsection{Converting WaveScript and C types}

An important feature of the foreign interface is that it defines a set
of mappings between WaveScript types and native C types.  The compiler
then automatically converts object representations where necessary.
This allows many C functions to be used without modification.  Figure
\ref{f:types} shows the mapping between C types and WaveScript types.

\begin{figure}
\begin{center}
\begin{tabular}{|r|r|l|}
\hline
$WaveScript$ & $C$ & $explanation$\\
\hline
{\tt Int}   & {\tt int}   & 
  \parbox[t]{2.2in}{native ints have a system-dependent 
length, note that in the emulator WaveScript {\tt Int}s may 
have less precision than C {\tt int}s} \\

{\tt Float} & {\tt float} & 
\parbox[t]{2.2in}{WaveScript floats are single-precision}\\

{\tt Bool} & {\tt bool} & \\

{\tt String} & {\tt char*} & pointer to null-terminated string \\

%()   & 

{\tt Char} & {\tt char} & (not implemented yet) \\

{\tt Array T} & {\tt $T$*} & \parbox[t]{2.2in}{
(not implemented yet) 
pointer to C representation of type {\tt T} 
}\\

{\tt Pointer} & {\tt void*} &  \parbox[t]{2.2in}{
(not implemented yet) Type for handling C-pointers.  Only good for
  passing back to C.
}\\

\hline
\end{tabular}
\end{center}
\caption{Mapping between WaveScript and C types.  Conversions
  performed automatically.}
\label{f:types}
\end{figure}

\rednote{[2007.05.03] The system will very soon support conversion of
  Complex, Int16, and Array types.  Further, it will provide a
  C-library for manipulating the representations of other WaveScript types.}

\chapter{Signal Processing Libraries}

\section{Fourier Transforms}

WaveScript uses fftw.  See prim\_defs.ss for a list of the different
fft interfaces provided.

\section{Matrix Operations}

WaveScript uses the Gnu Scientific Library to support matrix operations.

\rednote{[2007.03.09] Currently, GSL is only used for a built-in matrix
  inversion, {\tt m\_invert}}, 

\chapter{WaveScript Evaluation Model}

WaveScript is a {\em metaprogramming} language.  For further
explanation, I'll refer you to a quote from the {\em Matrix Reloaded}
that was brought to my attention by Yannis Smaragdakis.

\begin{center}
NEO: Programs hacking programs. Why?

ORACLE: They have their reasons, ...
\end{center}

The {\em reason} in WaveScript, is that we want to write programs of a
different character than we want to {\em run}.
We want to {\em write}
abstract, reusable, polymorphic, higher-order programs, but we want to
{\em run} fast, monomorphic, first-order, C-programs representing
parallelizable dataflow graphs.
In WaveScript your program essentially {\em
generates} the specialized, high-performance stream-processing
program that is subsequently compiled and run.  


How does this work?  Currently {\em all} user defined functions (as
described in section \ref{udfs}) {\bf will be inlined at metaprogram
evaluation}.  What results is a dataflow graph of {\tt iterate} blocks.
Thus, only bounded-recursions are permitted in user defined functions,
and excessive code bloat becomes a real possibility.  In the future, we will
allow a ``noinline'' or ``library function'' annotation that specifies
that a function is to be compiled as a C-function, rather than
inlined.  Of course, such a function will not be allowed to take or
return {\tt Stream} values.

\rednote{\em \bf Keep the metaprogram pure! (free of side-effects)}

\end{document}
