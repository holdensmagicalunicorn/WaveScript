
%\documentstyle[refman.sty]{article}
\documentstyle{report}
%\usepackage{color}

% page size commands

\title{WaveScript 0.1 Users Manual}

%\newcommand{\rednote}[1]{{\textcolor{red}{}}}
\newcommand{\rednote}[1]{{\em \bf{}}}





\begin{document}

\maketitle

% title page commads

\pagenumbering{arabic}
\tableofcontents
\clearpage

\chapter{Introduction}

WaveScript is a functional metaprogramming language for writing highly abstract
programs that generate efficient dataflow graphs.  These graphs are
executable in an emulator (ws) or by compiling te C++ (wsc) and linking them
to the {\em XStream} engine.

\section{Using WaveScript}

See the README for install instructions.  Once the system is installed
you should be able to execute {\tt ws} or {\tt wsc} on any WaveScript
source files ({\tt .ws}).

\subsection*{Develop Incrementally}

WaveScript is still very much a prototype.  It doesn't offer the same
level of support that you can expect from production-quality
compilers.  For example, the compiler doesn't track code locations.
It will often print the surrounding context of an error (in abstract
syntax), but nothing more.

Thus it helps to build your program bit by bit.  Compile often to make
sure that the pieces of your program parse and type-check.

{\tt \bf wsparse:}
If you want the full error message for a stubborn parser error, run
{\tt wsparse} directly on the ws file.  It will either print the AST
(abstract syntax tree) for the file, or will give you an error message
that includes line and character numbers.

\subsection{The WaveScript Emulator: {\tt \bf ws} }

Running {\tt ws} on a WaveScript file will simulate the functionality
of the query without actually compiling the query to C++ code.  The
query is converted to a Scheme program which is compiled to native
code and executed on the fly.  

\subsubsection*{Consider {\tt \bf ws.opt} for high-performance emulation}

The first thing to do to improve the performance of {\tt ws} is make
sure that you have the full version of Chez Scheme.  This version
includes the incremental native code compiler.  If you are using the
free, Petite Chez Scheme interpreter, your {\tt .ws} query files will
be converted to {\em interpreted} Scheme code, which runs considerably
slower.  The executable, {\tt chez}, should be in your path.

To go further, you might consider runnig {\tt ws.opt} in place of {\tt
ws}.  First, {\tt ws.opt} has debugging assertions disabled. 
Second, {\tt ws.opt} is compiled in the highest Chez Scheme optimize
level, and also compiles your query in this higher optimize level.
However, this optimize level is dangerous in that it omits various
checks necessary to maintaining type safety.  Thus the process can
crash if there's an error, or memory can become corrupted (just like
C/C++).  Therefore, debug your code using {\tt ws} first.

\subsubsection*{Run {\tt \bf ws.debug} occasionally for sanity-checking}

While it's too slow for the normal development cycle, it is important
to occasionally compile your program with ws.debug.  Mainly this is
important for building confidence that the compiler is behaving
properly on your program (not having exposing a bug).  If the compiler
were a mature system not under active development, this would not be
as important.  When you run {\bf ws.debug} the compiler runs extensive
invariant checks on the data structures it uses, in particular it
checks the intermediate forms between compiler passes for
conformance to explicit grammars.  Further it inserts extra
type-checks to make sure that the intermediate programs are well-formed.

\subsection{The WaveScript Compiler: {\tt \bf wsc}}

The WaveScript emulator provides a reference implementation suitable
to prototyping and debugging applications.  The eventual target is to
generate an efficient C++ program from the WaveScript source.  This is
accomplished with the {\bf wsc} compiler.  In practice, during
development the {\bf wsc} compiler often lags behind the {\bf ws}
emulator in terms of features and functionality.  Again, develop
incrementally, refer to wavescript/demos/wavescope for programs that
should work with {\bf wsc}.

Refer to the XStream documentation\footnote{Currently nonexistent
[2007.03.09]} for information on how to configure the XStream engine
(number of threads, scheduling policy, etc).

\rednote{[2007.03.09] Ideally the output from the XStream-executed
query would be the same as the emulator output.  Currently, there are
some basic disparities in how objects are printed.  Hopefully, these
are straightforward to work around, and should go away shortly.}

%================================================================================
\section{Language Syntax}

Please make liberal use of ~/wavescript/demos/wavescope as a reference
when developing WaveScript programs.  These demos cover most of the
basic functionality in the language.

\section{Naming conventions}

\chapter{Basics}

\section{Tuples}

\section{Numbers}

% int, uint16, uint8, float, double, complex 

% Could just have NUMBER in the FIRST type check..
% Then type check again AFTER elaboration.
% (It would be really nice to keep source info....)

\section{Streams}

\section{Sigsegs}

\section{Functions}

\begin{code}
fun f(x,y) {
  z = x+y;
  sqrt(z)
}
\end{code}

\begin{code}
stream_map(fun(x) x+3, S)
\end{code}

\section{Type Annotations}

\begin{code}
f :: Type;
fun f(x,y) { ...
\end{code}

\begin{code}
(expression :: Type)
\end{code}

\begin{code}
var :: Type = 
\end{code}





% smap$((+3))
% smap(f$(x), S)
%%  ls.List:ref(i)
%%  ls.list:ref(i)

%% list:ref 
%% List:ref 

%% list|ref 

%% ls.List|ref(i)


%% namespace Matrix {
  
%% }

%% Matrix:make
%% Array:make

%% using Matrix;


\section{Patterns}

In any variable-binding position it is valid to use a pattern rather
than a variable name.  This includes the arguments to a function, a
local variable binding, or the variable binding within an {\tt
  iterate} construct.  Currently, patterns are just used to bind names
to the interior parts of tuples.  In the future, we will support list
patterns, array patterns, and tagged union patterns.  

Let's look at an example.
We saw above how to bind variables in WaveScript:
\begin{center}
{\tt \bf{z} = (1,2);}
\end{center}
This binds {\tt t} to a tuple containing two elements.  
Now I will share with you that this is actually a shorthand for the
more verbose syntax:
\begin{center}
{\tt let \bf{z} = (1,2);}
\end{center}
Now we are ready to bind the individual components of the tuple by using
a pattern in place of the variable {\tt 'z'}:
\begin{center}
{\tt let \bf{(x,y)} = (1,2);}
\end{center}
Note: an unfortunate limitation of the parser is that {\tt 'let'} cannot be
omitted if we a pattern is used in place of a simple identifier.

Similarly, we may use patterns within a function's arguments.  Here's
a function that takes a 2-tuple as its second argument:

\begin{center}
{\tt {\bf fun} foo (x,\bf{(y,z)}) \{ \dots \}}
\end{center}


\chapter{Signal Processing Libraries}

\section{Fourier Transforms}

WaveScript uses fftw.

\section{Matrix Operations}

WaveScript uses the Gnu Scientific Library to support matrix operations.

\chapter{WaveScript Evaluation Model}




\end{document}
