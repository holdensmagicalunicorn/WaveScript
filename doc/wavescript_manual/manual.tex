
%\documentstyle[refman.sty]{article}
\documentstyle{report}

% page size commands

\title{WaveScript 0.1 Users Manual}

\begin{document}

\maketitle

% title page commads

\pagenumbering{arabic}
\tableofcontents
\clearpage

\chapter{Introduction}

\~/wavescript

\section{Using WaveScript}

See the README for install instructions.  Once the system is installed
you should be able to execute {\tt ws} or {\tt wsc} on any WaveScript
source files ({\tt .ws}).

\subsection*{Develop Incrementally}

WaveScript is still very much a prototype.  It doesn't offer the same
level of support that you can expect from production-quality
compilers.  For example, the compiler doesn't track code locations.
It will often print the surrounding context of an error (in abstract
syntax), but nothing more.

Thus it helps to build your program bit by bit.  Compile often to make
sure that the pieces of your program parse and type-check.

{\tt \bf wsparse:}
If you want the full error message for a stubborn parser error, run
{\tt wsparse} directly on the ws file.  It will either print the AST
(abstract syntax tree) for the file, or will give you an error message
that includes line and character numbers.

\subsection{The WaveScript Emulator: {\tt \bf ws} }

Running {\tt ws} on a WaveScript file will simulate the functionality
of the query without actually compiling the query to C++ code.  The
query is converted to a Scheme program which is compiled to native
code and executed on the fly.  

\subsubsection*{Consider {\tt \bf ws.opt} for high-performance emulation}

The first thing to do to improve the performance of {\tt ws} is make
sure that you have the full version of Chez Scheme.  This version
includes the incremental native code compiler.  If you are using the
free, Petite Chez Scheme interpreter, your {\tt .ws} query files will
be converted to {\em interpreted} Scheme code, which runs considerably
slower.  The executable, {\tt chez}, should be in your path.

To go further, you might consider runnig {\tt ws.opt} in place of {\tt
ws}.  First, {\tt ws.opt} has debugging assertions disabled. 
Second, {\tt ws.opt} is compiled in the highest Chez Scheme optimize
level, and also compiles your query in this higher optimize level.
However, this optimize level is dangerous in that it omits various
checks necessary to maintaining type safety.  Thus the process can
crash if there's an error, or memory can become corrupted (just like
C/C++).  Therefore, debug your code using {\tt ws} first.

\subsection{The WaveScript Compiler: {\tt \bf wsc}}


\section{Syntax}

Please make liberal use of ~/wavescript/demos/wavescope

\section{Naming conventions}


\chapter{Basics}

\section{Tuples}

\section{Numbers}

% int, uint16, uint8, float, double, complex 

% Could just have NUMBER in the FIRST type check..
% Then type check again AFTER elaboration.
% (It would be really nice to keep source info....)

\section{Streams}

\section{Sigsegs}

\section{Functions}

\section{Patterns}

In any variable-binding position it is valid to use a pattern rather
than a variable name.  This includes the arguments to a function, a
local variable binding, or the variable binding within an {\tt
  iterate} construct.  Currently, patterns are just used to bind names
to the interior parts of tuples.  In the future, we will support list
patterns, array patterns, and tagged union patterns.  

Let's look at an example.
We saw above how to bind variables in WaveScript:
\begin{center}
{\tt \bf{z} = (1,2);}
\end{center}
This binds {\tt t} to a tuple containing two elements.  
Now I will share with you that this is actually a shorthand for the
more verbose syntax:
\begin{center}
{\tt let \bf{z} = (1,2);}
\end{center}
Now we are ready to bind the individual components of the tuple by using
a pattern in place of the variable {\tt 'z'}:
\begin{center}
{\tt let \bf{(x,y)} = (1,2);}
\end{center}
Note: an unfortunate limitation of the parser is that {\tt 'let'} cannot be
omitted if we a pattern is used in place of a simple identifier.

Similarly, we may use patterns within a function's arguments.  Here's
a function that takes a 2-tuple as its second argument:

\begin{center}
{\tt {\bf fun} foo (x,\bf{(y,z)}) \{ \dots \}}
\end{center}


\chapter{Signal Processing Libraries}

\section{Fourier Transforms}

\section{Matrix Operations}



\chapter{WaveScript Evaluation Model}




\end{document}
