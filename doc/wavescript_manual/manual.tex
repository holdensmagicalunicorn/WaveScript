
%\documentstyle[refman.sty]{article}
%\documentstyle[twocolumn]{report}
\documentclass[twocolumn]{report}
\usepackage{color}
%\usepackage{code}

%\usepackage{hyperref}
\usepackage{html}


\setlength{\textheight}{9.25in}
\setlength{\columnsep}{0.25in} %RRN changed: {0.33in}
\setlength{\textwidth}{7.4in}
\setlength{\footskip}{0.0in}
\setlength{\topmargin}{-0.25in}
\setlength{\headheight}{0.0in}
\setlength{\headsep}{0.0in}
\setlength{\oddsidemargin}{-.45in}
\setlength{\parindent}{1pc}


% page size commands

\title{WaveScript 0.1.4 Users Manual}

\newcommand{\rednote}[1]{{\textcolor{blue}{#1}}}
%\newcommand{\rednote}[1]{{\em \bf{}}}

\newcommand{\evalsto}[2]{\[ \begin{array}{rcl}
$\tt #1 $&$ \arr $&$ #2 $
\end{array} \]}

\newcommand{\arr}{\ensuremath{\rightarrow}}

\newcommand{\cd}{\tt}

\newcommand{\ra}{\ensuremath{\rightarrow}}

\newenvironment{wscode}{\begin{center}\tt}{\end{center}}

\begin{document}

\maketitle

% title page commads

\pagenumbering{arabic}
\tableofcontents
\clearpage

\chapter{Introduction}

WaveScript is a functional metaprogramming language for writing highly abstract
programs that generate efficient dataflow graphs.  These graphs are
executable in several backends (Scheme, ML, C++) that offer different
tradeoffs in features, performance, and compile times.  The compiler
has several command line entrypoints for the different backends.

%Calling {\bf ws}
% linking them to the {\em XStream} engine.

\section{Using WaveScript}

See the README for install instructions.  The bottom line is that you
will need Mzscheme and Petite Chez Scheme to run the WaveScript
compiler and the Scheme backend.  (Petite for Linux is included in the
repository.)  You will need Boost, the Gnu Scientific Library (GSL),
FFTW, and their respective headers to run compiled C++ code.

Once the system is installed you should be able to execute {\bf \tt
  ws} on any WaveScript source files ({\tt .ws} files).  This will
compile the query and execute it directly in the Scheme backend.
Other backends (and variations on this one) will be discussed in this
chapter.  This chapter addresses pragmatic issues concerning invoking
the system and running dataflow graphs.  If you are new to WaveScript,
it may help to skip to chapter \ref{s:lang} to get a sense for the
language itself, then come back to this section afterwards.

\subsection*{Develop Incrementally}

WaveScript is a research compiler.  It doesn't offer the same
level of support that you expect from production-quality
compilers.  Sometimes the error messages might be difficult to
interpret.  (However, the type checker messages have been improved
immensely and do include code locations [04/08/2007].)

Therefore it helps to build your program bit by bit.  Compile often to make
sure that the pieces of your program parse and type-check.

{\tt \bf wsparse:} While entrypoints such as {\tt \bf ws} parse source files
internally, if you want the full error message for a parser error
(including line and column number!), run {\tt wsparse} directly on the
{\tt .ws} file.  It will either print the AST (abstract syntax tree) for the
file, or will give you an error message that does include line and
character numbers.

\subsection{{\tt \bf ws}: The Interactive Scheme Backend}

Running the command ``{\tt ws mysource.ws}'' will compile your source
file, and execute the resultant dataflow graph directly within Scheme,
without generating code for another platform.
%
The dataflow graph is converted to a Scheme program which is compiled
to native code and executed on the fly.  Compile time is low, because
we need not call a separate backend compiler.  However, performance is
not as good as the other backends we will discuss.  Further, the
Scheme backend does not support external (real time) data sources,
only queries running in virtual time using data stored in files.

One major advantage of the Scheme backend is that it's {\em
  interactive}.  The query starts up paused, and the user may step
through and inspect the elements of the output stream.  Thus the user
may {\em pull} on the stream rather than being {\em pushed} a torrent
of output.

%% Further, hardware
%% sensors cannot be accessed from the emulator (except through the
%% foreign interface \ref{s:foreign}), and so data must be read from
%% trace files.

\subsection*{Variants of {\tt \bf ws}}

There are several other useful ways to invoke WaveScript with the
Scheme backend.

\subsubsection*{Consider {\tt \bf ws.opt} for higher performance}

The first thing to do to improve the performance of {\tt ws} is make
sure that you have the full version of Chez Scheme.  This version
includes the incremental native code compiler.  If you are using the
free, Petite Chez Scheme interpreter, your {\tt .ws} query files will
be converted to {\em interpreted} Scheme code, which runs considerably
slower.  The executable {\tt chez} should be in your path.

To go further, you might consider running {\tt ws.opt} in place of {\tt
ws}.  First, {\tt ws.opt} has debugging assertions disabled. 
Second, {\tt ws.opt} is compiled in the highest Chez Scheme optimize
level, and also compiles your query in this higher optimize level.
However, this optimize level is dangerous in that it omits various
checks necessary to maintaining type safety.  Thus the process can
crash if there's an error, or memory can become corrupted (just like
C/C++).  Therefore, debug your code using {\tt ws} first.

\subsubsection*{Run {\tt \bf ws.debug} occasionally for sanity-checking}

Ws.debug is too slow for the normal development cycle, but it is
important to occasionally compile your program with ws.debug.  Mainly
this is important for building confidence that the compiler is
behaving properly on your program.  If the
compiler were a mature system not under active development, this would
not be as important.  


Specifically, when you run {\tt ws.debug}:

\begin{enumerate}
\item It turns on extra ASSERT statements in the code that check data
structure invariants to help ensure proper operation.

\item It dumps the whole program at several points in the
  compilation to files such as ``.\_\_elaboratedprog.ss''.  It can be
  helpful to look at these for debugging.

\item It includes additional type checks of the entire program between
  passes (regular {\tt ws} type checks several times, but {\tt
  ws.debug} does more).  This helps expose compiler bugs.

\item Finally, it does ``grammar checks'' on the output of each compiler
  pass. Each pass includes a BNF grammar that describes its output.
  {\tt ws.debug} mechanically checks to make sure every intermediate
  expression conforms to the appropriate grammar.  Again, this helps
  to expose compiler bugs.
\end{enumerate}


\subsubsection*{For very low compile times: {\tt \bf ws.early}}

If you are running many small programs --- stream ``queries'' --- then
the latency introduced by compilation may be more significant than the
throughput of the query once it is running.  In this case it is
reasonable to use {\tt ws.early}.


%When you run {\bf ws.debug} the compiler runs extensive
%invariant checks on the data structures it uses, in particular it
%checks the intermediate forms between compiler passes for
%conformance to explicit grammars.  Further it inserts extra
%type-checks to make sure that the intermediate programs are well-formed.

\subsection{The WaveScript C++ Backend}

The WaveScript emulator provides a reference implementation suitable
to prototyping and debugging applications.  The eventual target is to
generate an efficient C++ program from the WaveScript source.  This is
accomplished with the {\bf wsc} compiler.  In practice, as WaveScript
undergoes development, the {\bf wsc} compiler often lags behind the {\bf ws}
emulator in terms of features and functionality.  Again, develop
incrementally, refer to {\tt wavescript/demos/wavescope} for programs that
should work with {\bf wsc}.

Refer to the XStream documentation\footnote{\rednote{[2007.03.09] Currently nonexistent}} 
for information on how to configure the XStream engine
(number of threads, scheduling policy, etc)).

\rednote{[2007.03.09] Ideally the output from the XStream-executed
query would be the same as the emulator output.  Currently, however, there are
some basic disparities in how objects are printed to text form.  Hopefully, these
are straightforward to work around, and should go away shortly.}


\subsubsection*{The WaveScript CaML Backend}

\rednote{This backend is no longer supported and will receive no new features!}

\subsubsection*{The WaveScript MLton Backend}



%================================================================================
\chapter{Language Basics}\label{s:lang}

Please make liberal use of {\tt wavescript/demos/wavescope/*.ws} as a reference
when learning WaveScript.  These demos cover most of the basic
functionality in the language.

%\section{Naming conventions}
%\chapter{Basics}

WaveScript is a functional language with many similarities to ML or
Haskell.  Functions are values.  The language is strongly typed and uses a
type-inference algorithm to infer types from variable usages.
It provides the usual basic datatypes, including various
numeric types, strings, lists, arrays, hash tables as well as the more
WaveScript-specific Streams and Sigsegs.  Valid {\em expressions} in
WaveScript are written much as in C.
\[
\begin{array}{rcl}
arithmetic       & : & $\tt 3 + 4 * 10 $  \\
function\; calls & : & $\tt f(x, y)$  \\
blocks           & : & $\tt \{ e$_1$; e$_2$; \ldots$\:$ e$_n$ \}$  \\
\end{array}
\]

But there are also many syntactic differences from C.  For example,
WaveScript doesn't have a sharp division between commands and
expressions.  Conditionals use a different syntax and are valid in
{\em any}
expression position.
%
\evalsto{3 + (if true then 1 else 2)} {4}
%
Moreover, {\em blocks} in WaveScript---delimited by curly
braces---are just expressions!

\evalsto{3 + \{1; 2; 3\}} {6}
%
This is similar to the {\tt begin}/{\tt end} blocks found in other
functional languages, or the ``comma operator'' sequencing construct
in C++.  Only the value of the last expression within the block is
returned, the other statements/expressions only bind variables or
perform side effects.

Note that this different convention makes semi-colon usage in
WaveScript somewhat unintuitive.  Within blocks, semi-colons are only
required as {\em separators}; they are permitted, but not required
after the last expression in the block.  Also, since curly-brace
delimited blocks are merely expressions, they sometimes must be
followed with a semi-colon, as below:\footnote{As a special case, when
a function body consists of curly braces, it needn't be followed by a semi-colon.}

%\vspace{-5mm}
\begin{verbatim}
        {
          foo;
          if b then {
            bar();
          } else {
            baz();
          };  <-- SEMICOLON REQUIRED
          done();
        }
\end{verbatim}

\rednote{[2007.03.09] Be wary that with the current parser, a
  semi-colon error may appear as a strange parse error in the next
  or previous line.}

\subsection{Constructing complete programs}

A complete program file contains function and variable
declarations as well as a single {\em stream wiring statement} of the form:
\begin{wscode}
BASE <- expression;
\end{wscode}
This wiring statement determines the stream of values returned as
a result of running the program.



%================================================================================
\section{Datatypes}

This section goes over syntax and primitives for manipulating
built-in data structures.

\subsection{Tuples}

Tuples, or {\em product types}, are ordered sets of elements which can
each be of different types. 
\evalsto{(1,``hello'')}{A tuple of type {\tt (Int * String)}}
%\begin{wscode}
Tuples are accessed by a pattern-matching against them and binding
variable names to their constituent components.  This process is
described in section \ref{s:patterns}.

\subsection{Numbers}

WaveScript supports several different types of numbers.  \rednote{Currently,
this set includes Int, Int16, Float, Complex, but it will be extended
to include 8-bit integers, unsigned integers, doubles, and complex-doubles.}
WaveScript includes generic numeric arithmetic operations ($+$, $-$,
$*$, $/$) that work for any numeric types, but must be used on two
numbers of the same type.  There are also type-specific numeric
operations that are not used frequently:

\[
\begin{array}{rcl}
%generic          & : & +,\; -,\; $*$,\; /,\; ^{\wedge}   \\
generic          & : & $\tt + - * / \^{}$   \\
Int              & : & $\tt +\_ -\_ *\_ /\_ \^{}\_ $ \\
Float            & : & $\tt +. -. *. /. \^{}. $ \\
Complex          & : & $\tt +: -: *: /: \^{}: $ \\
Int16            & : & $\tt +I16 -I16 *I16 /I16 \^{}I16 $   \\
\end{array}
\]

Other numeric operations, such as {\tt abs} or {\tt sqrt}, follow the
naming convention {\tt absI} for integers, {\tt absF} for floats, {\tt
absC} for complex, and {\tt absI16} for 16-bit integers.

% int, uint16, uint8, float, double, complex 

% Could just have NUMBER in the FIRST type check..
% Then type check again AFTER elaboration.
% (It would be really nice to keep source info....)

\subsection{Lists}

Lists can be written as constants and support the usual primitive
operations.  
\begin{verbatim}
      ls = [1, 2, 3];
      ls2 = head(ls):::ls;
      print(List:length(ls2)); // Prints '4'
      print(ls == []);         // Prints 'false'
\end{verbatim}

The {\tt :::} operator adds an element to the front of a list.  Also
use {\tt head}, {\tt tail}, {\tt List:reverse}, {\tt List:append} to operate on
lists. 

\rednote{DESCRIBE BUILD, FOREACH, MAPI, ETC}

\subsection{Arrays}

Arrays are mutable and cannot currently be written as constants.  Use
{\em Array:make} to produce arrays, {\tt arr[i]} to access arrays, and
{\tt arr[i] = x;} to modify them.  See the documentation for
additional primitives below.

%Refer to {\tt prim_defs.ss} for more array operations.

\subsection{Additional primitive functions}

Please refer to this file within your working copy:
\vspace{-2mm}
\begin{center}
{\tt{wavescript/src/generic/\\compiler\_components/prim\_defs.ss}}
\end{center}

You can find the online documentation at:
\vspace{-2mm}
\begin{center}
\url{http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html}
\end{center}

%\htmladdnormallink {my Web page} {http://www.astro.ku.dk/\~{}milvang/}

%\htmladdnormallink{\tt{wavescript/src/generic/\\compiler\_components/prim\_defs.ss}}{http://regiment.us/codedoc/html/generic/compiler_components/prim_defs.ss}

%\htmladdnormallink{wavescript/src/generic/compiler\_components/prim\_defs.ss}{http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html}

This file contains type-signatures (and minimal documentation) for all built-in
wavescript primitives, many of which are not covered in this manual.
Within the online documentation linked above you should look at 
\htmladdnormallink{regiment-primitives}{http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#regiment-primitives}
which is defined in terms of 
\htmladdnormallink{regiment-basic-primitives}      {http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#regiment-basic-primitives},
\htmladdnormallink{regiment-distributed-primitives}{http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#regiment-distributed-primitives},
\htmladdnormallink{wavescript-primitives}          {http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#wavescript-primitives},
\htmladdnormallink{meta-only-primitives}           {http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#meta-only-primitives},
\htmladdnormallink{higher-order-primitives}        {http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#higher-order-primitives},
and
\htmladdnormallink{regiment-constants}             {http://regiment.us/codedoc/html/generic/compiler\_components/prim\_defs.ss.html\#regiment-constants}~.

Please also examine the library files found in the {\tt wavescript/lib}
directory.  These files, for example {\tt ``stdlib.ws''} and {\tt
  ``matrix.ws''}, include library routines written in WaveScript.  As
a general design principle, it is best to implement as much as
possible in the language, while keeping the set of built-in primitives
relatively small.


%================================================================================
\section{User defined functions}
\label{udfs}

Named functions can be defined at the top-level, or within a {\tt
  \{\ldots\}} block as follows:

\begin{verbatim}
       fun f(x,y) {
         z = x+y;
         sqrt(z)
       }
\end{verbatim}

The function body, following the argument list can be any expression.
Above it happens to be a statement block that returns the
square-root of {\tt z}.

Unnamed, or anonymous, functions can occur anywhere that an expression
might occur. In the following we pass an anonymous ``plus three''
function as the first input to {\tt stream\_map}.  Note that the body
of the function is a single expression, not a statement block, and is
not delimited by curly braces.

\begin{wscode}
stream\_map(fun(x) x+3, S)
\end{wscode}




%================================================================================
\section{Type Annotations}

We have already seen several types in textual form within this manual:
{\tt Float}, {\tt (Int * String)} These are valid WaveScript types.
WaveScript also has compound types such as {\tt Sigseg (Array Int)}.

Similar to Haskell or ML, the user is permitted, but not generally
required to add explicit type annotations in the program.  For
example, we may annotate a function {$\tt f$} with its type by writing
the following.
%
\begin{verbatim}
        f :: (Type, Type) -> Type;
        fun f(x,y) { ... }
\end{verbatim}

Indeed, a type annotation may be attached to any expression with
the following syntax:
\begin{wscode}
(expression :: Type)
\end{wscode}

Further, type annotations may be added to variable declarations with:
\begin{wscode}
 var :: Type = expression;
\end{wscode}

In general, compound types may be built from other types in several
ways.  
\[
\begin{array}{rcl}
tuples           & : & $\tt (T1 * T2 * T3) $   \\
lists            & : & $\tt List T1 $ \\
arrays           & : & $\tt Array T1 $ \\
hashtables       & : & $\tt HashTable (T1,T2) $ \\
functions        & : & $\tt (T1, T2, T3) -> T4 $ \\
\end{array}
\]
Note that parentheses must be used when nesting type
constructors as in {\tt List (List T)}.

\rednote{[2007.03.09] In the future, the user will be able to create
  their own type definitions and type constructors, including
  tagged-union or {\em sum} types.}


\subsection{Reading data with readFile}

The one place where type annotations {\em are} currently mandated is
when importing data from a file.  This is done with the primitive {\tt
readFile}.
%
\begin{verbatim}
       BASE <- 
         (readFile("foo.txt", "") 
          :: Stream (Int16 * Float))
\end{verbatim}

The above complete program reads space-separated values from a text
file, one-tuple-per-line.  In this case, each tuple contains two
values: a 16 bit integer, and a floating point value.
The {\tt readFile} primitive may also be
used to read data from a file in blocks (Sigsegs), which is generally
more efficient.  All that is required is to specify a stream of
{\tt Sigseg} type, as follows.

\begin{verbatim}
       BASE <- 
         (readFile("foo.dat", 
                   "mode: binary  repeat: 3")
          :: Stream (Sigseg Int16))
\end{verbatim}

Also note that the second argument to {\tt readFile} is an option
string.  This string is parsed at compile time (during meta-program
evaluation).  The string must contain a (space separated) list of
alternating option names and option values.  The following are the
available options, and their default values.

\begin{itemize}
\item {\bf mode:} one of 'text' or 'binary' (default {\bf 'text'})

\item {\bf repeats:} a number specifying whether to replay the file's
  contents when the end of file is reached.  Set to a non-negative
  integer to specify the number of repeats, or to {\bf -1} to repeat
  indefinitely.  (default {\bf 0})

\item {\bf rate:} the rate (in tuples per second) to play the back the
  data from the file.  For the emulator, this refers to virtual time,
  and is used only to maintain relative timing of different data
  streams.  Note that this is orthogonal to windowing; whether data is
  windowed or not, the rate will be interpreted in the same
  way. (default {\bf 1000}) 

\item {\bf offset:}
  The offset, in bytes, at which to start reading from the
  file. (default {\bf 0})

\item {\bf skipbytes:}
The number of bytes to skip between reading each tuple
  from the data file. (default {\bf 0})

\item {\bf window:} If the output stream is blocked into Sigsegs
  (windows), this parameter determines the size of each
  Sigseg. (default {\bf 1})

\end{itemize}


%%  and reads them at a virtual ``rate'' of
%% 44Khz (this is important for the relative timing of different
%% streams).  Finally, the last number is the replay argument.  If it's greater
%% than zero, {\tt dataFile} will replay the data that many times after
%% reading the file.  If the replay value is $-1$, then the data will be
%% replayed indefinitely.



%================================================================================
\subsection{Type Aliases}

Because types can grow large and complex, it is often helpful to
define aliases, or shorthands, similar to C/C++'s {\tt typedef}s.

\begin{center}
\begin{verbatim}
       type MyType        = List Int;
       type MyType2  t    = Stream (List t);
       type MyType3 (x)   = List (x);
       type MyType4 (x,y) = List (x * y);

       x :: MyType;
       x = [3];

       s1 :: MyType2 Int;
       ...
\end{verbatim}
\end{center}


%================================================================================
\section{Streams}

WaveScript is for stream-processing and it would be useless without
Streams.  
Streams in WaveScript are like any other values: bound to variables,
passed and returned from functions.
The primary means of operating on the data inside streams is the {\tt
  iterate} syntactic construct.

\begin{verbatim}
        S2 = iterate( x in S1 ) {
          state{ counter = 0 }
          counter := counter + 1;
          emit counter + x;
        }
\end{verbatim}

The {\tt iterate} construct can be placed in any {\em expression}
position.  It produces a new stream by applying the supplied code to
every element of its input stream.  The above example executes the
body of the iterate every time data is received on the stream {\tt
  S1}, it adds an increasing quantity to each element of {\tt S1}, and the
resulting stream is bound to the variable {\tt S2}.

In addition to {\tt iterate} several library procedures (such as {\tt
stream\_map}) and many primitives (such as {\tt unionList}) operate on
{\tt Stream} values.





%================================================================================
\section{Sigsegs}

Sigsegs are a flexible ADT for representing windows of samples on a stream.
Please refer to the CIDR'07 publication by the title 
``The Case for a Signal-Oriented Data Stream Management System'' for
details.  Also check {\tt prim\_defs.ss} for the specific names and
type signatures of the Sigseg primitives.

% smap$((+3))
% smap(f$(x), S)
%%  ls.List:ref(i)
%%  ls.list:ref(i)

%% list:ref 
%% List:ref 

%% list|ref 

%% ls.List|ref(i)


%% namespace Matrix {
  
%% }

%% Matrix:make
%% Array:make

%% using Matrix;




%================================================================================
\section{Namespaces}

WaveScript, while not having a sophisticated module system, does
include a simple system for managing namespaces.

\begin{center}
\begin{verbatim}
      namespace Foo {
        x = ...;
        y = ...;
      }
      var = Foo:x + Foo:y;
      fun f() {
        using Foo;
        var = x + y;
      }
\end{verbatim}
\end{center}


%================================================================================
\section{Patterns}
\label{s:patterns}

WaveScript allows pattern matching in addition to plain variable-
In any variable-binding position it is valid to use a pattern rather
than a variable name---this includes the arguments to a function, a
local variable binding, or the variable binding within an {\tt
 iterate} construct.  Currently, patterns are used to bind names
to the interior parts of tuples.  In the future, we will support list
patterns, and tagged union patterns.  

Let's look at an example.
We saw how to bind variables in WaveScript:
\begin{center}
{\tt \bf{z} = (1,2);}
\end{center}
This binds {\tt z} to a tuple containing two elements.  
This is actually a shorthand for the more verbose syntax:
\begin{center}
{\tt let \bf{z} = (1,2);}
\end{center}

An unfortunate limitation of the parser is that {\tt 'let'} cannot be
omitted if we a pattern is used in place of a simple identifier.  The
following binds the individual components of the tuple by using a
pattern in place of the variable {\tt 'z'}:
\begin{center}
{\tt let \bf{(x,y)} = (1,2);}
\end{center}

Similarly, we may use patterns within a function's argument list.  Here's
a function that takes a 2-tuple as its second argument:

\begin{center}
{\tt {\bf fun} foo (x,\bf{(y,z)}) \{ \dots \}}
\end{center}


%================================================================================
\section{Syntactic Sugar}

Syntactic sugars are convenient shorthands that are implemented by the
parser and make programming in WaveScript more convenient (at the risk
of making reading code more difficult for the uninitiated).

%\noindent {\bf Dot syntax:}
\subsection{Dot syntax}
  For convenience, functions can be applied using an
alternative ``dot syntax''.  For example rather than taking the first
element of a list with ``{\cd head(ls)}'', we can write ``{\cd ls.head}''.
This generalizes to functions of more than one argument; only the
first argument is moved before the dot.  For example, 
\vspace{-2mm}
\begin{wscode}
List:ref(ls,i)
\end{wscode}
\vspace{-2mm}
 may be written as 
\vspace{-2mm}
\begin{wscode}
ls.List:ref(i)
\end{wscode}
\vspace{-2mm}
This is useful because many functions on data structures take the
data structure itself as their first argument.  Thus it is concise to
write the following:
\vspace{-2mm}
\begin{wscode}
ls.tail.tail.head
\end{wscode}
\vspace{-2mm}


\subsection{Stream Projectors}

WaveScript also includes a syntax for binding variables to
Stream-of-tuple values that binds projector functions for each of
the tuples' fields.  For example:

\begin{wscode}
S as (a,b) = someStream;
\end{wscode}

Subsequently, ``{\tt S.(a)}'' or ``{\tt S.(a,b,a)}'' can be used to
project-out a new stream where each tuple represents an arrangement of
the fields within each tuple in {S}.  If used in conjunction with the
type-annotation syntax, note that the ``{\tt as}'' clause must go first:

\begin{wscode}
S as (a,b) :: Stream(Int * Float) = someStream;
\end{wscode}





\chapter{Foreign (C/C++) Interface}

The WaveScript compiler provides a facility for calling external
(foreign) functions written in C or C++.  The primary reasons for this
are two-fold.

\begin{enumerate}
\item We wish to reuse existing libraries without modification (e.g. Gnu
  Scientific Library, FFTW, etc).
\item We wish to add new stream sinks --- for network communication, disk access and so
  on --- without modifying the WaveScript compiler itself.  Also, we
  frequently want to add support for new hardware data-sources
  (sensors)\footnote{New data {\em souces} are not always convenient
  or possible to implement
  with the current foreign function interface.  In the future we will
  have a {\tt foreign\_box} syntax similar to {\tt foreign}, but
  allowing the user to write a WSSource class usable by the WaveScope engine.}.
\end{enumerate}

The WaveScript construct used to accomplish this is:
  ``{\tt foreign {\em <function-name>} in {\em <files>}}''.
The {\tt foreign} syntax can be used anywhere within a WaveScript
program.  It returns a WaveScript function representing the
corresponding C function.
For example, the following would import a function ``foo'' from ``foo.c''.

\begin{wscode}
c\_foo :: Int -> Int = foreign "foo" in ["foo.c"]
\end{wscode}

Note that, as when reading data from a file, the compiler has no way
to know the type of the external function, so an explicit type
annotation is required.

Currently C-code can be loaded from source files ({\tt .c}, {\tt
  .cpp}) or object files ({\tt .o}, {\tt .a}, {\tt .so}).  When
  loading from object files, it's necessary to also include a header
  ({\tt .h}, {\tt .hpp}).  For example:

\begin{wscode}
c\_bar :: Int -> Int = foreign "bar" in ["bar.h", "bar.a"]
\end{wscode}

Of course, you may want to import many functions from the same file or
library.  WaveScript uses a very simple rule.  If a file has already
been imported once, repeated imports are suppressed.  (This goes for
source and object files.)  Also, if you try to import multiple files with
the same basename (e.g. ``bar.o'' and ``bar.so'') the behavior is
currently undefined.

The foreign-function facility works under the {\bf Scheme} and {\bf
 C++/XStream} backends ({\tt ws} and {\tt wsc}).  The behavior differs
 slightly in that the Scheme system can only load shared-object files,
 thus when passed {\tt .o} or {\tt .a} files, it simply invokes a
 shell command to convert them to shared-object files before loading
 them.

Including source files also has a slightly different meaning between
the two backends.  Scheme will ignore header files (it doesn't need
them).  C source files ({\tt .c} or {\tt .cpp}) are compiled by
invoking the system's C compiler.  On the other hand, in the XStream backend, C source
files are simply {\tt \#include}d into the output C++ query file.  In
the former case, the source is compiled with no special link options
or compiler flags, and in the latter it is compiled under the same
environment as the C++ query file itself.

Thus, if the imported foreign functions require any customization of
the build environment whatsoever, it is recommended to compile them
yourself and import the object files into WaveScript, rather than
importing the C source files.

\rednote{[2007.05.03] Note: Currently the foreign function interface is only
supported on Linux platforms.  It also has very preliminary support
for Mac OS but is mostly subsection.}

\subsection{Converting WaveScript and C types}

An important feature of the foreign interface is that it defines a set
of mappings between WaveScript types and native C types.  The compiler
then automatically converts object representations where necessary.
This allows many C functions to be used without modification.  Figure
\ref{f:types} shows the mapping between C types and WaveScript types.

\begin{figure}
\begin{center}
\begin{tabular}{|r|r|l|}
\hline
$WaveScript$ & $C$ & $explanation$\\
\hline
{\tt Int}   & {\tt int}   & 
  \parbox[t]{2.2in}{native ints have a system-dependent 
length, note that in the emulator WaveScript {\tt Int}s may 
have less precision than C {\tt int}s} \\

{\tt Float} & {\tt float} & 
\parbox[t]{2.2in}{WaveScript floats are single-precision}\\

{\tt Bool} & {\tt bool} & \\

{\tt String} & {\tt char*} & pointer to null-terminated string \\

%()   & 

{\tt Char} & {\tt char} & (not implemented yet) \\

{\tt Array T} & {\tt $T$*} & \parbox[t]{2.2in}{
(not implemented yet) 
pointer to C representation of type {\tt T} 
}\\

{\tt Pointer} & {\tt void*} &  \parbox[t]{2.2in}{
(not implemented yet) Type for handling C-pointers.  Only good for
  passing back to C.
}\\

\hline
\end{tabular}
\end{center}
\caption{Mapping between WaveScript and C types.  Conversions
  performed automatically.}
\label{f:types}
\end{figure}

\rednote{[2007.05.03] The system will very soon support conversion of
  Complex, Int16, and Array types.  Further, it will provide a
  C-library for manipulating the representations of other WaveScript types.}


%================================================================================
\chapter{Signal Processing Libraries}

Most of the basic stream operators (window, rewindow, sync, etc) are
contained within ``stdlib.ws''.  Thus most programs will start with
{\tt include ``stdlib.ws''}.

\section{Fourier Transforms}

WaveScript uses fftw.  See prim\_defs.ss for a list of the different
fft interfaces provided.




\section{Matrix Operations}

WaveScript uses the Gnu Scientific Library to support matrix
operations.  There are three files of interest within the {\tt
wavescript/lib/} directory.  The first, {\tt gsl.ws} declares
prototypes for accessing a subset of the low level GSL functions
directly.  You shouldn't need to use this file directly.  The second,
{\tt matrix\_gsl.ws}, which you should use, provides a wrapper around
GSL's matrix functionality that's more in the spirit of WaveScript.
(Note that both of these files are generated by the C-preprocessor from
the corresponding {\tt .pp} files.)

The third file of interest is {\tt matrix.ws}.  This is a
native-WaveScript library that implements the basic matrix operations
described below using a simple array-of-arrays representation.  Except
for a few operations implemented only in the GSL-based version,
the libraries should be interchangeable.  You should choose which to
use based on the operations you need, availability of GSL on the
target platform, and performance requirements.
\rednote{Note: The GSL matrix library depends on the {\em
    ExclusivePtr} mechanism, which is not supported in the ML backends
    presently.}

\subsection{Other numeric types}

All of the below matrix operations are explained with the example of
32-bit floating point matrices.  These operators are contained in the
namespace {\tt Matrix:Float} and can may be referred to with fully
qualified names ({\tt Matrix:Float:add}) or by first importing the
namespace, ``{\tt using Matrix:Float};'', followed by only the short
name ``{\tt get}''.  Also included in the matrix library are analogous
routines in the {\tt Matrix:Complex} and {\tt Matrix:Double} namespaces.
\footnote{\rednote{(Currently, the {\tt invert} operation is available only for
{\tt Matrix:Double}.)}}

\subsection{Matrix Interface}

Here are the functions contained within the namespace {\tt
  Matrix:Float}.  On the left is a typical function call, with
  meaningful names for the arguments, and on the right is the
  WaveScript type of the function.  For brevity ``{\tt M}'' is used to
  abbreviate the type {\tt Matrix Float}, which in turn is a type
  alias for whatever the internal representation of a matrix is.

\[
\begin{array}{lcl}
\bullet$ $ $create$(dim1,dim2)     & :: &  $(Int, Int)                \ra   M$   \\
\bullet$ $ $eq$(m1, m2)            & :: &  $(M, M)          \ra   Bool$   \\
\bullet$ $ $get$(m, dim1, dim2)    & :: &  $(M, Int, Int)        \ra   Float$   \\
\bullet$ $ $set$(m, i, j, val)     & :: &  $(M, Int, Int, Float) \ra   ()$ \\
\bullet$ $ $dims$(m)               & :: &  $ M                   \ra   (Float * Float)$ \\
\bullet$ $ $row$(m,i)              & :: &  $ (M, Int)            \ra   Array Float$ \\
\bullet$ $ $col$(m,j)              & :: &  $ (M, Int)            \ra   Array Float$ \\
\bullet$ $ $toArray$(m)            & :: &  $ M                   \ra   Array Float $ \\
\bullet$ $ $fromArray$(arr,dim1)   & :: &  $ (Array Float, Int)       \ra   M $ \\
\bullet$ $ $fromArray2d$(arr,dim1) & :: &  $ (Array (Array Float))    \ra   M $ \\
\bullet$ $ $fromList2d$(arr,dim1)  & :: &  $ (List (List Float))    \ra   M $ \\
\end{array}
\]

This basic interface includes functions for creating a (zeroed)
matrix, accessing and mutating it, and converting to and from
one-dimensional (row-major) arrays, or from two-dimensional arrays and
lists.  A very important note about Array extraction operators such as
{\tt toArray}, {\tt row}, and {\tt column} is that they provide {\em
no guarantee} as to whether or not they return an alias to the
existing storage in the matrix, or newly allocated storage.  We need
to leave both these possibilities open because of the diversity of
possible backends, platforms, and matrix implementations.  Thus the
Arrays returned from these operations must be treated as {\em
immutable}.

In addition to the above basic matrix functions, the matrix library
namespace also includes common linear algebra matrix operations.

\[
\begin{array}{lcl}
\bullet$ $ $add$(m1, m2)           & :: &  $(M, M)          \ra   M$ \\
\bullet$ $ $sub$(m1, m2)           & :: &  $(M, M)          \ra   M$ \\
\bullet$ $ $mul\_elements$(m1, m2) & :: &  $(M, M)          \ra   M$ \\
\bullet$ $ $div\_elements$(m1, m2) & :: &  $(M, M)          \ra   M$ \\
\bullet$ $ $scale$(m, coef)        & :: &  $(M, Float)           \ra   M$ \\
\bullet$ $ $add\_constant$(m1, const) & :: &  $(M, Float)        \ra   M$ \\
\bullet$ $ $mul$(m)                & :: &  $ (M, M) \ra M  \ra   M$ \\
\bullet$ $ $invert$(m)             & :: &  $ M                   \ra   M$ \\
\end{array}
\]

The above operations are purely functional.  That is, they do not
destroy their arguments; they allocate new matrices to store the
results of their computations.  Because matrices can be large, this is
not always desirable.  The matrix library includes destructive, {\em
in place} versions of all the above operations (except {\tt mul} and
{\tt invert}): for example, {\tt add\_inplace}.  These mutate their
first argument and return unit, ``{\tt ()}'', rather than returning a
new matrix.
%They have the suffix ``\_inplace'' append to their names.

\subsubsection{Higher order matrix operations}

Below are additional {\em higher order} matrix operations (those that
take functions as arguments).

\[
\begin{array}{lcl}
\bullet$ $ $build$    & :: & $(Int, Int, (Int, Int) \ra Float) \ra M  $ \\
\bullet$ $ $foreach$  & :: & $(Float \ra (), M) \ra ()   $ \\
\bullet$ $ $foreachi$     & :: & $((Int, Int, Float) \ra (), M) \ra ()   $ \\
\bullet$ $ $rowmap$       & :: & $(Array Float \ra b, M) \ra Array b     $ \\
\bullet$ $ $map$          & :: & $(Float \ra Float, M) \ra M  $ \\
\bullet$ $ $map2$         & :: & $((Float,Float) \ra Float, M, M) \ra M  $  \\
\bullet$ $ $map\_inplace$  & :: & $(Float \ra Float, M) \ra ()           $ \\
\bullet$ $ $map2\_inplace$ & :: & $((Float,Float) \ra Float, M, M) \ra ()    $\\
\end{array}
\]

The {\tt build}, {\tt foreach}, {\tt foreachi}, and {\tt map}
operations follow the same conventions as the standard WaveScript
container operators of the same names.  For example, {\tt
build($rows$, $cols$, $f$)} builds a matrix of the specified size by
applying $f$ at every $(i,j)$ index pair.  Additionally, {\tt rowmap}
exposes each individual row as an array, and the ``inplace'' map
variants provide destructive updates.

\subsubsection{A note on polymorphism}

The operations contained in {\tt Matrix:Float} are {\em monomorphic}.
They operate only on matrices of floats.  This is due to the fact that
these are wrappers around non-polymorphic native C routines.  While
the pure WaveScript matrix implementation provides these monomorphic
interfaces for compatibility, it also provides polymorphic operations
directly under the {\tt Matrix} namespace (i.e. {\tt Matrix:add}).
There are definite advantages to the polymorphic interface.  For
example, the {\tt Matrix:map} function can be used to apply a function
$f :: $Float$ \ra $Complex to build a complex matrix from a float
matrix.  The monomorphic versions can only apply map float matrices to
float matrices and complex to complex.

\subsubsection{Going further: other GSL functionality}

The GSL libraries contained a wealth of functionality not currently
exposed in WaveScript.  It is straightforward to extend {\tt gsl.ws}
to export more of this functionality, but there has not been the
opportunity or need to do so at the moment.  You can see the GSL
documentation here:

\vspace{-2mm}
\begin{center}
\url{http://www.gnu.org/software/gsl/manual/html_node/}
\end{center}

If there's something you need, bug Ryan to add
it (\url{newton@mit.edu}), or take a look at {\tt gsl.ws.pp} and {\tt matrix\_gsl.ws.pp} and
try to add it yourself.


\chapter{WaveScript Evaluation Model}

WaveScript is a {\em metaprogramming} language.  For further
explanation, I'll refer you to a quote from the {\em Matrix Reloaded}
that was brought to my attention by Yannis Smaragdakis.

\begin{center}
NEO: Programs hacking programs. Why?

ORACLE: They have their reasons, ...
\end{center}

The {\em reason} in WaveScript, is that we want to write programs of a
different character than we want to {\em run}.
We want to {\em write}
abstract, reusable, polymorphic, higher-order programs, but we want to
{\em run} fast, monomorphic, first-order, C-programs representing
parallelizable dataflow graphs.
In WaveScript your program essentially {\em
generates} the specialized, high-performance stream-processing
program that is subsequently compiled and run.  


How does this work?  Currently {\em all} user defined functions (as
described in section \ref{udfs}) {\bf will be inlined at metaprogram
evaluation}.  What results is a dataflow graph of {\tt iterate} blocks.
Thus, only bounded-recursions are permitted in user defined functions,
and excessive code bloat becomes a real possibility.  In the future, we will
allow a ``noinline'' or ``library function'' annotation that specifies
that a function is to be compiled as a C-function, rather than
inlined.  Of course, such a function will not be allowed to take or
return {\tt Stream} values.

\rednote{\em \bf Keep the metaprogram pure! (free of side-effects)}

\section{Debugging}



%% pos#0: 
%% seg-get: index 474 is out of bounds for sigseg:
%% #<struct:sigseg>

%%  === context ===
%% /Users/newton/wavescript/src/generic/sim/wavescript_sim_library_push.ss:1314:5: seg-get
%% /Users/newton/temp/__lang_running.tmp.ss:359:30
%% /Users/newton/wavescript/src/generic/sim/wavescript_sim_library_push.ss:357:6: wsbox
%% /Users/newton/wavescript/src/generic/sim/wavescript_sim_library_push.ss:282:13: global-loop



\end{document}
