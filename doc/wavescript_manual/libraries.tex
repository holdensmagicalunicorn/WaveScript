
\chapter{Standard Libraries}

\section{{\tt stdlib.ws}}

Most of the basic stream operators (window, rewindow, sync, etc) are
contained within ``stdlib.ws''.  Thus most programs will start with
{\tt include ``stdlib.ws''}.  The file is contained within the {\tt
  lib/} subdirectory of the WaveScript root.
The top portion of the file contains type signatures for all the
functions exported by the library.  Further down, above each
definition, should be a brief explanation of its function.

Here is a high level overview of the functionality provided by
{\tt stdlib.ws} as of [2007.08.24]:

\begin{itemize}
\item Stream operators: snoop on streams, zip streams together, sync them, window,
  rewindow, and dewindow them.  Interleave and deinterleave the
  elements of streams.
\item Sigseg operators: map functions over them, lift some operations
  like fft to work on sigsegs.
\item Basic math functions that are not included as primitive.
\item Prints, asserts, and constant definitions (e.g. $\pi$).
\item Extended list and array operations not included as primitive (e.g. {\tt List:map2}).
\item Shorthands for common procedures (e.g. {\tt i2f} for {\tt intToFloat}).
\item Curried versions of higher order operators.
\end{itemize}


\section{Fourier Transforms}

WaveScript uses fftw.  See prim\_defs.ss for a list of the different
fft interfaces provided.




\section{Matrix Operations}

WaveScript uses the Gnu Scientific Library to support matrix
operations.  There are three files of interest within the {\tt
wavescript/lib/} directory.  The first, {\tt gsl.ws} declares
prototypes for accessing a subset of the low level GSL functions
directly.  You shouldn't need to use this file directly.  The second,
{\tt matrix\_gsl.ws}, which you should use, provides a wrapper around
GSL's matrix functionality that's more in the spirit of WaveScript.
(Note that both of these files are generated by the C-preprocessor from
the corresponding {\tt .pp} files.)

The third file of interest is {\tt matrix.ws}.  This is a
native-WaveScript library that implements the basic matrix operations
described below using a simple array-of-arrays representation.  Except
for a few operations implemented only in the GSL-based version,
the libraries should be interchangeable.  You should choose which to
use based on the operations you need, availability of GSL on the
target platform, and performance requirements.

\subsection{Other numeric types}

All of the below matrix operations are explained with the example of
32-bit floating point matrices.  These operators are contained in the
namespace {\tt Matrix:Float} and can may be referred to with fully
qualified names ({\tt Matrix:Float:add}) or by first importing the
namespace, ``{\tt using Matrix:Float};'', followed by only the short
name ``{\tt get}''.  Also included in the matrix library are analogous
routines in the {\tt Matrix:Complex} and {\tt Matrix:Double} namespaces.
\footnote{\rednote{(Currently, the {\tt invert} operation is available only for
{\tt Matrix:Double}.)}}

\subsection{Matrix Interface}

Here are the functions contained within the namespace {\tt
  Matrix:Float}.  On the left is a typical function call, with
  meaningful names for the arguments, and on the right is the
  WaveScript type of the function.  For brevity ``{\tt M}'' is used to
  abbreviate the type {\tt Matrix Float}, which in turn is a type
  alias for whatever the internal representation of a matrix is.

\[
\begin{array}{lcl}
\bullet$ $ $create$(dim1,dim2)     & :: &  $(Int, Int)                \ra   M$   \\
\bullet$ $ $eq$(m1, m2)            & :: &  $(M, M)          \ra   Bool$   \\
\bullet$ $ $get$(m, dim1, dim2)    & :: &  $(M, Int, Int)        \ra   Float$   \\
\bullet$ $ $set$(m, i, j, val)     & :: &  $(M, Int, Int, Float) \ra   ()$ \\
\bullet$ $ $dims$(m)               & :: &  $ M                   \ra   (Float * Float)$ \\
\bullet$ $ $row$(m,i)              & :: &  $ (M, Int)            \ra   Array Float$ \\
\bullet$ $ $col$(m,j)              & :: &  $ (M, Int)            \ra   Array Float$ \\
\bullet$ $ $toArray$(m)            & :: &  $ M                   \ra   Array Float $ \\
\bullet$ $ $fromArray$(arr,dim1)   & :: &  $ (Array Float, Int)       \ra   M $ \\
\bullet$ $ $fromArray2d$(arr,dim1) & :: &  $ (Array (Array Float))    \ra   M $ \\
\bullet$ $ $fromList2d$(arr,dim1)  & :: &  $ (List (List Float))    \ra   M $ \\
\end{array}
\]

This basic interface includes functions for creating a (zeroed)
matrix, accessing and mutating it, and converting to and from
one-dimensional (row-major) arrays, or from two-dimensional arrays and
lists.  A very important note about Array extraction operators such as
{\tt toArray}, {\tt row}, and {\tt column} is that they provide {\em
no guarantee} as to whether or not they return an alias to the
existing storage in the matrix, or newly allocated storage.  We need
to leave both these possibilities open because of the diversity of
possible backends, platforms, and matrix implementations.  Thus the
Arrays returned from these operations must be treated as {\em
immutable}.

In addition to the above basic matrix functions, the matrix library
namespace also includes common linear algebra matrix operations.

\[
\begin{array}{lcl}
\bullet$ $ $add$(m1, m2)           & :: &  $(M, M)          \ra   M$ \\
\bullet$ $ $sub$(m1, m2)           & :: &  $(M, M)          \ra   M$ \\
\bullet$ $ $mul\_elements$(m1, m2) & :: &  $(M, M)          \ra   M$ \\
\bullet$ $ $div\_elements$(m1, m2) & :: &  $(M, M)          \ra   M$ \\
\bullet$ $ $scale$(m, coef)        & :: &  $(M, Float)           \ra   M$ \\
\bullet$ $ $add\_constant$(m1, const) & :: &  $(M, Float)        \ra   M$ \\
\bullet$ $ $mul$(m)                & :: &  $ (M, M) \ra M  \ra   M$ \\
\bullet$ $ $invert$(m)             & :: &  $ M                   \ra   M$ \\
\end{array}
\]

The above operations are purely functional.  That is, they do not
destroy their arguments; they allocate new matrices to store the
results of their computations.  Because matrices can be large, this is
not always desirable.  The matrix library includes destructive, {\em
in place} versions of all the above operations (except {\tt mul} and
{\tt invert}): for example, {\tt add\_inplace}.  These mutate their
first argument and return unit, ``{\tt ()}'', rather than returning a
new matrix.
%They have the suffix ``\_inplace'' append to their names.

\subsubsection{Higher order matrix operations}

Below are additional {\em higher order} matrix operations (those that
take functions as arguments).

\[
\begin{array}{lcl}
\bullet$ $ $build$    & :: & $(Int, Int, (Int, Int) \ra Float) \ra M  $ \\
\bullet$ $ $foreach$  & :: & $(Float \ra (), M) \ra ()   $ \\
\bullet$ $ $foreachi$     & :: & $((Int, Int, Float) \ra (), M) \ra ()   $ \\
\bullet$ $ $rowmap$       & :: & $(Array Float \ra b, M) \ra Array b     $ \\
\bullet$ $ $map$          & :: & $(Float \ra Float, M) \ra M  $ \\
\bullet$ $ $map2$         & :: & $((Float,Float) \ra Float, M, M) \ra M  $  \\
\bullet$ $ $map\_inplace$  & :: & $(Float \ra Float, M) \ra ()           $ \\
\bullet$ $ $map2\_inplace$ & :: & $((Float,Float) \ra Float, M, M) \ra ()    $\\
\end{array}
\]

The {\tt build}, {\tt foreach}, {\tt foreachi}, and {\tt map}
operations follow the same conventions as the standard WaveScript
container operators of the same names.  For example, {\tt
build($rows$, $cols$, $f$)} builds a matrix of the specified size by
applying $f$ at every $(i,j)$ index pair.  Additionally, {\tt rowmap}
exposes each individual row as an array, and the ``inplace'' map
variants provide destructive updates.

\subsubsection{A note on polymorphism}

The operations contained in {\tt Matrix:Float} are {\em monomorphic}.
They operate only on matrices of floats.  This is due to the fact that
these are wrappers around non-polymorphic native C routines.  While
the pure WaveScript matrix implementation provides these monomorphic
interfaces for compatibility, it also provides polymorphic operations
directly under the {\tt Matrix} namespace (i.e. {\tt Matrix:add}).
There are definite advantages to the polymorphic interface.  For
example, the {\tt Matrix:map} function can be used to apply a function
$f :: $Float$ \ra $Complex to build a complex matrix from a float
matrix.  The monomorphic versions can only apply map float matrices to
float matrices and complex to complex.

\subsubsection{Going further: other GSL functionality}

The GSL libraries contained a wealth of functionality not currently
exposed in WaveScript.  It is straightforward to extend {\tt gsl.ws}
to export more of this functionality, but there has not been the
opportunity or need to do so at the moment.  You can see the GSL
documentation here:

\vspace{-2mm}
\begin{center}
\url{http://www.gnu.org/software/gsl/manual/html_node/}
\end{center}

If there's something you need, bug Ryan to add
it (\url{newton@mit.edu}), or take a look at {\tt gsl.ws.pp} and {\tt matrix\_gsl.ws.pp} and
try to add it yourself.

